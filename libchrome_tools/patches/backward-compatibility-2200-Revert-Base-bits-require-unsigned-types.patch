From 06edc65eeef138368837f806e40d6e12200b27eb Mon Sep 17 00:00:00 2001
From: Byron Lee <byronlee@google.com>
Date: Thu, 30 Nov 2023 07:32:46 +0000
Subject: [PATCH] Revert "Use concepts to clean base/bits.h, require unsigned
 types"

This reverts commit e5b0ae4f37568f472a9f1c2e7a86174572b591fa.
---
 base/bits.h                   | 81 +++++++----------------------------
 base/bits_unittest.cc         | 44 +++++++++----------
 base/files/file_util_posix.cc |  4 +-
 3 files changed, 37 insertions(+), 92 deletions(-)

diff --git a/base/bits.h b/base/bits.h
index eaae98b073..ecab9376af 100644
--- a/base/bits.h
+++ b/base/bits.h
@@ -11,35 +11,16 @@
 #include <stdint.h>
 
 #include <bit>
-#include <concepts>
+#include <type_traits>
 
 #include "base/check.h"
 
 namespace base::bits {
 
-// Bit functions in <bit> are restricted to a specific set of types of unsigned
-// integer; restrict functions in this file that are related to those in that
-// header to match for consistency.
-template <typename T>
-concept UnsignedInteger =
-    std::unsigned_integral<T> && !std::same_as<T, bool> &&
-    !std::same_as<T, char> && !std::same_as<T, char8_t> &&
-    !std::same_as<T, char16_t> && !std::same_as<T, char32_t> &&
-    !std::same_as<T, wchar_t>;
-
-// We want to migrate all users of these functions to use the unsigned type
-// versions of the functions, but until they are all moved over, create a
-// concept that captures all the types that must be supported for compatibility
-// but that we want to remove.
-template <typename T>
-concept SignedIntegerDeprecatedDoNotUse =
-    std::integral<T> && !UnsignedInteger<T>;
-
 // Returns true iff |value| is a power of 2.
 //
 // TODO(https://crbug.com/1414634): Replace with std::has_single_bit().
-template <typename T>
-  requires UnsignedInteger<T>
+template <typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
 constexpr bool IsPowerOfTwo(T value) {
   // From "Hacker's Delight": Section 2.1 Manipulating Rightmost Bits.
   //
@@ -50,55 +31,31 @@ constexpr bool IsPowerOfTwo(T value) {
   return value > 0 && (value & (value - 1)) == 0;
 }
 
-template <typename T>
-  requires SignedIntegerDeprecatedDoNotUse<T>
-constexpr bool IsPowerOfTwoDeprecatedDoNotUse(T value) {
-  return value > 0 && (value & (value - 1)) == 0;
-}
-
 // Round down |size| to a multiple of alignment, which must be a power of two.
-template <typename T>
-  requires UnsignedInteger<T>
-inline constexpr T AlignDown(T size, T alignment) {
+template <typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
+constexpr T AlignDown(T size, T alignment) {
   DCHECK(IsPowerOfTwo(alignment));
   return size & ~(alignment - 1);
 }
 
-template <typename T>
-  requires SignedIntegerDeprecatedDoNotUse<T>
-inline constexpr T AlignDownDeprecatedDoNotUse(T size, T alignment) {
-  DCHECK(IsPowerOfTwoDeprecatedDoNotUse(alignment));
-  return size & ~(alignment - 1);
-}
-
 // Move |ptr| back to the previous multiple of alignment, which must be a power
 // of two. Defined for types where sizeof(T) is one byte.
-template <typename T>
-  requires(sizeof(T) == 1)
+template <typename T, typename = std::enable_if_t<sizeof(T) == 1>>
 inline T* AlignDown(T* ptr, uintptr_t alignment) {
   return reinterpret_cast<T*>(
       AlignDown(reinterpret_cast<uintptr_t>(ptr), alignment));
 }
 
 // Round up |size| to a multiple of alignment, which must be a power of two.
-template <typename T>
-  requires UnsignedInteger<T>
-inline constexpr T AlignUp(T size, T alignment) {
+template <typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
+constexpr T AlignUp(T size, T alignment) {
   DCHECK(IsPowerOfTwo(alignment));
   return (size + alignment - 1) & ~(alignment - 1);
 }
 
-template <typename T>
-  requires SignedIntegerDeprecatedDoNotUse<T>
-inline constexpr T AlignUpDeprecatedDoNotUse(T size, T alignment) {
-  DCHECK(IsPowerOfTwoDeprecatedDoNotUse(alignment));
-  return (size + alignment - 1) & ~(alignment - 1);
-}
-
 // Advance |ptr| to the next multiple of alignment, which must be a power of
 // two. Defined for types where sizeof(T) is one byte.
-template <typename T>
-  requires(sizeof(T) == 1)
+template <typename T, typename = std::enable_if_t<sizeof(T) == 1>>
 inline T* AlignUp(T* ptr, uintptr_t alignment) {
   return reinterpret_cast<T*>(
       AlignUp(reinterpret_cast<uintptr_t>(ptr), alignment));
@@ -106,24 +63,16 @@ inline T* AlignUp(T* ptr, uintptr_t alignment) {
 
 // Returns the integer i such as 2^i <= n < 2^(i+1).
 //
-// A common use for this function is to measure the number of bits required to
-// contain a value; for that case use std::bit_width().
+// There is a common `BitLength` function, which returns the number of bits
+// required to represent a value. Rather than implement that function,
+// use `Log2Floor` and add 1 to the result.
 //
-// A common use for this function is to take its result and use it to left-shift
-// a bit; instead of doing so, use std::bit_floor().
-// TODO(https://crbug.com/1414634): Replace existing uses that do that.
+// TODO(https://crbug.com/1414634): Replace with std::bit_xxx().
 constexpr int Log2Floor(uint32_t n) {
   return 31 - std::countl_zero(n);
 }
 
 // Returns the integer i such as 2^(i-1) < n <= 2^i.
-//
-// A common use for this function is to measure the number of bits required to
-// contain a value; for that case use std::bit_width().
-//
-// A common use for this function is to take its result and use it to left-shift
-// a bit; instead of doing so, use std::bit_ceil().
-// TODO(https://crbug.com/1414634): Replace existing uses that do that.
 constexpr int Log2Ceiling(uint32_t n) {
   // When n == 0, we want the function to return -1.
   // When n == 0, (n - 1) will underflow to 0xFFFFFFFF, which is
@@ -132,11 +81,11 @@ constexpr int Log2Ceiling(uint32_t n) {
 }
 
 // Returns a value of type T with a single bit set in the left-most position.
-// Can be used instead of manually shifting a 1 to the left. Unlike the other
-// functions in this file, usable for any integral type.
+// Can be used instead of manually shifting a 1 to the left.
 template <typename T>
-  requires std::integral<T>
 constexpr T LeftmostBit() {
+  static_assert(std::is_integral_v<T>,
+                "This function can only be used with integral types.");
   T one(1u);
   return one << (8 * sizeof(T) - 1);
 }
diff --git a/base/bits_unittest.cc b/base/bits_unittest.cc
index 527aac1911..b1f9f8ea57 100644
--- a/base/bits_unittest.cc
+++ b/base/bits_unittest.cc
@@ -5,6 +5,7 @@
 // This file contains the unit tests for the bit utilities.
 
 #include "base/bits.h"
+#include "build/build_config.h"
 
 #include <stddef.h>
 
@@ -50,12 +51,12 @@ TEST(BitsTest, Log2Ceiling) {
 
 TEST(BitsTest, AlignUp) {
   static constexpr size_t kSizeTMax = std::numeric_limits<size_t>::max();
-  EXPECT_EQ(0u, AlignUp(0u, 4u));
-  EXPECT_EQ(4u, AlignUp(1u, 4u));
-  EXPECT_EQ(4096u, AlignUp(1u, 4096u));
-  EXPECT_EQ(4096u, AlignUp(4096u, 4096u));
-  EXPECT_EQ(4096u, AlignUp(4095u, 4096u));
-  EXPECT_EQ(8192u, AlignUp(4097u, 4096u));
+  EXPECT_EQ(0, AlignUp(0, 4));
+  EXPECT_EQ(4, AlignUp(1, 4));
+  EXPECT_EQ(4096, AlignUp(1, 4096));
+  EXPECT_EQ(4096, AlignUp(4096, 4096));
+  EXPECT_EQ(4096, AlignUp(4095, 4096));
+  EXPECT_EQ(8192, AlignUp(4097, 4096));
   EXPECT_EQ(kSizeTMax - 31, AlignUp(kSizeTMax - 62, size_t{32}));
   EXPECT_EQ(kSizeTMax / 2 + 1, AlignUp(size_t{1}, kSizeTMax / 2 + 1));
 }
@@ -83,12 +84,12 @@ TEST(BitsTest, AlignUpPointer) {
 
 TEST(BitsTest, AlignDown) {
   static constexpr size_t kSizeTMax = std::numeric_limits<size_t>::max();
-  EXPECT_EQ(0u, AlignDown(0u, 4u));
-  EXPECT_EQ(0u, AlignDown(1u, 4u));
-  EXPECT_EQ(0u, AlignDown(1u, 4096u));
-  EXPECT_EQ(4096u, AlignDown(4096u, 4096u));
-  EXPECT_EQ(0u, AlignDown(4095u, 4096u));
-  EXPECT_EQ(4096u, AlignDown(4097u, 4096u));
+  EXPECT_EQ(0, AlignDown(0, 4));
+  EXPECT_EQ(0, AlignDown(1, 4));
+  EXPECT_EQ(0, AlignDown(1, 4096));
+  EXPECT_EQ(4096, AlignDown(4096, 4096));
+  EXPECT_EQ(0, AlignDown(4095, 4096));
+  EXPECT_EQ(4096, AlignDown(4097, 4096));
   EXPECT_EQ(kSizeTMax - 63, AlignDown(kSizeTMax - 62, size_t{32}));
   EXPECT_EQ(kSizeTMax - 31, AlignDown(kSizeTMax, size_t{32}));
   EXPECT_EQ(0ul, AlignDown(size_t{1}, kSizeTMax / 2 + 1));
@@ -118,9 +119,10 @@ TEST(BitsTest, AlignDownPointer) {
 }
 
 TEST(BitsTest, PowerOfTwo) {
-  EXPECT_FALSE(IsPowerOfTwo(0u));
-  EXPECT_TRUE(IsPowerOfTwo(1u));
-  EXPECT_TRUE(IsPowerOfTwo(2u));
+  EXPECT_FALSE(IsPowerOfTwo(-1));
+  EXPECT_FALSE(IsPowerOfTwo(0));
+  EXPECT_TRUE(IsPowerOfTwo(1));
+  EXPECT_TRUE(IsPowerOfTwo(2));
   // Unsigned 64 bit cases.
   for (uint32_t i = 2; i < 64; i++) {
     const uint64_t val = uint64_t{1} << i;
@@ -128,19 +130,15 @@ TEST(BitsTest, PowerOfTwo) {
     EXPECT_TRUE(IsPowerOfTwo(val));
     EXPECT_FALSE(IsPowerOfTwo(val + 1));
   }
-}
-
-TEST(BitsTest, PowerOfTwoDeprecatedDoNotUse) {
-  EXPECT_FALSE(IsPowerOfTwoDeprecatedDoNotUse(-1));
   // Signed 64 bit cases.
   for (uint32_t i = 2; i < 63; i++) {
     const int64_t val = int64_t{1} << i;
-    EXPECT_FALSE(IsPowerOfTwoDeprecatedDoNotUse(val - 1));
-    EXPECT_TRUE(IsPowerOfTwoDeprecatedDoNotUse(val));
-    EXPECT_FALSE(IsPowerOfTwoDeprecatedDoNotUse(val + 1));
+    EXPECT_FALSE(IsPowerOfTwo(val - 1));
+    EXPECT_TRUE(IsPowerOfTwo(val));
+    EXPECT_FALSE(IsPowerOfTwo(val + 1));
   }
   // Signed integers with only the last bit set are negative, not powers of two.
-  EXPECT_FALSE(IsPowerOfTwoDeprecatedDoNotUse(int64_t{1} << 63));
+  EXPECT_FALSE(IsPowerOfTwo(int64_t{1} << 63));
 }
 
 TEST(BitsTest, LeftMostBit) {
diff --git a/base/files/file_util_posix.cc b/base/files/file_util_posix.cc
index 804911bea4..acb98a7e3e 100644
--- a/base/files/file_util_posix.cc
+++ b/base/files/file_util_posix.cc
@@ -1034,9 +1034,7 @@ bool AllocateFileRegion(File* file, int64_t offset, size_t size) {
   blksize_t block_size = 512;  // Start with something safe.
   stat_wrapper_t statbuf;
   if (File::Fstat(file->GetPlatformFile(), &statbuf) == 0 &&
-      statbuf.st_blksize > 0 &&
-      base::bits::IsPowerOfTwo(
-          base::checked_cast<uint64_t>(statbuf.st_blksize))) {
+      statbuf.st_blksize > 0 && base::bits::IsPowerOfTwo(statbuf.st_blksize)) {
     block_size = static_cast<blksize_t>(statbuf.st_blksize);
   }
 
-- 
2.43.0.rc1.413.gea7ed67945-goog

