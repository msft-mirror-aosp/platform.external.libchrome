From 1fefcf7ab47b8bc07726bcfa9068a61a270cd10a Mon Sep 17 00:00:00 2001
From: Jeff Lin <jeffulin@google.com>
Date: Wed, 26 Jul 2023 15:14:10 +0800
Subject: [PATCH] Revert "Making ChromeOS guests RT-friendly series CLs"

This reverts the following commits:

5e9aa19020 base/threading: Fix setting of RT for kRealTimeAudio for Linux
3e8c4f660e base/threading: Separate ChromeOS-specific Linux code from vanilla Linux
0d36fb171f base/threading: Split out NACL/AIX code out of Linux
ef5c20e13e base/threading: Split out the PlatformThread class into platform-specific classes

These commits are in the series of b/262267726.

Change-Id: I54e855d3360111c2ccf5ee7b70e7ca605843c112
---
 base/threading/platform_thread.cc            |  12 +-
 base/threading/platform_thread.h             |  90 ++---
 base/threading/platform_thread_android.cc    |   2 +-
 base/threading/platform_thread_cros.cc       | 272 --------------
 base/threading/platform_thread_linux.cc      | 358 ++++++++++++++++---
 base/threading/platform_thread_linux_base.cc |  31 --
 base/threading/platform_thread_posix.cc      |  28 +-
 7 files changed, 359 insertions(+), 434 deletions(-)
 delete mode 100644 base/threading/platform_thread_cros.cc
 delete mode 100644 base/threading/platform_thread_linux_base.cc

diff --git a/base/threading/platform_thread.cc b/base/threading/platform_thread.cc
index 1bc5ee15bf..d96b2237df 100644
--- a/base/threading/platform_thread.cc
+++ b/base/threading/platform_thread.cc
@@ -3,7 +3,6 @@
 // found in the LICENSE file.
 
 #include "base/threading/platform_thread.h"
-#include "base/threading/thread_id_name_manager.h"
 
 #include "base/task/current_thread.h"
 #include "third_party/abseil-cpp/absl/base/attributes.h"
@@ -22,7 +21,7 @@ ABSL_CONST_INIT thread_local ThreadType current_thread_type =
 }  // namespace
 
 // static
-void PlatformThreadBase::SetCurrentThreadType(ThreadType thread_type) {
+void PlatformThread::SetCurrentThreadType(ThreadType thread_type) {
   MessagePumpType message_pump_type = MessagePumpType::DEFAULT;
   if (CurrentIOThread::IsSet()) {
     message_pump_type = MessagePumpType::IO;
@@ -36,12 +35,12 @@ void PlatformThreadBase::SetCurrentThreadType(ThreadType thread_type) {
 }
 
 // static
-ThreadType PlatformThreadBase::GetCurrentThreadType() {
+ThreadType PlatformThread::GetCurrentThreadType() {
   return current_thread_type;
 }
 
 // static
-absl::optional<TimeDelta> PlatformThreadBase::GetThreadLeewayOverride() {
+absl::optional<TimeDelta> PlatformThread::GetThreadLeewayOverride() {
 #if BUILDFLAG(IS_FUCHSIA)
   // On Fuchsia, all audio threads run with the CPU scheduling profile that uses
   // an interval of |kAudioSchedulingPeriod|. Using the default leeway may lead
@@ -53,11 +52,6 @@ absl::optional<TimeDelta> PlatformThreadBase::GetThreadLeewayOverride() {
   return absl::nullopt;
 }
 
-// static
-void PlatformThreadBase::SetNameCommon(const std::string& name) {
-  ThreadIdNameManager::GetInstance()->SetName(name);
-}
-
 namespace internal {
 
 void SetCurrentThreadType(ThreadType thread_type,
diff --git a/base/threading/platform_thread.h b/base/threading/platform_thread.h
index 88714870a2..a7553e1a12 100644
--- a/base/threading/platform_thread.h
+++ b/base/threading/platform_thread.h
@@ -132,17 +132,18 @@ enum class ThreadPriorityForTest : int {
   kMaxValue = kRealtimeAudio,
 };
 
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+class ThreadTypeDelegate;
+#endif
+
 // A namespace for low-level thread functions.
-class BASE_EXPORT PlatformThreadBase {
+class BASE_EXPORT PlatformThread {
  public:
   // Implement this interface to run code on a background thread.  Your
   // ThreadMain method will be called on the newly created thread.
   class BASE_EXPORT Delegate {
    public:
-    virtual void ThreadMain() = 0;
-
 #if BUILDFLAG(IS_APPLE)
-    // TODO: Move this to the PlatformThreadApple class.
     // The interval at which the thread expects to have work to do. Zero if
     // unknown. (Example: audio buffer duration for real-time audio.) Is used to
     // optimize the thread real-time behavior. Is called on the newly created
@@ -150,13 +151,15 @@ class BASE_EXPORT PlatformThreadBase {
     virtual TimeDelta GetRealtimePeriod();
 #endif
 
+    virtual void ThreadMain() = 0;
+
    protected:
     virtual ~Delegate() = default;
   };
 
-  PlatformThreadBase() = delete;
-  PlatformThreadBase(const PlatformThreadBase&) = delete;
-  PlatformThreadBase& operator=(const PlatformThreadBase&) = delete;
+  PlatformThread() = delete;
+  PlatformThread(const PlatformThread&) = delete;
+  PlatformThread& operator=(const PlatformThread&) = delete;
 
   // Gets the current thread id, which may be useful for logging purposes.
   static PlatformThreadId CurrentId();
@@ -264,37 +267,7 @@ class BASE_EXPORT PlatformThreadBase {
   // Returns the override of task leeway if any.
   static absl::optional<TimeDelta> GetThreadLeewayOverride();
 
-  // Returns the default thread stack size set by chrome. If we do not
-  // explicitly set default size then returns 0.
-  static size_t GetDefaultThreadStackSize();
-
-  static ThreadPriorityForTest GetCurrentThreadPriorityForTest();
-
-  protected:
-  static void SetNameCommon(const std::string& name);
-};
-
-#if BUILDFLAG(IS_APPLE)
-class BASE_EXPORT PlatformThreadApple : public PlatformThreadBase {
- public:
-  // Stores the period value in TLS.
-  static void SetCurrentThreadRealtimePeriodValue(TimeDelta realtime_period);
-
-  // Signals that the feature list has been initialized which allows to check
-  // the feature's value now and initialize state. This prevents race
-  // conditions where the feature is being checked while it is being
-  // initialized, which can cause a crash.
-  static void InitFeaturesPostFieldTrial();
-};
-#endif  // BUILDFLAG(IS_APPLE)
-
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
-class ThreadTypeDelegate;
-
-class BASE_EXPORT PlatformThreadLinux : public PlatformThreadBase {
- public:
-  static constexpr struct sched_param kRealTimePrio = {8};
-
   // Sets a delegate which handles thread type changes for this process. This
   // must be externally synchronized with any call to SetCurrentThreadType.
   static void SetThreadTypeDelegate(ThreadTypeDelegate* delegate);
@@ -311,41 +284,28 @@ class BASE_EXPORT PlatformThreadLinux : public PlatformThreadBase {
   static void SetThreadType(PlatformThreadId process_id,
                             PlatformThreadId thread_id,
                             ThreadType thread_type);
+#endif
 
-  // For a given thread id and thread type, setup the cpuset and schedtune
-  // CGroups for the thread.
-  static void SetThreadCgroupsForThreadType(PlatformThreadId thread_id,
-                                            ThreadType thread_type);
-};
-#endif  // BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
-
-#if BUILDFLAG(IS_CHROMEOS)
-class BASE_EXPORT PlatformThreadChromeOS : public PlatformThreadLinux {
- public:
-  // Signals that the feature list has been initialized. Used for preventing
-  // race conditions and crashes, see comments in PlatformThreadApple.
+#if BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_APPLE)
+  // Signals that the feature list has been initialized which allows to check
+  // the feature's value now and initialize state. This prevents race
+  // conditions where the feature is being checked while it is being
+  // initialized, which can cause a crash.
   static void InitFeaturesPostFieldTrial();
+#endif
 
-  // Toggles a specific thread's type at runtime. This is the ChromeOS-specific
-  // version and includes Linux's functionality but does slightly more. See
-  // PlatformThreadLinux's SetThreadType() header comment for Linux details.
-  static void SetThreadType(PlatformThreadId process_id,
-                            PlatformThreadId thread_id,
-                            ThreadType thread_type);
-};
-#endif  // BUILDFLAG(IS_CHROMEOS)
+  // Returns the default thread stack size set by chrome. If we do not
+  // explicitly set default size then returns 0.
+  static size_t GetDefaultThreadStackSize();
 
-// Alias to the correct platform-specific class based on preprocessor directives
 #if BUILDFLAG(IS_APPLE)
-using PlatformThread = PlatformThreadApple;
-#elif BUILDFLAG(IS_CHROMEOS)
-using PlatformThread = PlatformThreadChromeOS;
-#elif BUILDFLAG(IS_LINUX)
-using PlatformThread = PlatformThreadLinux;
-#else
-using PlatformThread = PlatformThreadBase;
+  // Stores the period value in TLS.
+  static void SetCurrentThreadRealtimePeriodValue(TimeDelta realtime_period);
 #endif
 
+  static ThreadPriorityForTest GetCurrentThreadPriorityForTest();
+};
+
 namespace internal {
 
 void SetCurrentThreadType(ThreadType thread_type,
diff --git a/base/threading/platform_thread_android.cc b/base/threading/platform_thread_android.cc
index 0d0609966b..594bae9f6d 100644
--- a/base/threading/platform_thread_android.cc
+++ b/base/threading/platform_thread_android.cc
@@ -87,7 +87,7 @@ GetCurrentThreadPriorityForPlatformForTest() {
 }  // namespace internal
 
 void PlatformThread::SetName(const std::string& name) {
-  SetNameCommon(name);
+  ThreadIdNameManager::GetInstance()->SetName(name);
 
   // Like linux, on android we can get the thread names to show up in the
   // debugger by setting the process name for the LWP.
diff --git a/base/threading/platform_thread_cros.cc b/base/threading/platform_thread_cros.cc
deleted file mode 100644
index 28e6407820..0000000000
--- a/base/threading/platform_thread_cros.cc
+++ /dev/null
@@ -1,272 +0,0 @@
-// Copyright 2023 The Chromium Authors
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-// Description: ChromeOS specific Linux code layered on top of
-// base/threading/platform_thread_linux{,_base}.cc.
-
-#include "base/threading/platform_thread.h"
-#include "base/threading/platform_thread_internal_posix.h"
-
-#include "base/base_switches.h"
-#include "base/command_line.h"
-#include "base/files/file_util.h"
-#include "base/metrics/field_trial_params.h"
-#include "base/process/internal_linux.h"
-#include "base/strings/stringprintf.h"
-
-#include <sys/resource.h>
-
-namespace base {
-
-BASE_FEATURE(kSchedUtilHints,
-             "SchedUtilHints",
-             base::FEATURE_ENABLED_BY_DEFAULT);
-
-namespace {
-
-std::atomic<bool> g_use_sched_util(true);
-std::atomic<bool> g_scheduler_hints_adjusted(false);
-
-// When a device doesn't specify uclamp values via chrome switches,
-// default boosting for urgent tasks is hardcoded here as 20%.
-// Higher values can lead to higher power consumption thus this value
-// is chosen conservatively where it does not show noticeable
-// power usage increased from several perf/power tests.
-const int kSchedulerBoostDef = 20;
-const int kSchedulerLimitDef = 100;
-const bool kSchedulerUseLatencyTuneDef = true;
-
-int g_scheduler_boost_adj;
-int g_scheduler_limit_adj;
-bool g_scheduler_use_latency_tune_adj;
-
-// Defined by linux uclamp ABI of sched_setattr().
-constexpr uint32_t kSchedulerUclampMin = 0;
-constexpr uint32_t kSchedulerUclampMax = 1024;
-
-// sched_attr is used to set scheduler attributes for Linux. It is not a POSIX
-// struct and glibc does not expose it.
-struct sched_attr {
-  uint32_t size;
-
-  uint32_t sched_policy;
-  uint64_t sched_flags;
-
-  /* SCHED_NORMAL, SCHED_BATCH */
-  int32_t sched_nice;
-
-  /* SCHED_FIFO, SCHED_RR */
-  uint32_t sched_priority;
-
-  /* SCHED_DEADLINE */
-  uint64_t sched_runtime;
-  uint64_t sched_deadline;
-  uint64_t sched_period;
-
-  /* Utilization hints */
-  uint32_t sched_util_min;
-  uint32_t sched_util_max;
-};
-
-#if !defined(__NR_sched_setattr)
-#if defined(__x86_64__)
-#define __NR_sched_setattr 314
-#define __NR_sched_getattr 315
-#elif defined(__i386__)
-#define __NR_sched_setattr 351
-#define __NR_sched_getattr 352
-#elif defined(__arm__)
-#define __NR_sched_setattr 380
-#define __NR_sched_getattr 381
-#elif defined(__aarch64__)
-#define __NR_sched_setattr 274
-#define __NR_sched_getattr 275
-#else
-#error "We don't have an __NR_sched_setattr for this architecture."
-#endif
-#endif
-
-#if !defined(SCHED_FLAG_UTIL_CLAMP_MIN)
-#define SCHED_FLAG_UTIL_CLAMP_MIN 0x20
-#endif
-
-#if !defined(SCHED_FLAG_UTIL_CLAMP_MAX)
-#define SCHED_FLAG_UTIL_CLAMP_MAX 0x40
-#endif
-
-long sched_getattr(pid_t pid,
-                   const struct sched_attr* attr,
-                   unsigned int size,
-                   unsigned int flags) {
-  return syscall(__NR_sched_getattr, pid, attr, size, flags);
-}
-
-long sched_setattr(pid_t pid,
-                   const struct sched_attr* attr,
-                   unsigned int flags) {
-  return syscall(__NR_sched_setattr, pid, attr, flags);
-}
-
-// Setup whether a thread is latency sensitive. The thread_id should
-// always be the value in the root PID namespace (see FindThreadID).
-void SetThreadLatencySensitivity(ProcessId process_id,
-                                 PlatformThreadId thread_id,
-                                 ThreadType thread_type) {
-  struct sched_attr attr;
-  bool is_urgent = false;
-  int boost_percent, limit_percent;
-  int latency_sensitive_urgent;
-
-  // Scheduler boost defaults to true unless disabled.
-  if (!g_use_sched_util.load())
-    return;
-
-  // FieldTrial API can be called only once features were parsed.
-  if (g_scheduler_hints_adjusted.load()) {
-    boost_percent = g_scheduler_boost_adj;
-    limit_percent = g_scheduler_limit_adj;
-    latency_sensitive_urgent = g_scheduler_use_latency_tune_adj;
-  } else {
-    boost_percent = kSchedulerBoostDef;
-    limit_percent = kSchedulerLimitDef;
-    latency_sensitive_urgent = kSchedulerUseLatencyTuneDef;
-  }
-
-  // The thread_id passed in here is either 0 (in which case we ste for current
-  // thread), or is a tid that is not the NS tid but the global one. The
-  // conversion from NS tid to global tid is done by the callers using
-  // FindThreadID().
-  FilePath thread_dir;
-  if (thread_id && thread_id != PlatformThread::CurrentId())
-    thread_dir = FilePath(StringPrintf("/proc/%d/task/%d/", process_id, thread_id));
-  else
-    thread_dir = FilePath("/proc/thread-self/");
-
-  FilePath latency_sensitive_file = thread_dir.Append("latency_sensitive");
-
-  if (!PathExists(latency_sensitive_file))
-    return;
-
-  // Silently ignore if getattr fails due to sandboxing.
-  if (sched_getattr(thread_id, &attr, sizeof(attr), 0) == -1 ||
-      attr.size != sizeof(attr))
-    return;
-
-  switch (thread_type) {
-    case ThreadType::kBackground:
-    case ThreadType::kUtility:
-    case ThreadType::kResourceEfficient:
-    case ThreadType::kDefault:
-      break;
-    case ThreadType::kCompositing:
-    case ThreadType::kDisplayCritical:
-      // Compositing and display critical threads need a boost for consistent 60
-      // fps.
-      [[fallthrough]];
-    case ThreadType::kRealtimeAudio:
-      is_urgent = true;
-      break;
-  }
-
-  PLOG_IF(ERROR,
-          !WriteFile(latency_sensitive_file,
-                     (is_urgent && latency_sensitive_urgent) ? "1" : "0", 1))
-      << "Failed to write latency file.";
-
-  attr.sched_flags |= SCHED_FLAG_UTIL_CLAMP_MIN;
-  attr.sched_flags |= SCHED_FLAG_UTIL_CLAMP_MAX;
-
-  if (is_urgent) {
-    attr.sched_util_min =
-        (saturated_cast<uint32_t>(boost_percent) * kSchedulerUclampMax + 50) /
-        100;
-    attr.sched_util_max = kSchedulerUclampMax;
-  } else {
-    attr.sched_util_min = kSchedulerUclampMin;
-    attr.sched_util_max =
-        (saturated_cast<uint32_t>(limit_percent) * kSchedulerUclampMax + 50) /
-        100;
-  }
-
-  DCHECK_GE(attr.sched_util_min, kSchedulerUclampMin);
-  DCHECK_LE(attr.sched_util_max, kSchedulerUclampMax);
-
-  attr.size = sizeof(struct sched_attr);
-  if (sched_setattr(thread_id, &attr, 0) == -1) {
-    // We log it as an error because, if the PathExists above succeeded, we
-    // expect this syscall to also work since the kernel is new'ish.
-    PLOG_IF(ERROR, errno != E2BIG)
-        << "Failed to set sched_util_min, performance may be effected.";
-  }
-}
-
-} // namespace
-
-void PlatformThreadChromeOS::InitFeaturesPostFieldTrial() {
-  DCHECK(FeatureList::GetInstance());
-  if (!FeatureList::IsEnabled(kSchedUtilHints)) {
-    g_use_sched_util.store(false);
-    return;
-  }
-
-  int boost_def = kSchedulerBoostDef;
-
-  if (CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kSchedulerBoostUrgent)) {
-    std::string boost_switch_str =
-        CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
-            switches::kSchedulerBoostUrgent);
-
-    int boost_switch_val;
-    if (!StringToInt(boost_switch_str, &boost_switch_val) ||
-        boost_switch_val < 0 || boost_switch_val > 100) {
-      DVLOG(1) << "Invalid input for " << switches::kSchedulerBoostUrgent;
-    } else {
-      boost_def = boost_switch_val;
-    }
-  }
-
-  g_scheduler_boost_adj = GetFieldTrialParamByFeatureAsInt(
-      kSchedUtilHints, "BoostUrgent", boost_def);
-  g_scheduler_limit_adj = GetFieldTrialParamByFeatureAsInt(
-      kSchedUtilHints, "LimitNonUrgent", kSchedulerLimitDef);
-  g_scheduler_use_latency_tune_adj = GetFieldTrialParamByFeatureAsBool(
-      kSchedUtilHints, "LatencyTune", kSchedulerUseLatencyTuneDef);
-
-  g_scheduler_hints_adjusted.store(true);
-}
-
-// static
-void PlatformThreadChromeOS::SetThreadType(ProcessId process_id,
-                                           PlatformThreadId thread_id,
-                                           ThreadType thread_type) {
-  // TODO(b/262267726): Call PlatformThreadLinux::SetThreadType for common code.
-  PlatformThreadId syscall_tid = thread_id;
-  if (thread_id == PlatformThread::CurrentId()) {
-    syscall_tid = 0;
-  }
-
-  // For legacy schedtune interface
-  PlatformThreadLinux::SetThreadCgroupsForThreadType(thread_id, thread_type);
-
-  // For upstream uclamp interface. We try both legacy (schedtune, as done
-  // earlier) and upstream (uclamp) interfaces, and whichever succeeds wins.
-  SetThreadLatencySensitivity(process_id, thread_id, thread_type);
-
-  if (thread_type == ThreadType::kRealtimeAudio) {
-    if (sched_setscheduler(syscall_tid, SCHED_RR, &kRealTimePrio) == 0) {
-      return;
-    }
-    // If failed to set to RT, fallback to setting nice value.
-    DVPLOG(1) << "Failed to set realtime priority for thread (" << thread_id
-              << ")";
-  }
-
-  const int nice_setting = internal::ThreadTypeToNiceValue(thread_type);
-  if (setpriority(PRIO_PROCESS, static_cast<id_t>(syscall_tid), nice_setting)) {
-    DVPLOG(1) << "Failed to set nice value of thread (" << thread_id << ") to "
-              << nice_setting;
-  }
-}
-
-}  // namespace base
diff --git a/base/threading/platform_thread_linux.cc b/base/threading/platform_thread_linux.cc
index 0fbe17c465..b365237cac 100644
--- a/base/threading/platform_thread_linux.cc
+++ b/base/threading/platform_thread_linux.cc
@@ -1,8 +1,6 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-// Description: Linux specific functionality. Other Linux-derivatives layer on
-// top of this translation unit.
 
 #include "base/threading/platform_thread.h"
 
@@ -30,19 +28,118 @@
 #include "build/build_config.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 
+#if !BUILDFLAG(IS_NACL) && !BUILDFLAG(IS_AIX)
 #include <pthread.h>
 #include <sys/prctl.h>
 #include <sys/resource.h>
 #include <sys/time.h>
 #include <sys/types.h>
 #include <unistd.h>
+#endif
 
 namespace base {
 
+#if BUILDFLAG(IS_CHROMEOS)
+BASE_FEATURE(kSchedUtilHints,
+             "SchedUtilHints",
+             base::FEATURE_ENABLED_BY_DEFAULT);
+#endif
+
 namespace {
 
+#if !BUILDFLAG(IS_NACL)
 ThreadTypeDelegate* g_thread_type_delegate = nullptr;
+#endif
+
+#if BUILDFLAG(IS_CHROMEOS)
+std::atomic<bool> g_use_sched_util(true);
+std::atomic<bool> g_scheduler_hints_adjusted(false);
+
+// When a device doesn't specify uclamp values via chrome switches,
+// default boosting for urgent tasks is hardcoded here as 20%.
+// Higher values can lead to higher power consumption thus this value
+// is chosen conservatively where it does not show noticeable
+// power usage increased from several perf/power tests.
+const int kSchedulerBoostDef = 20;
+const int kSchedulerLimitDef = 100;
+const bool kSchedulerUseLatencyTuneDef = true;
+
+int g_scheduler_boost_adj;
+int g_scheduler_limit_adj;
+bool g_scheduler_use_latency_tune_adj;
+
+#if !BUILDFLAG(IS_NACL) && !BUILDFLAG(IS_AIX)
+
+// Defined by linux uclamp ABI of sched_setattr().
+const uint32_t kSchedulerUclampMin = 0;
+const uint32_t kSchedulerUclampMax = 1024;
+
+// sched_attr is used to set scheduler attributes for Linux. It is not a POSIX
+// struct and glibc does not expose it.
+struct sched_attr {
+  uint32_t size;
+
+  uint32_t sched_policy;
+  uint64_t sched_flags;
+
+  /* SCHED_NORMAL, SCHED_BATCH */
+  __s32 sched_nice;
+
+  /* SCHED_FIFO, SCHED_RR */
+  uint32_t sched_priority;
+
+  /* SCHED_DEADLINE */
+  uint64_t sched_runtime;
+  uint64_t sched_deadline;
+  uint64_t sched_period;
+
+  /* Utilization hints */
+  uint32_t sched_util_min;
+  uint32_t sched_util_max;
+};
+
+#if !defined(__NR_sched_setattr)
+#if defined(__x86_64__)
+#define __NR_sched_setattr 314
+#define __NR_sched_getattr 315
+#elif defined(__i386__)
+#define __NR_sched_setattr 351
+#define __NR_sched_getattr 352
+#elif defined(__arm__)
+#define __NR_sched_setattr 380
+#define __NR_sched_getattr 381
+#elif defined(__aarch64__)
+#define __NR_sched_setattr 274
+#define __NR_sched_getattr 275
+#else
+#error "We don't have an __NR_sched_setattr for this architecture."
+#endif
+#endif
+
+#if !defined(SCHED_FLAG_UTIL_CLAMP_MIN)
+#define SCHED_FLAG_UTIL_CLAMP_MIN 0x20
+#endif
 
+#if !defined(SCHED_FLAG_UTIL_CLAMP_MAX)
+#define SCHED_FLAG_UTIL_CLAMP_MAX 0x40
+#endif
+
+long sched_getattr(pid_t pid,
+                   const struct sched_attr* attr,
+                   unsigned int size,
+                   unsigned int flags) {
+  return syscall(__NR_sched_getattr, pid, attr, size, flags);
+}
+
+long sched_setattr(pid_t pid,
+                   const struct sched_attr* attr,
+                   unsigned int flags) {
+  return syscall(__NR_sched_setattr, pid, attr, flags);
+}
+#endif  // !BUILDFLAG(IS_NACL) && !BUILDFLAG(IS_AIX)
+#endif  // BUILDFLAG(IS_CHROMEOS)
+
+#if !BUILDFLAG(IS_NACL)
 const FilePath::CharType kCgroupDirectory[] =
     FILE_PATH_LITERAL("/sys/fs/cgroup");
 
@@ -98,10 +195,129 @@ void SetThreadCgroupForThreadType(PlatformThreadId thread_id,
   SetThreadCgroup(thread_id, cgroup_directory);
 }
 
+#if BUILDFLAG(IS_CHROMEOS)
+// thread_id should always be the value in the root PID namespace (see
+// FindThreadID).
+void SetThreadLatencySensitivity(ProcessId process_id,
+                                 PlatformThreadId thread_id,
+                                 ThreadType thread_type) {
+  struct sched_attr attr;
+  bool is_urgent = false;
+  int boost_percent, limit_percent;
+  int latency_sensitive_urgent;
+
+  // Scheduler boost defaults to true unless disabled.
+  if (!g_use_sched_util.load())
+    return;
+
+  // FieldTrial API can be called only once features were parsed.
+  if (g_scheduler_hints_adjusted.load()) {
+    boost_percent = g_scheduler_boost_adj;
+    limit_percent = g_scheduler_limit_adj;
+    latency_sensitive_urgent = g_scheduler_use_latency_tune_adj;
+  } else {
+    boost_percent = kSchedulerBoostDef;
+    limit_percent = kSchedulerLimitDef;
+    latency_sensitive_urgent = kSchedulerUseLatencyTuneDef;
+  }
+
+  // The thread_id passed in here is either 0 (in which case we ste for current
+  // thread), or is a tid that is not the NS tid but the global one. The
+  // conversion from NS tid to global tid is done by the callers using
+  // FindThreadID().
+  std::string thread_dir;
+  if (thread_id)
+    thread_dir = base::StringPrintf("/proc/%d/task/%d/", process_id, thread_id);
+  else
+    thread_dir = "/proc/thread-self/";
+
+  // Silently ignore request if thread directory doesn't exist.
+  if (!DirectoryExists(FilePath(thread_dir)))
+    return;
+
+  FilePath latency_sensitive_file = FilePath(thread_dir + "latency_sensitive");
+
+  if (!PathExists(latency_sensitive_file))
+    return;
+
+  // Silently ignore if getattr fails due to sandboxing.
+  if (sched_getattr(thread_id, &attr, sizeof(attr), 0) == -1 ||
+      attr.size != sizeof(attr))
+    return;
+
+  switch (thread_type) {
+    case ThreadType::kBackground:
+    case ThreadType::kUtility:
+    case ThreadType::kResourceEfficient:
+    case ThreadType::kDefault:
+      break;
+    case ThreadType::kCompositing:
+    case ThreadType::kDisplayCritical:
+      // Compositing and display critical threads need a boost for consistent 60
+      // fps.
+      [[fallthrough]];
+    case ThreadType::kRealtimeAudio:
+      is_urgent = true;
+      break;
+  }
+
+  if (is_urgent && latency_sensitive_urgent) {
+    PLOG_IF(ERROR, !WriteFile(latency_sensitive_file, "1", 1))
+        << "Failed to write latency file.\n";
+  } else {
+    PLOG_IF(ERROR, !WriteFile(latency_sensitive_file, "0", 1))
+        << "Failed to write latency file.\n";
+  }
+
+  attr.sched_flags |= SCHED_FLAG_UTIL_CLAMP_MIN;
+  attr.sched_flags |= SCHED_FLAG_UTIL_CLAMP_MAX;
+
+  if (is_urgent) {
+    attr.sched_util_min =
+        (saturated_cast<uint32_t>(boost_percent) * kSchedulerUclampMax + 50) /
+        100;
+    attr.sched_util_max = kSchedulerUclampMax;
+  } else {
+    attr.sched_util_min = kSchedulerUclampMin;
+    attr.sched_util_max =
+        (saturated_cast<uint32_t>(limit_percent) * kSchedulerUclampMax + 50) /
+        100;
+  }
+
+  DCHECK_GE(attr.sched_util_min, kSchedulerUclampMin);
+  DCHECK_LE(attr.sched_util_max, kSchedulerUclampMax);
+
+  attr.size = sizeof(struct sched_attr);
+  if (sched_setattr(thread_id, &attr, 0) == -1) {
+    // We log it as an error because, if the PathExists above succeeded, we
+    // expect this syscall to also work since the kernel is new'ish.
+    PLOG_IF(ERROR, errno != E2BIG)
+        << "Failed to set sched_util_min, performance may be effected.\n";
+  }
+}
+#endif
+
+void SetThreadCgroupsForThreadType(PlatformThreadId thread_id,
+                                   ThreadType thread_type) {
+  FilePath cgroup_filepath(kCgroupDirectory);
+  SetThreadCgroupForThreadType(
+      thread_id, cgroup_filepath.Append(FILE_PATH_LITERAL("cpuset")),
+      thread_type);
+  SetThreadCgroupForThreadType(
+      thread_id, cgroup_filepath.Append(FILE_PATH_LITERAL("schedtune")),
+      thread_type);
+}
+#endif
 }  // namespace
 
 namespace internal {
 
+namespace {
+#if !BUILDFLAG(IS_NACL)
+const struct sched_param kRealTimePrio = {8};
+#endif
+}  // namespace
+
 const ThreadPriorityToNiceValuePairForTest
     kThreadPriorityToNiceValueMapForTest[5] = {
         {ThreadPriorityForTest::kRealtimeAudio, -10},
@@ -124,14 +340,19 @@ const ThreadTypeToNiceValuePair kThreadTypeToNiceValueMap[7] = {
 };
 
 bool CanSetThreadTypeToRealtimeAudio() {
+#if !BUILDFLAG(IS_NACL)
   // A non-zero soft-limit on RLIMIT_RTPRIO is required to be allowed to invoke
   // pthread_setschedparam in SetCurrentThreadTypeForPlatform().
   struct rlimit rlim;
   return getrlimit(RLIMIT_RTPRIO, &rlim) != 0 && rlim.rlim_cur != 0;
+#else
+  return false;
+#endif
 }
 
 bool SetCurrentThreadTypeForPlatform(ThreadType thread_type,
                                      MessagePumpType pump_type_hint) {
+#if !BUILDFLAG(IS_NACL)
   const PlatformThreadId tid = PlatformThread::CurrentId();
 
   if (g_thread_type_delegate &&
@@ -139,29 +360,44 @@ bool SetCurrentThreadTypeForPlatform(ThreadType thread_type,
     return true;
   }
 
-  PlatformThread::SetThreadType(getpid(), tid, thread_type);
-  return true;
+  // For legacy schedtune interface
+  SetThreadCgroupsForThreadType(tid, thread_type);
+
+#if BUILDFLAG(IS_CHROMEOS)
+  // For upstream uclamp interface. We try both legacy (schedtune, as done
+  // earlier) and upstream (uclamp) interfaces, and whichever succeeds wins.
+  SetThreadLatencySensitivity(0 /* ignore */, 0 /* thread-self */, thread_type);
+#endif
+
+  return thread_type == ThreadType::kRealtimeAudio &&
+         pthread_setschedparam(pthread_self(), SCHED_RR, &kRealTimePrio) == 0;
+#else
+  return false;
+#endif
 }
 
 absl::optional<ThreadPriorityForTest>
 GetCurrentThreadPriorityForPlatformForTest() {
+#if !BUILDFLAG(IS_NACL)
   int maybe_sched_rr = 0;
   struct sched_param maybe_realtime_prio = {0};
   if (pthread_getschedparam(pthread_self(), &maybe_sched_rr,
                             &maybe_realtime_prio) == 0 &&
       maybe_sched_rr == SCHED_RR &&
-      maybe_realtime_prio.sched_priority ==
-          PlatformThreadLinux::kRealTimePrio.sched_priority) {
+      maybe_realtime_prio.sched_priority == kRealTimePrio.sched_priority) {
     return absl::make_optional(ThreadPriorityForTest::kRealtimeAudio);
   }
+#endif
   return absl::nullopt;
 }
 
 }  // namespace internal
 
-void PlatformThreadBase::SetName(const std::string& name) {
-  SetNameCommon(name);
+// static
+void PlatformThread::SetName(const std::string& name) {
+  ThreadIdNameManager::GetInstance()->SetName(name);
 
+#if !BUILDFLAG(IS_NACL) && !BUILDFLAG(IS_AIX)
   // On linux we can get the thread names to show up in the debugger by setting
   // the process name for the LWP.  We don't want to do this for the main
   // thread because that would rename the process, causing tools like killall
@@ -178,58 +414,96 @@ void PlatformThreadBase::SetName(const std::string& name) {
   // We expect EPERM failures in sandboxed processes, just ignore those.
   if (err < 0 && errno != EPERM)
     DPLOG(ERROR) << "prctl(PR_SET_NAME)";
+#endif  //  !BUILDFLAG(IS_NACL) && !BUILDFLAG(IS_AIX)
 }
 
+#if !BUILDFLAG(IS_NACL)
 // static
-void PlatformThreadLinux::SetThreadTypeDelegate(ThreadTypeDelegate* delegate) {
+void PlatformThread::SetThreadTypeDelegate(ThreadTypeDelegate* delegate) {
   // A component cannot override a delegate set by another component, thus
   // disallow setting a delegate when one already exists.
   DCHECK(!g_thread_type_delegate || !delegate);
 
   g_thread_type_delegate = delegate;
 }
+#endif
 
+#if !BUILDFLAG(IS_NACL) && !BUILDFLAG(IS_AIX)
 // static
-void PlatformThreadLinux::SetThreadCgroupsForThreadType(
-    PlatformThreadId thread_id,
-    ThreadType thread_type) {
-  FilePath cgroup_filepath(kCgroupDirectory);
-  SetThreadCgroupForThreadType(
-      thread_id, cgroup_filepath.Append(FILE_PATH_LITERAL("cpuset")),
-      thread_type);
-  SetThreadCgroupForThreadType(
-      thread_id, cgroup_filepath.Append(FILE_PATH_LITERAL("schedtune")),
-      thread_type);
-}
-
-// static
-void PlatformThreadLinux::SetThreadType(ProcessId process_id,
-                                        PlatformThreadId thread_id,
-                                        ThreadType thread_type) {
+void PlatformThread::SetThreadType(ProcessId process_id,
+                                   PlatformThreadId thread_id,
+                                   ThreadType thread_type) {
+  // For legacy schedtune interface
   SetThreadCgroupsForThreadType(thread_id, thread_type);
 
-  // Some scheduler syscalls require thread ID of 0 for current thread.
-  // This prevents us from requiring to translate the NS TID to
-  // global TID.
-  PlatformThreadId syscall_tid = thread_id;
-  if (thread_id == PlatformThread::CurrentId()) {
-    syscall_tid = 0;
-  }
-
-  if (thread_type == ThreadType::kRealtimeAudio) {
-    if (sched_setscheduler(syscall_tid, SCHED_RR,
-                           &PlatformThreadLinux::kRealTimePrio) == 0) {
-      return;
-    }
-    // If failed to set to RT, fallback to setpriority to set nice value.
-    DPLOG(ERROR) << "Failed to set realtime priority for thread " << thread_id;
-  }
+#if BUILDFLAG(IS_CHROMEOS)
+  // For upstream uclamp interface. We try both legacy (schedtune, as done
+  // earlier) and upstream (uclamp) interfaces, and whichever succeeds wins.
+  SetThreadLatencySensitivity(process_id, thread_id, thread_type);
+#endif
 
   const int nice_setting = internal::ThreadTypeToNiceValue(thread_type);
-  if (setpriority(PRIO_PROCESS, static_cast<id_t>(syscall_tid), nice_setting)) {
+  if (setpriority(PRIO_PROCESS, static_cast<id_t>(thread_id), nice_setting)) {
     DVPLOG(1) << "Failed to set nice value of thread (" << thread_id << ") to "
               << nice_setting;
   }
 }
+#endif  //  !BUILDFLAG(IS_NACL) && !BUILDFLAG(IS_AIX)
+
+#if BUILDFLAG(IS_CHROMEOS)
+void PlatformThread::InitFeaturesPostFieldTrial() {
+  DCHECK(FeatureList::GetInstance());
+  if (!FeatureList::IsEnabled(kSchedUtilHints)) {
+    g_use_sched_util.store(false);
+    return;
+  }
+
+  int boost_def = kSchedulerBoostDef;
+
+  if (CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kSchedulerBoostUrgent)) {
+    std::string boost_switch_str =
+        CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
+            switches::kSchedulerBoostUrgent);
+
+    int boost_switch_val;
+    if (!StringToInt(boost_switch_str, &boost_switch_val) ||
+        boost_switch_val < 0 || boost_switch_val > 100) {
+      DVPLOG(1) << "Invalid input for " << switches::kSchedulerBoostUrgent;
+    } else {
+      boost_def = boost_switch_val;
+    }
+  }
+
+  g_scheduler_boost_adj = GetFieldTrialParamByFeatureAsInt(
+      kSchedUtilHints, "BoostUrgent", boost_def);
+  g_scheduler_limit_adj = GetFieldTrialParamByFeatureAsInt(
+      kSchedUtilHints, "LimitNonUrgent", kSchedulerLimitDef);
+  g_scheduler_use_latency_tune_adj = GetFieldTrialParamByFeatureAsBool(
+      kSchedUtilHints, "LatencyTune", kSchedulerUseLatencyTuneDef);
+
+  g_scheduler_hints_adjusted.store(true);
+}
+#endif
+
+void InitThreading() {}
+
+void TerminateOnThread() {}
+
+size_t GetDefaultThreadStackSize(const pthread_attr_t& attributes) {
+#if !defined(THREAD_SANITIZER) && defined(__GLIBC__)
+  // Generally glibc sets ample default stack sizes, so use the default there.
+  return 0;
+#elif !defined(THREAD_SANITIZER)
+  // Other libcs (uclibc, musl, etc) tend to use smaller stacks, often too small
+  // for chromium. Make sure we have enough space to work with here. Note that
+  // for comparison glibc stacks are generally around 8MB.
+  return 2 * (1 << 20);
+#else
+  // ThreadSanitizer bloats the stack heavily. Evidence has been that the
+  // default stack size isn't enough for some browser tests.
+  return 2 * (1 << 23);  // 2 times 8192K (the default stack size on Linux).
+#endif
+}
 
 }  // namespace base
diff --git a/base/threading/platform_thread_linux_base.cc b/base/threading/platform_thread_linux_base.cc
deleted file mode 100644
index ea94e6237c..0000000000
--- a/base/threading/platform_thread_linux_base.cc
+++ /dev/null
@@ -1,31 +0,0 @@
-// Copyright 2023 The Chromium Authors
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-// Description: Common functions for NACL and all Linux and
-// Linux-derivatives.
-
-#include "base/threading/platform_thread.h"
-
-namespace base {
-
-size_t GetDefaultThreadStackSize(const pthread_attr_t& attributes) {
-#if !defined(THREAD_SANITIZER) && defined(__GLIBC__)
-  // Generally glibc sets ample default stack sizes, so use the default there.
-  return 0;
-#elif !defined(THREAD_SANITIZER)
-  // Other libcs (uclibc, musl, etc) tend to use smaller stacks, often too small
-  // for chromium. Make sure we have enough space to work with here. Note that
-  // for comparison glibc stacks are generally around 8MB.
-  return 2 * (1 << 20);
-#else
-  // ThreadSanitizer bloats the stack heavily. Evidence has been that the
-  // default stack size isn't enough for some browser tests.
-  return 2 * (1 << 23);  // 2 times 8192K (the default stack size on Linux).
-#endif
-}
-
-void InitThreading() {}
-
-void TerminateOnThread() {}
-
-}  // namespace base
\ No newline at end of file
diff --git a/base/threading/platform_thread_posix.cc b/base/threading/platform_thread_posix.cc
index cb3794036f..6743b44020 100644
--- a/base/threading/platform_thread_posix.cc
+++ b/base/threading/platform_thread_posix.cc
@@ -209,7 +209,7 @@ void InvalidateTidCache() {
 #endif  // BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
 
 // static
-PlatformThreadId PlatformThreadBase::CurrentId() {
+PlatformThreadId PlatformThread::CurrentId() {
   // Pthreads doesn't have the concept of a thread ID, so we have to reach down
   // into the kernel.
 #if BUILDFLAG(IS_APPLE)
@@ -269,24 +269,24 @@ PlatformThreadId PlatformThreadBase::CurrentId() {
 }
 
 // static
-PlatformThreadRef PlatformThreadBase::CurrentRef() {
+PlatformThreadRef PlatformThread::CurrentRef() {
   return PlatformThreadRef(pthread_self());
 }
 
 // static
-PlatformThreadHandle PlatformThreadBase::CurrentHandle() {
+PlatformThreadHandle PlatformThread::CurrentHandle() {
   return PlatformThreadHandle(pthread_self());
 }
 
 #if !BUILDFLAG(IS_APPLE)
 // static
-void PlatformThreadBase::YieldCurrentThread() {
+void PlatformThread::YieldCurrentThread() {
   sched_yield();
 }
 #endif  // !BUILDFLAG(IS_APPLE)
 
 // static
-void PlatformThreadBase::Sleep(TimeDelta duration) {
+void PlatformThread::Sleep(TimeDelta duration) {
   struct timespec sleep_time, remaining;
 
   // Break the duration into seconds and nanoseconds.
@@ -301,12 +301,12 @@ void PlatformThreadBase::Sleep(TimeDelta duration) {
 }
 
 // static
-const char* PlatformThreadBase::GetName() {
+const char* PlatformThread::GetName() {
   return ThreadIdNameManager::GetInstance()->GetName(CurrentId());
 }
 
 // static
-bool PlatformThreadBase::CreateWithType(size_t stack_size,
+bool PlatformThread::CreateWithType(size_t stack_size,
                                     Delegate* delegate,
                                     PlatformThreadHandle* thread_handle,
                                     ThreadType thread_type,
@@ -316,12 +316,12 @@ bool PlatformThreadBase::CreateWithType(size_t stack_size,
 }
 
 // static
-bool PlatformThreadBase::CreateNonJoinable(size_t stack_size, Delegate* delegate) {
+bool PlatformThread::CreateNonJoinable(size_t stack_size, Delegate* delegate) {
   return CreateNonJoinableWithType(stack_size, delegate, ThreadType::kDefault);
 }
 
 // static
-bool PlatformThreadBase::CreateNonJoinableWithType(size_t stack_size,
+bool PlatformThread::CreateNonJoinableWithType(size_t stack_size,
                                                Delegate* delegate,
                                                ThreadType thread_type,
                                                MessagePumpType pump_type_hint) {
@@ -333,7 +333,7 @@ bool PlatformThreadBase::CreateNonJoinableWithType(size_t stack_size,
 }
 
 // static
-void PlatformThreadBase::Join(PlatformThreadHandle thread_handle) {
+void PlatformThread::Join(PlatformThreadHandle thread_handle) {
   // Joining another thread may block the current thread for a long time, since
   // the thread referred to by |thread_handle| may still be running long-lived /
   // blocking tasks.
@@ -343,7 +343,7 @@ void PlatformThreadBase::Join(PlatformThreadHandle thread_handle) {
 }
 
 // static
-void PlatformThreadBase::Detach(PlatformThreadHandle thread_handle) {
+void PlatformThread::Detach(PlatformThreadHandle thread_handle) {
   CHECK_EQ(0, pthread_detach(thread_handle.platform_handle()));
 }
 
@@ -352,7 +352,7 @@ void PlatformThreadBase::Detach(PlatformThreadHandle thread_handle) {
 #if !BUILDFLAG(IS_APPLE) && !BUILDFLAG(IS_FUCHSIA)
 
 // static
-bool PlatformThreadBase::CanChangeThreadType(ThreadType from, ThreadType to) {
+bool PlatformThread::CanChangeThreadType(ThreadType from, ThreadType to) {
 #if BUILDFLAG(IS_NACL)
   return false;
 #else
@@ -395,7 +395,7 @@ void SetCurrentThreadTypeImpl(ThreadType thread_type,
 }  // namespace internal
 
 // static
-ThreadPriorityForTest PlatformThreadBase::GetCurrentThreadPriorityForTest() {
+ThreadPriorityForTest PlatformThread::GetCurrentThreadPriorityForTest() {
 #if BUILDFLAG(IS_NACL)
   NOTIMPLEMENTED();
   return ThreadPriorityForTest::kNormal;
@@ -415,7 +415,7 @@ ThreadPriorityForTest PlatformThreadBase::GetCurrentThreadPriorityForTest() {
 #endif  // !BUILDFLAG(IS_APPLE) && !BUILDFLAG(IS_FUCHSIA)
 
 // static
-size_t PlatformThreadBase::GetDefaultThreadStackSize() {
+size_t PlatformThread::GetDefaultThreadStackSize() {
   pthread_attr_t attributes;
   pthread_attr_init(&attributes);
   return base::GetDefaultThreadStackSize(attributes);
-- 
2.41.0.487.g6d72f3e995-goog

