From 62bba06a487ff8ec300847d916705cddfdbc2719 Mon Sep 17 00:00:00 2001
From: Nathan Muggli <nmuggli@google.com>
Date: Wed, 2 Aug 2023 10:26:12 -0600
Subject: [PATCH] Revert "Land intentional C++20 use in base/."

This reverts commit c5acc58e7bebe5de213668909a9414b97c58c9c7.

patch-name: backward-compatibility-1400-Revert-Land-intentional-C-20-use-in-base.patch
Change-Id: Iab4e3adeb005025fdecdfeef6786662692aa11c0
---
 base/check_op.h                               |  70 +++++------
 base/containers/contiguous_iterator.h         | 113 ++++++++++++++++++
 base/containers/span.h                        |   8 +-
 base/strings/to_string.h                      |  34 ++++--
 base/strings/to_string_unittest.cc            |  16 +--
 base/types/strong_alias.h                     |   2 +-
 base/types/strong_alias_unittest.cc           |   4 +-
 base/types/supports_ostream_operator.h        |  10 +-
 .../supports_ostream_operator_unittest.cc     |  39 +++---
 9 files changed, 209 insertions(+), 87 deletions(-)
 create mode 100644 base/containers/contiguous_iterator.h

diff --git a/base/check_op.h b/base/check_op.h
index 0c3aea6316..f1c7735ad3 100644
--- a/base/check_op.h
+++ b/base/check_op.h
@@ -69,10 +69,10 @@ BASE_EXPORT char* StreamValToStr(const void* v,
 #endif
 
 template <typename T>
-inline std::enable_if_t<
-    base::internal::SupportsOstreamOperator<const T&> &&
-        !std::is_function_v<typename std::remove_pointer<T>::type>,
-    char*>
+inline typename std::enable_if<
+    base::internal::SupportsOstreamOperator<const T&>::value &&
+        !std::is_function<typename std::remove_pointer<T>::type>::value,
+    char*>::type
 CheckOpValueStr(const T& v) {
   auto f = [](std::ostream& s, const void* p) {
     s << *reinterpret_cast<const T*>(p);
@@ -95,9 +95,10 @@ CheckOpValueStr(const T& v) {
 
 // Overload for types that have no operator<< but do have .ToString() defined.
 template <typename T>
-inline std::enable_if_t<!base::internal::SupportsOstreamOperator<const T&> &&
-                            base::internal::SupportsToString<const T&>,
-                        char*>
+inline typename std::enable_if<
+    !base::internal::SupportsOstreamOperator<const T&>::value &&
+        base::internal::SupportsToString<const T&>::value,
+    char*>::type
 CheckOpValueStr(const T& v) {
   // .ToString() may not return a std::string, e.g. blink::WTF::String.
   return CheckOpValueStr(v.ToString());
@@ -109,9 +110,9 @@ CheckOpValueStr(const T& v) {
 // standards-conforming here and converts function pointers to regular
 // pointers, so this is a no-op for MSVC.)
 template <typename T>
-inline std::enable_if_t<
-    std::is_function_v<typename std::remove_pointer<T>::type>,
-    char*>
+inline typename std::enable_if<
+    std::is_function<typename std::remove_pointer<T>::type>::value,
+    char*>::type
 CheckOpValueStr(const T& v) {
   return CheckOpValueStr(reinterpret_cast<const void*>(v));
 }
@@ -119,9 +120,10 @@ CheckOpValueStr(const T& v) {
 // We need overloads for enums that don't support operator<<.
 // (i.e. scoped enums where no operator<< overload was declared).
 template <typename T>
-inline std::enable_if_t<!base::internal::SupportsOstreamOperator<const T&> &&
-                            std::is_enum_v<T>,
-                        char*>
+inline typename std::enable_if<
+    !base::internal::SupportsOstreamOperator<const T&>::value &&
+        std::is_enum<T>::value,
+    char*>::type
 CheckOpValueStr(const T& v) {
   return CheckOpValueStr(
       static_cast<typename std::underlying_type<T>::type>(v));
@@ -167,27 +169,27 @@ BASE_EXPORT char* CreateCheckOpLogMessageString(const char* expr_str,
 
 // The second overload avoids address-taking of static members for
 // fundamental types.
-#define DEFINE_CHECK_OP_IMPL(name, op)                                         \
-  template <                                                                   \
-      typename T, typename U,                                                  \
-      std::enable_if_t<!std::is_fundamental_v<T> || !std::is_fundamental_v<U>, \
-                       int> = 0>                                               \
-  constexpr char* Check##name##Impl(const T& v1, const U& v2,                  \
-                                    const char* expr_str) {                    \
-    if (LIKELY(ANALYZER_ASSUME_TRUE(v1 op v2)))                                \
-      return nullptr;                                                          \
-    return CreateCheckOpLogMessageString(expr_str, CheckOpValueStr(v1),        \
-                                         CheckOpValueStr(v2));                 \
-  }                                                                            \
-  template <                                                                   \
-      typename T, typename U,                                                  \
-      std::enable_if_t<std::is_fundamental_v<T> && std::is_fundamental_v<U>,   \
-                       int> = 0>                                               \
-  constexpr char* Check##name##Impl(T v1, U v2, const char* expr_str) {        \
-    if (LIKELY(ANALYZER_ASSUME_TRUE(v1 op v2)))                                \
-      return nullptr;                                                          \
-    return CreateCheckOpLogMessageString(expr_str, CheckOpValueStr(v1),        \
-                                         CheckOpValueStr(v2));                 \
+#define DEFINE_CHECK_OP_IMPL(name, op)                                  \
+  template <typename T, typename U,                                     \
+            std::enable_if_t<!std::is_fundamental<T>::value ||          \
+                                 !std::is_fundamental<U>::value,        \
+                             int> = 0>                                  \
+  constexpr char* Check##name##Impl(const T& v1, const U& v2,           \
+                                    const char* expr_str) {             \
+    if (LIKELY(ANALYZER_ASSUME_TRUE(v1 op v2)))                         \
+      return nullptr;                                                   \
+    return CreateCheckOpLogMessageString(expr_str, CheckOpValueStr(v1), \
+                                         CheckOpValueStr(v2));          \
+  }                                                                     \
+  template <typename T, typename U,                                     \
+            std::enable_if_t<std::is_fundamental<T>::value &&           \
+                                 std::is_fundamental<U>::value,         \
+                             int> = 0>                                  \
+  constexpr char* Check##name##Impl(T v1, U v2, const char* expr_str) { \
+    if (LIKELY(ANALYZER_ASSUME_TRUE(v1 op v2)))                         \
+      return nullptr;                                                   \
+    return CreateCheckOpLogMessageString(expr_str, CheckOpValueStr(v1), \
+                                         CheckOpValueStr(v2));          \
   }
 
 // clang-format off
diff --git a/base/containers/contiguous_iterator.h b/base/containers/contiguous_iterator.h
new file mode 100644
index 0000000000..7886fbb415
--- /dev/null
+++ b/base/containers/contiguous_iterator.h
@@ -0,0 +1,113 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_CONTAINERS_CONTIGUOUS_ITERATOR_H_
+#define BASE_CONTAINERS_CONTIGUOUS_ITERATOR_H_
+
+#include <array>
+#include <iterator>
+#include <string>
+#include <type_traits>
+#include <vector>
+
+#include "base/containers/checked_iterators.h"
+
+namespace base {
+
+namespace internal {
+
+template <typename T>
+struct PointsToObject : std::true_type {};
+// std::iter_value_t is not defined for `T*` where T is not an object type.
+template <typename T>
+struct PointsToObject<T*> : std::is_object<T> {};
+
+// A pointer is a contiguous iterator.
+// Reference: https://wg21.link/iterator.traits#5
+template <typename T>
+struct IsPointer : std::is_pointer<T> {};
+
+template <typename T, typename StringT = std::basic_string<iter_value_t<T>>>
+struct IsStringIterImpl
+    : std::disjunction<std::is_same<T, typename StringT::const_iterator>,
+                       std::is_same<T, typename StringT::iterator>> {};
+
+// An iterator to std::basic_string is contiguous.
+// Reference: https://wg21.link/basic.string.general#2
+//
+// Note: Requires indirection via `IsStringIterImpl` to avoid triggering a
+// `static_assert(is_trivial_v<value_type>)` inside libc++'s std::basic_string.
+template <typename T>
+struct IsStringIter
+    : std::conjunction<
+          std::disjunction<std::is_same<iter_value_t<T>, char>,
+                           std::is_same<iter_value_t<T>, wchar_t>,
+                           std::is_same<iter_value_t<T>, char8_t>,
+                           std::is_same<iter_value_t<T>, char16_t>,
+                           std::is_same<iter_value_t<T>, char32_t>>,
+          IsStringIterImpl<T>> {};
+
+// An iterator to std::array is contiguous.
+// Reference: https://wg21.link/array.overview#1
+template <typename T, typename ArrayT = std::array<iter_value_t<T>, 1>>
+struct IsArrayIter
+    : std::disjunction<std::is_same<T, typename ArrayT::const_iterator>,
+                       std::is_same<T, typename ArrayT::iterator>> {};
+
+// An iterator to a non-bool std::vector is contiguous.
+// Reference: https://wg21.link/vector.overview#2
+template <typename T, typename VectorT = std::vector<iter_value_t<T>>>
+struct IsVectorIter
+    : std::conjunction<
+          std::negation<std::is_same<iter_value_t<T>, bool>>,
+          std::disjunction<std::is_same<T, typename VectorT::const_iterator>,
+                           std::is_same<T, typename VectorT::iterator>>> {};
+
+// The result of passing a std::valarray to std::begin is a contiguous iterator.
+// Note: Since all common standard library implementations (i.e. libc++,
+// stdlibc++ and MSVC's STL) just use a pointer here, we perform a similar
+// optimization. The corresponding unittest still ensures that this is working
+// as intended.
+// Reference: https://wg21.link/valarray.range#1
+template <typename T>
+struct IsValueArrayIter : std::is_pointer<T> {};
+
+// base's CheckedContiguousIterator is a contiguous iterator.
+template <typename T, typename ValueT = iter_value_t<T>>
+struct IsCheckedContiguousIter
+    : std::disjunction<
+          std::is_same<T, base::CheckedContiguousConstIterator<ValueT>>,
+          std::is_same<T, base::CheckedContiguousIterator<ValueT>>> {};
+
+// Check that the iterator points to an actual object, and is one of the
+// iterator types mentioned above.
+template <typename T, bool B = PointsToObject<T>::value>
+struct IsContiguousIteratorImpl : std::false_type {};
+template <typename T>
+struct IsContiguousIteratorImpl<T, true>
+    : std::disjunction<IsPointer<T>,
+                       IsStringIter<T>,
+                       IsArrayIter<T>,
+                       IsVectorIter<T>,
+                       IsValueArrayIter<T>,
+                       IsCheckedContiguousIter<T>> {};
+
+}  // namespace internal
+
+// IsContiguousIterator is a type trait that determines whether a given type is
+// a contiguous iterator. It is similar to C++20's contiguous_iterator concept,
+// but due to a lack of the corresponding contiguous_iterator_tag relies on
+// explicitly instantiating the type with iterators that are supposed to be
+// contiguous iterators.
+// References:
+// - https://wg21.link/iterator.concept.contiguous
+// - https://wg21.link/std.iterator.tags#lib:contiguous_iterator_tag
+// - https://wg21.link/n4284
+template <typename T>
+struct IsContiguousIterator
+    : internal::IsContiguousIteratorImpl<remove_cvref_t<T>> {};
+
+}  // namespace base
+
+#endif  // BASE_CONTAINERS_CONTIGUOUS_ITERATOR_H_
diff --git a/base/containers/span.h b/base/containers/span.h
index 0904fd2372..30c07190ba 100644
--- a/base/containers/span.h
+++ b/base/containers/span.h
@@ -9,7 +9,6 @@
 #include <stdint.h>
 
 #include <array>
-#include <concepts>
 #include <iterator>
 #include <limits>
 #include <memory>
@@ -19,6 +18,7 @@
 #include "base/check.h"
 #include "base/compiler_specific.h"
 #include "base/containers/checked_iterators.h"
+#include "base/containers/contiguous_iterator.h"
 #include "base/numerics/safe_conversions.h"
 #include "base/template_util.h"
 
@@ -81,9 +81,9 @@ using IteratorHasConvertibleReferenceType =
     IsLegalDataConversion<std::remove_reference_t<iter_reference_t<Iter>>, T>;
 
 template <typename Iter, typename T>
-using EnableIfCompatibleContiguousIterator =
-    std::enable_if_t<std::contiguous_iterator<Iter> &&
-                     IteratorHasConvertibleReferenceType<Iter, T>::value>;
+using EnableIfCompatibleContiguousIterator = std::enable_if_t<
+    std::conjunction_v<IsContiguousIterator<Iter>,
+                       IteratorHasConvertibleReferenceType<Iter, T>>>;
 
 template <typename Container, typename T>
 using ContainerHasConvertibleData = IsLegalDataConversion<
diff --git a/base/strings/to_string.h b/base/strings/to_string.h
index bfbc5ae578..eb402662b9 100644
--- a/base/strings/to_string.h
+++ b/base/strings/to_string.h
@@ -23,8 +23,11 @@ std::string ToString(const Ts&... values);
 
 namespace internal {
 
+template <typename T, typename = void>
+struct SupportsToString : std::false_type {};
 template <typename T>
-concept SupportsToString = requires(const T& t) { t.ToString(); };
+struct SupportsToString<T, decltype(void(std::declval<T>().ToString()))>
+    : std::true_type {};
 
 // I/O manipulators are function pointers, but should be sent directly to the
 // `ostream` instead of being cast to `const void*` like other function
@@ -56,17 +59,19 @@ struct ToStringHelper {
 
 // Most streamables.
 template <typename T>
-struct ToStringHelper<T,
-                      std::enable_if_t<SupportsOstreamOperator<const T&> &&
-                                       !WillBeIncorrectlyStreamedAsBool<T>>> {
+struct ToStringHelper<
+    T,
+    std::enable_if_t<SupportsOstreamOperator<const T&>::value &&
+                     !WillBeIncorrectlyStreamedAsBool<T>>> {
   static void Stringify(const T& v, std::ostringstream& ss) { ss << v; }
 };
 
 // Functions and function pointers.
 template <typename T>
-struct ToStringHelper<T,
-                      std::enable_if_t<SupportsOstreamOperator<const T&> &&
-                                       WillBeIncorrectlyStreamedAsBool<T>>> {
+struct ToStringHelper<
+    T,
+    std::enable_if_t<SupportsOstreamOperator<const T&>::value &&
+                     WillBeIncorrectlyStreamedAsBool<T>>> {
   static void Stringify(const T& v, std::ostringstream& ss) {
     ToStringHelper<const void*>::Stringify(reinterpret_cast<const void*>(v),
                                            ss);
@@ -75,9 +80,10 @@ struct ToStringHelper<T,
 
 // Non-streamables that have a `ToString` member.
 template <typename T>
-struct ToStringHelper<T,
-                      std::enable_if_t<!SupportsOstreamOperator<const T&> &&
-                                       SupportsToString<const T&>>> {
+struct ToStringHelper<
+    T,
+    std::enable_if_t<!SupportsOstreamOperator<const T&>::value &&
+                     SupportsToString<const T&>::value>> {
   static void Stringify(const T& v, std::ostringstream& ss) {
     // .ToString() may not return a std::string, e.g. blink::WTF::String.
     ToStringHelper<decltype(v.ToString())>::Stringify(v.ToString(), ss);
@@ -89,7 +95,8 @@ struct ToStringHelper<T,
 template <typename T>
 struct ToStringHelper<
     T,
-    std::enable_if_t<!SupportsOstreamOperator<const T&> && std::is_enum_v<T>>> {
+    std::enable_if_t<!SupportsOstreamOperator<const T&>::value &&
+                     std::is_enum_v<T>>> {
   static void Stringify(const T& v, std::ostringstream& ss) {
     using UT = typename std::underlying_type_t<T>;
     ToStringHelper<UT>::Stringify(static_cast<UT>(v), ss);
@@ -120,8 +127,9 @@ struct ToStringHelper<std::tuple<T...>> {
 template <typename... Ts>
 std::string ToString(const Ts&... values) {
   std::ostringstream ss;
-  (..., internal::ToStringHelper<remove_cvref_t<decltype(values)>>::Stringify(
-            values, ss));
+  (internal::ToStringHelper<remove_cvref_t<decltype(values)>>::Stringify(values,
+                                                                         ss),
+   ...);
   return ss.str();
 }
 
diff --git a/base/strings/to_string_unittest.cc b/base/strings/to_string_unittest.cc
index dca285ff52..3cb3c22356 100644
--- a/base/strings/to_string_unittest.cc
+++ b/base/strings/to_string_unittest.cc
@@ -20,22 +20,14 @@ class HasToString {
 };
 
 // .ToString() support on structs.
-static_assert(!internal::SupportsToString<NotStringifiable>,
+static_assert(!internal::SupportsToString<NotStringifiable>::value,
               "value without ToString() shouldn't be marked SupportsToString");
-static_assert(!internal::SupportsToString<NotStringifiable&>,
-              "& without ToString() shouldn't be marked SupportsToString");
-static_assert(!internal::SupportsToString<const NotStringifiable&>,
+static_assert(!internal::SupportsToString<const NotStringifiable&>::value,
               "const& without ToString() shouldn't be marked SupportsToString");
-static_assert(!internal::SupportsToString<NotStringifiable&&>,
-              "&& without ToString() shouldn't be marked SupportsToString");
-static_assert(internal::SupportsToString<HasToString>,
+static_assert(internal::SupportsToString<HasToString>::value,
               "value with ToString() should be marked SupportsToString");
-static_assert(internal::SupportsToString<HasToString&>,
-              "& with ToString() should be marked SupportsToString");
-static_assert(internal::SupportsToString<const HasToString&>,
+static_assert(internal::SupportsToString<const HasToString&>::value,
               "const& with ToString() should be marked SupportsToString");
-static_assert(internal::SupportsToString<HasToString&&>,
-              "&& with ToString() should be marked SupportsToString");
 
 TEST(ToStringTest, Streamable) {
   // Types with built-in <<.
diff --git a/base/types/strong_alias.h b/base/types/strong_alias.h
index 79d39808b0..7a4872a4a0 100644
--- a/base/types/strong_alias.h
+++ b/base/types/strong_alias.h
@@ -154,7 +154,7 @@ class StrongAlias {
 template <typename TagType,
           typename UnderlyingType,
           typename = std::enable_if_t<
-              internal::SupportsOstreamOperator<UnderlyingType>>>
+              internal::SupportsOstreamOperator<UnderlyingType>::value>>
 std::ostream& operator<<(std::ostream& stream,
                          const StrongAlias<TagType, UnderlyingType>& alias) {
   return stream << alias.value();
diff --git a/base/types/strong_alias_unittest.cc b/base/types/strong_alias_unittest.cc
index e69cf7b704..b211d3b474 100644
--- a/base/types/strong_alias_unittest.cc
+++ b/base/types/strong_alias_unittest.cc
@@ -371,7 +371,7 @@ TEST(StrongAliasTest, EnsureConstexpr) {
 void StreamOperatorExists() {
   // Aliases of ints should be streamable because ints are streamable.
   using StreamableAlias = StrongAlias<class IntTag, int>;
-  static_assert(internal::SupportsOstreamOperator<StreamableAlias>);
+  static_assert(internal::SupportsOstreamOperator<StreamableAlias>::value);
 
   // Aliases of a class which does not expose a stream operator should
   // themselves not be streamable.
@@ -380,7 +380,7 @@ void StreamOperatorExists() {
     Scope() = default;
   };
   using NonStreamableAlias = StrongAlias<class ScopeTag, Scope>;
-  static_assert(!internal::SupportsOstreamOperator<NonStreamableAlias>);
+  static_assert(!internal::SupportsOstreamOperator<NonStreamableAlias>::value);
 }
 
 #if BUILDFLAG(ENABLE_BASE_TRACING)
diff --git a/base/types/supports_ostream_operator.h b/base/types/supports_ostream_operator.h
index 7e0100f970..0803db4862 100644
--- a/base/types/supports_ostream_operator.h
+++ b/base/types/supports_ostream_operator.h
@@ -11,13 +11,17 @@
 
 namespace base::internal {
 
-// Detects whether using operator<< would work.
+// Uses expression SFINAE to detect whether using operator<< would work.
 //
 // Note that the above #include of <ostream> is necessary to guarantee
 // consistent results here for basic types.
+template <typename T, typename = void>
+struct SupportsOstreamOperator : std::false_type {};
 template <typename T>
-concept SupportsOstreamOperator =
-    requires(const T& t, std::ostream& os) { os << t; };
+struct SupportsOstreamOperator<T,
+                               decltype(void(std::declval<std::ostream&>()
+                                             << std::declval<T>()))>
+    : std::true_type {};
 
 }  // namespace base::internal
 
diff --git a/base/types/supports_ostream_operator_unittest.cc b/base/types/supports_ostream_operator_unittest.cc
index 31e2628962..0f8c3a09d9 100644
--- a/base/types/supports_ostream_operator_unittest.cc
+++ b/base/types/supports_ostream_operator_unittest.cc
@@ -26,40 +26,43 @@ std::ostream& operator<<(std::ostream& os, const StructWithOperator& v) {
 }
 
 // A few standard types that definitely support printing.
-static_assert(internal::SupportsOstreamOperator<int>,
+static_assert(internal::SupportsOstreamOperator<int>::value,
               "ints should be printable");
-static_assert(internal::SupportsOstreamOperator<const char*>,
+static_assert(internal::SupportsOstreamOperator<const char*>::value,
               "C strings should be printable");
-static_assert(internal::SupportsOstreamOperator<std::string>,
+static_assert(internal::SupportsOstreamOperator<std::string>::value,
               "std::string should be printable");
 
 // Various kinds of enums operator<< support.
-static_assert(internal::SupportsOstreamOperator<SimpleEnum>,
+static_assert(internal::SupportsOstreamOperator<SimpleEnum>::value,
               "simple enum should be printable by value");
-static_assert(internal::SupportsOstreamOperator<const SimpleEnum&>,
+static_assert(internal::SupportsOstreamOperator<const SimpleEnum&>::value,
               "simple enum should be printable by const ref");
-static_assert(internal::SupportsOstreamOperator<EnumWithExplicitType>,
+static_assert(internal::SupportsOstreamOperator<EnumWithExplicitType>::value,
               "enum with explicit type should be printable by value");
-static_assert(internal::SupportsOstreamOperator<const EnumWithExplicitType&>,
-              "enum with explicit type should be printable by const ref");
-static_assert(!internal::SupportsOstreamOperator<ScopedEnum>,
+static_assert(
+    internal::SupportsOstreamOperator<const EnumWithExplicitType&>::value,
+    "enum with explicit type should be printable by const ref");
+static_assert(!internal::SupportsOstreamOperator<ScopedEnum>::value,
               "scoped enum should not be printable by value");
-static_assert(!internal::SupportsOstreamOperator<const ScopedEnum&>,
+static_assert(!internal::SupportsOstreamOperator<const ScopedEnum&>::value,
               "simple enum should not be printable by const ref");
-static_assert(internal::SupportsOstreamOperator<ScopedEnumWithOperator>,
+static_assert(internal::SupportsOstreamOperator<ScopedEnumWithOperator>::value,
               "scoped enum with operator<< should be printable by value");
-static_assert(internal::SupportsOstreamOperator<const ScopedEnumWithOperator&>,
-              "scoped enum with operator<< should be printable by const ref");
+static_assert(
+    internal::SupportsOstreamOperator<const ScopedEnumWithOperator&>::value,
+    "scoped enum with operator<< should be printable by const ref");
 
 // operator<< support on structs.
-static_assert(!internal::SupportsOstreamOperator<SimpleStruct>,
+static_assert(!internal::SupportsOstreamOperator<SimpleStruct>::value,
               "simple struct should not be printable by value");
-static_assert(!internal::SupportsOstreamOperator<const SimpleStruct&>,
+static_assert(!internal::SupportsOstreamOperator<const SimpleStruct&>::value,
               "simple struct should not be printable by const ref");
-static_assert(internal::SupportsOstreamOperator<StructWithOperator>,
+static_assert(internal::SupportsOstreamOperator<StructWithOperator>::value,
               "struct with operator<< should be printable by value");
-static_assert(internal::SupportsOstreamOperator<const StructWithOperator&>,
-              "struct with operator<< should be printable by const ref");
+static_assert(
+    internal::SupportsOstreamOperator<const StructWithOperator&>::value,
+    "struct with operator<< should be printable by const ref");
 
 }  // namespace
 }  // namespace base
-- 
2.43.0.rc1.413.gea7ed67945-goog

