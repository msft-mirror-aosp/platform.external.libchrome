From 1b480bd2a198186f87db5aab010b49fc344abbd4 Mon Sep 17 00:00:00 2001
From: Georg Neis <neis@chromium.org>
Date: Fri, 14 Feb 2025 05:15:15 +0000
Subject: [PATCH 1/2] Revert "[mac] Use pthread_threadid for ThreadId"

This reverts commit 45a077c10ce0c6e9106c897cb7a036a16ebd5561.
---
 .../sampling_profiler_thread_token.cc         |  2 +-
 .../profiler/sampling_profiler_thread_token.h |  6 +++---
 base/threading/hang_watcher.cc                | 19 +++++++++++++++----
 base/threading/hang_watcher.h                 | 11 ++++++++++-
 base/threading/hang_watcher_unittest.cc       | 11 ++++++++++-
 base/threading/platform_thread.h              |  5 ++++-
 base/threading/platform_thread_posix.cc       |  4 +---
 7 files changed, 44 insertions(+), 14 deletions(-)

diff --git a/base/profiler/sampling_profiler_thread_token.cc b/base/profiler/sampling_profiler_thread_token.cc
index afb39f0bdd..5ef3ec4a57 100644
--- a/base/profiler/sampling_profiler_thread_token.cc
+++ b/base/profiler/sampling_profiler_thread_token.cc
@@ -16,7 +16,7 @@ namespace base {
 
 SamplingProfilerThreadToken GetSamplingProfilerCurrentThreadToken() {
   PlatformThreadId id = PlatformThread::CurrentId();
-#if BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_APPLE)
+#if BUILDFLAG(IS_ANDROID)
   return {id, pthread_self()};
 #elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
   std::optional<uintptr_t> maybe_stack_base =
diff --git a/base/profiler/sampling_profiler_thread_token.h b/base/profiler/sampling_profiler_thread_token.h
index 29b5145d12..c2e9ef1b5d 100644
--- a/base/profiler/sampling_profiler_thread_token.h
+++ b/base/profiler/sampling_profiler_thread_token.h
@@ -11,7 +11,7 @@
 #include "base/threading/platform_thread.h"
 #include "build/build_config.h"
 
-#if BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_APPLE)
+#if BUILDFLAG(IS_ANDROID)
 #include <pthread.h>
 #elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
 #include <stdint.h>
@@ -21,11 +21,11 @@ namespace base {
 
 // SamplingProfilerThreadToken represents the thread identifier(s) required by
 // sampling profiler to operate on a thread. PlatformThreadId is needed for all
-// platforms, while Android and Mac also require a pthread_t to pass to pthread
+// platforms, while Android also requires a pthread_t to pass to pthread
 // functions used to obtain the stack base address.
 struct SamplingProfilerThreadToken {
   PlatformThreadId id;
-#if BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_APPLE)
+#if BUILDFLAG(IS_ANDROID)
   pthread_t pthread_id;
 #elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
   // Due to the sandbox, we can only retrieve the stack base address for the
diff --git a/base/threading/hang_watcher.cc b/base/threading/hang_watcher.cc
index b5fe642c24..11fec1abbd 100644
--- a/base/threading/hang_watcher.cc
+++ b/base/threading/hang_watcher.cc
@@ -814,8 +814,8 @@ void HangWatcher::WatchStateSnapShot::Init(
       // the next capture then they'll already be marked and will be included
       // in the capture at that time.
       if (thread_marked && all_threads_marked) {
-        hung_watch_state_copies_.push_back(
-            WatchStateCopy{deadline, watch_state.get()->GetThreadID()});
+        hung_watch_state_copies_.push_back(WatchStateCopy{
+            deadline, watch_state.get()->GetSystemWideThreadID()});
       } else {
         all_threads_marked = false;
       }
@@ -884,8 +884,7 @@ std::string HangWatcher::WatchStateSnapShot::PrepareHungThreadListCrashKey()
 
   // Add as many thread ids to the crash key as possible.
   for (const WatchStateCopy& copy : hung_watch_state_copies_) {
-    std::string fragment =
-        base::NumberToString(copy.thread_id.raw()) + kSeparator;
+    std::string fragment = base::NumberToString(copy.thread_id) + kSeparator;
     if (list_of_hung_thread_ids.size() + fragment.size() <
         static_cast<std::size_t>(debug::CrashKeySize::Size256)) {
       list_of_hung_thread_ids += fragment;
@@ -1224,6 +1223,9 @@ uint64_t HangWatchDeadline::SwitchBitsForTesting() {
 
 HangWatchState::HangWatchState(HangWatcher::ThreadType thread_type)
     : resetter_(&hang_watch_state, this, nullptr), thread_type_(thread_type) {
+#if BUILDFLAG(IS_MAC)
+  pthread_threadid_np(pthread_self(), &system_wide_thread_id_);
+#endif
   thread_id_ = PlatformThread::CurrentId();
 }
 
@@ -1327,6 +1329,15 @@ PlatformThreadId HangWatchState::GetThreadID() const {
   return thread_id_;
 }
 
+uint64_t HangWatchState::GetSystemWideThreadID() const {
+#if BUILDFLAG(IS_MAC)
+  return system_wide_thread_id_;
+#else
+  CHECK_NE(thread_id_, kInvalidThreadId);
+  return static_cast<uint64_t>(thread_id_);
+#endif
+}
+
 }  // namespace internal
 
 }  // namespace base
diff --git a/base/threading/hang_watcher.h b/base/threading/hang_watcher.h
index 1e653a12ad..3ee0fc89ec 100644
--- a/base/threading/hang_watcher.h
+++ b/base/threading/hang_watcher.h
@@ -290,7 +290,7 @@ class BASE_EXPORT HangWatcher : public DelegateSimpleThread::Delegate {
    public:
     struct WatchStateCopy {
       base::TimeTicks deadline;
-      base::PlatformThreadId thread_id;
+      uint64_t thread_id;
     };
 
     WatchStateSnapShot();
@@ -634,6 +634,7 @@ class BASE_EXPORT HangWatchState {
 #endif
 
   PlatformThreadId GetThreadID() const;
+  uint64_t GetSystemWideThreadID() const;
 
   // Retrieve the current hang watch deadline directly. For testing only.
   HangWatchDeadline* GetHangWatchDeadlineForTesting();
@@ -665,6 +666,14 @@ class BASE_EXPORT HangWatchState {
   // only.
   PlatformThreadId thread_id_ = kInvalidThreadId;
 
+#if BUILDFLAG(IS_MAC)
+  // TODO(crbug.com/40187449): Remove this once macOS uses system-wide ids.
+  // On macOS the thread ids used by CrashPad are not the same as the ones
+  // provided by PlatformThread. Make sure to use the same for correct
+  // attribution.
+  uint64_t system_wide_thread_id_;
+#endif
+
   // Number of active HangWatchScopeEnables on this thread.
   int nesting_level_ = 0;
 
diff --git a/base/threading/hang_watcher_unittest.cc b/base/threading/hang_watcher_unittest.cc
index e8835011f8..bfbc9770d4 100644
--- a/base/threading/hang_watcher_unittest.cc
+++ b/base/threading/hang_watcher_unittest.cc
@@ -726,7 +726,16 @@ TEST_F(HangWatcherSnapshotTest, NonActionableReport) {
   }
 }
 
-TEST_F(HangWatcherSnapshotTest, HungThreadIDs) {
+// TODO(crbug.com/40187449): On MAC, the base::PlatformThread::CurrentId(...)
+// should return the system wide IDs. The HungThreadIDs test fails because the
+// reported process ids do not match.
+#if BUILDFLAG(IS_MAC)
+#define MAYBE_HungThreadIDs DISABLED_HungThreadIDs
+#else
+#define MAYBE_HungThreadIDs HungThreadIDs
+#endif
+
+TEST_F(HangWatcherSnapshotTest, MAYBE_HungThreadIDs) {
   // During hang capture the list of hung threads should be populated.
   hang_watcher_.SetOnHangClosureForTesting(base::BindLambdaForTesting([this] {
     EXPECT_EQ(hang_watcher_.GrabWatchStateSnapshotForTesting()
diff --git a/base/threading/platform_thread.h b/base/threading/platform_thread.h
index dca4fc5b7b..06a667f3da 100644
--- a/base/threading/platform_thread.h
+++ b/base/threading/platform_thread.h
@@ -29,6 +29,8 @@
 #include "base/win/windows_types.h"
 #elif BUILDFLAG(IS_FUCHSIA)
 #include <zircon/types.h>
+#elif BUILDFLAG(IS_APPLE)
+#include <mach/mach_types.h>
 #elif BUILDFLAG(IS_POSIX)
 #include <pthread.h>
 #include <unistd.h>
@@ -54,7 +56,8 @@ class BASE_EXPORT PlatformThreadId {
 #elif BUILDFLAG(IS_FUCHSIA)
   using UnderlyingType = zx_koid_t;
 #elif BUILDFLAG(IS_APPLE)
-  using UnderlyingType = uint64_t;
+  // TODO(crbug.com/40187449): Use uint64_t ids from pthread_threadid_np.
+  using UnderlyingType = mach_port_t;
 #elif BUILDFLAG(IS_POSIX)
   using UnderlyingType = pid_t;
 #endif
diff --git a/base/threading/platform_thread_posix.cc b/base/threading/platform_thread_posix.cc
index c9344ccad1..f5ea6363d0 100644
--- a/base/threading/platform_thread_posix.cc
+++ b/base/threading/platform_thread_posix.cc
@@ -218,9 +218,7 @@ PlatformThreadId PlatformThreadBase::CurrentId() {
   // Pthreads doesn't have the concept of a thread ID, so we have to reach down
   // into the kernel.
 #if BUILDFLAG(IS_APPLE)
-  uint64_t tid;
-  CHECK_EQ(pthread_threadid_np(nullptr, &tid), 0);
-  return PlatformThreadId(tid);
+  return PlatformThreadId(pthread_mach_thread_np(pthread_self()));
 #elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
   // Workaround false-positive MSAN use-of-uninitialized-value on
   // thread_local storage for loaded libraries:
-- 
2.48.1.601.g30ceb7b040-goog

