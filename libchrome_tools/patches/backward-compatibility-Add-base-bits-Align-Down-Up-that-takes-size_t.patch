From 33b6b4b81f8b7c824c508de6b3847f9ff61567d8 Mon Sep 17 00:00:00 2001
From: Grace Cham <hscham@chromium.org>
Date: Mon, 26 Sep 2022 11:23:05 +0900
Subject: [PATCH] Add base::bits::Align{Down,Up} that takes size_t explicitly

The functions were changed to be templated in r1023727
(crrev.com/c/3752744) to take size and alignment of the same type. This
causes failure at type deduction with existing usages if they provide
the arguments of different types (which are then implicitly converted to
size_t).

Change-Id: I2b28163d94453fc3f4206e64d7f7e0949d56c7a5
---
 base/bits.h | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/base/bits.h b/base/bits.h
index 512ea7bb46fe..6469f5f44dee 100644
--- a/base/bits.h
+++ b/base/bits.h
@@ -41,6 +41,10 @@ constexpr T AlignDown(T size, T alignment) {
   return size & ~(alignment - 1);
 }
 
+inline constexpr size_t AlignDown(size_t size, size_t alignment) {
+  return AlignDown<size_t>(size, alignment);
+}
+
 // Move |ptr| back to the previous multiple of alignment, which must be a power
 // of two. Defined for types where sizeof(T) is one byte.
 template <typename T, typename = typename std::enable_if<sizeof(T) == 1>::type>
@@ -56,6 +60,10 @@ constexpr T AlignUp(T size, T alignment) {
   return (size + alignment - 1) & ~(alignment - 1);
 }
 
+inline constexpr size_t AlignUp(size_t size, size_t alignment) {
+  return AlignUp<size_t>(size, alignment);
+}
+
 // Advance |ptr| to the next multiple of alignment, which must be a power of
 // two. Defined for types where sizeof(T) is one byte.
 template <typename T, typename = typename std::enable_if<sizeof(T) == 1>::type>
-- 
2.37.3.998.g577e59143f-goog

