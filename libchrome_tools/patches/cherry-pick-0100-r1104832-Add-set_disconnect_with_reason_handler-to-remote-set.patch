This patch merges two CLs from the chromium repo together. Together they will
provide the functionality to disconnect and use disconnect_with_reason_handler
in remote set.

From efcc2e2ab5db4ea8d26d8973e6bb4d6854ba1757 Mon Sep 17 00:00:00 2001
From: Ethan Cheng <yycheng@google.com>
Date: Tue, 14 Feb 2023 03:42:20 +0000
Subject: [PATCH] Add |set_disconnect_with_reason_handler| to remote set

Add the ability to set a disconnect handler with reason for remote set.

Bug: None
Test: pass mojo_unittests
Change-Id: Id77caa8b09a603848354227cc4a59d6a385de7cc
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4242683
Reviewed-by: Ken Rockot <rockot@google.com>
Commit-Queue: Ethan Cheng <yycheng@google.com>
Cr-Commit-Position: refs/heads/main@{#1104832}


From b0c3b23e82fee9e8e20e8d701c9f7cd15dd78392 Mon Sep 17 00:00:00 2001
From: Ethan Cheng <yycheng@google.com>
Date: Tue, 14 Feb 2023 05:52:53 +0000
Subject: [PATCH] mojo: Add RemoteSetImpl::RemoveWithReason & ClearWithReason

To support removing a remote in RemoteSet with reason, like
Remote::ResetWithReason, adds RemoteSetImpl::RemoveWithReason() &
RemoteSetImpl::ClearWithReason().

BUG=chromium:1414799
TEST=builds

Change-Id: I2d418e0b27733c1cce79422696bff699cca3f9a9
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4241017
Reviewed-by: Ken Rockot <rockot@google.com>
Commit-Queue: Cheng-Hao Yang <chenghaoyang@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1104680}

---
 mojo/public/cpp/bindings/remote_set.h         | 43 ++++++++++++++++--
 .../cpp/bindings/tests/remote_unittest.cc     | 44 ++++++++++++++++---
 2 files changed, 79 insertions(+), 8 deletions(-)

diff --git a/mojo/public/cpp/bindings/remote_set.h b/mojo/public/cpp/bindings/remote_set.h
index 6d255462f2116..022a7adca78b2 100644
--- a/mojo/public/cpp/bindings/remote_set.h
+++ b/mojo/public/cpp/bindings/remote_set.h
@@ -98,8 +98,8 @@ class RemoteSetImpl {
   RemoteSetElementId Add(RemoteType<Interface> remote) {
     DCHECK(remote.is_bound());
     auto id = GenerateNextElementId();
-    remote.set_disconnect_handler(base::BindOnce(&RemoteSetImpl::OnDisconnect,
-                                                 base::Unretained(this), id));
+    remote.set_disconnect_with_reason_handler(base::BindOnce(
+        &RemoteSetImpl::OnDisconnect, base::Unretained(this), id));
     auto result = storage_.emplace(id, std::move(remote));
     DCHECK(result.second);
     return id;
@@ -119,6 +119,18 @@ class RemoteSetImpl {

   // Removes a remote from the set given |id|, if present.
   void Remove(RemoteSetElementId id) { storage_.erase(id); }
+  // Similar to the method above, but also specifies a disconnect reason.
+  void RemoveWithReason(RemoteSetElementId id,
+                        uint32_t custom_reason_code,
+                        const std::string& description) {
+    auto it = storage_.find(id);
+    if (it == storage_.end()) {
+      return;
+    }
+
+    it->second.ResetWithReason(custom_reason_code, description);
+    storage_.erase(it);
+  }

   // Indicates whether a remote with the given ID is present in the set.
   bool Contains(RemoteSetElementId id) { return base::Contains(storage_, id); }
@@ -136,11 +148,30 @@ class RemoteSetImpl {
   // Note that the remote in question is already removed from the set by the
   // time the callback is run for its disconnection.
   using DisconnectHandler = base::RepeatingCallback<void(RemoteSetElementId)>;
+  using DisconnectWithReasonHandler =
+      base::RepeatingCallback<void(RemoteSetElementId,
+                                   uint32_t /* custom_reason */,
+                                   const std::string& /* description */)>;
+
   void set_disconnect_handler(DisconnectHandler handler) {
     disconnect_handler_ = std::move(handler);
+    disconnect_with_reason_handler_.Reset();
+  }
+
+  void set_disconnect_with_reason_handler(DisconnectWithReasonHandler handler) {
+    disconnect_with_reason_handler_ = std::move(handler);
+    disconnect_handler_.Reset();
   }

   void Clear() { storage_.clear(); }
+  void ClearWithReason(uint32_t custom_reason_code,
+                       const std::string& description) {
+    for (auto& [_, remote] : storage_) {
+      remote.ResetWithReason(custom_reason_code, description);
+    }
+
+    Clear();
+  }

   bool empty() const { return storage_.empty(); }
   size_t size() const { return storage_.size(); }
@@ -161,15 +192,21 @@ class RemoteSetImpl {
     return remote_set_element_id_generator_.GenerateNextId();
   }

-  void OnDisconnect(RemoteSetElementId id) {
+  void OnDisconnect(RemoteSetElementId id,
+                    uint32_t custom_reason_code,
+                    const std::string& description) {
     Remove(id);
     if (disconnect_handler_)
       disconnect_handler_.Run(id);
+    else if (disconnect_with_reason_handler_) {
+      disconnect_with_reason_handler_.Run(id, custom_reason_code, description);
+    }
   }

   RemoteSetElementId::Generator remote_set_element_id_generator_;
   Storage storage_;
   DisconnectHandler disconnect_handler_;
+  DisconnectWithReasonHandler disconnect_with_reason_handler_;
 };

 template <typename Interface>
diff --git a/mojo/public/cpp/bindings/tests/remote_unittest.cc b/mojo/public/cpp/bindings/tests/remote_unittest.cc
index 3eb2a28f01346..3801b5d830fea 100644
--- a/mojo/public/cpp/bindings/tests/remote_unittest.cc
+++ b/mojo/public/cpp/bindings/tests/remote_unittest.cc
@@ -1307,25 +1307,28 @@ TEST_P(RemoteTest, SharedRemoteSyncCallsFromBoundNonConstructionSequence) {
 }

 TEST_P(RemoteTest, RemoteSet) {
-  std::vector<absl::optional<MathCalculatorImpl>> impls(3);
+  std::vector<absl::optional<MathCalculatorImpl>> impls(4);

   PendingRemote<math::Calculator> remote0;
   PendingRemote<math::Calculator> remote1;
   PendingRemote<math::Calculator> remote2;
+  PendingRemote<math::Calculator> remote3;
   impls[0].emplace(remote0.InitWithNewPipeAndPassReceiver());
   impls[1].emplace(remote1.InitWithNewPipeAndPassReceiver());
   impls[2].emplace(remote2.InitWithNewPipeAndPassReceiver());
+  impls[3].emplace(remote3.InitWithNewPipeAndPassReceiver());

   RemoteSet<math::Calculator> remotes;
   auto id0 = remotes.Add(Remote<math::Calculator>(std::move(remote0)));
   auto id1 = remotes.Add(std::move(remote1));
   auto id2 = remotes.Add(std::move(remote2));
+  auto id3 = remotes.Add(std::move(remote3));

   // Send a message to each and wait for a reply.
   {
     base::RunLoop loop;
     constexpr double kValue = 42.0;
-    auto on_add = base::BarrierClosure(6, loop.QuitClosure());
+    auto on_add = base::BarrierClosure(8, loop.QuitClosure());
     for (auto& remote : remotes) {
       remote->Add(kValue, base::BindLambdaForTesting([&](double total) {
                     EXPECT_EQ(kValue, total);
@@ -1334,7 +1337,7 @@ TEST_P(RemoteTest, RemoteSet) {
     }

     // Use Get() to get a specified remote from RemoteSet.
-    std::vector<mojo::RemoteSetElementId> ids = {id0, id1, id2};
+    std::vector<mojo::RemoteSetElementId> ids = {id0, id1, id2, id3};
     for (auto& id : ids) {
       remotes.Get(id)->Add(kValue,
                            base::BindLambdaForTesting([&](double total) {
@@ -1347,6 +1350,7 @@ TEST_P(RemoteTest, RemoteSet) {
     EXPECT_EQ(kValue * 2, impls[0]->total());
     EXPECT_EQ(kValue * 2, impls[1]->total());
     EXPECT_EQ(kValue * 2, impls[2]->total());
+    EXPECT_EQ(kValue * 2, impls[3]->total());
   }

   EXPECT_FALSE(remotes.empty());
@@ -1361,6 +1365,7 @@ TEST_P(RemoteTest, RemoteSet) {
           EXPECT_FALSE(remotes.Contains(id0));
           EXPECT_TRUE(remotes.Contains(id1));
           EXPECT_TRUE(remotes.Contains(id2));
+          EXPECT_TRUE(remotes.Contains(id3));
           loop.Quit();
         }));
     impls[0].reset();
@@ -1377,6 +1382,7 @@ TEST_P(RemoteTest, RemoteSet) {
           EXPECT_FALSE(remotes.Contains(id0));
           EXPECT_TRUE(remotes.Contains(id1));
           EXPECT_FALSE(remotes.Contains(id2));
+          EXPECT_TRUE(remotes.Contains(id3));
           loop.Quit();
         }));
     impls[2].reset();
@@ -1386,19 +1392,47 @@ TEST_P(RemoteTest, RemoteSet) {
   EXPECT_FALSE(remotes.empty());

   {
+    // Test that remote set disconnect_with_reason_handler can handle resets
+    // without reason.
     base::RunLoop loop;
-    remotes.set_disconnect_handler(
-        base::BindLambdaForTesting([&](RemoteSetElementId id) {
+    remotes.set_disconnect_with_reason_handler(base::BindLambdaForTesting(
+        [&](RemoteSetElementId id, uint32_t custom_reason_code,
+            const std::string& description) {
           EXPECT_EQ(id, id1);
+          EXPECT_EQ(custom_reason_code, static_cast<uint32_t>(0));
+          EXPECT_EQ(description, "");
           EXPECT_FALSE(remotes.Contains(id0));
           EXPECT_FALSE(remotes.Contains(id1));
           EXPECT_FALSE(remotes.Contains(id2));
+          EXPECT_TRUE(remotes.Contains(id3));
           loop.Quit();
         }));
     impls[1].reset();
     loop.Run();
   }

+  EXPECT_FALSE(remotes.empty());
+
+  {
+    // Test that remote set disconnect_with_reason_handler can handle resets
+    // with reason.
+    base::RunLoop loop;
+    remotes.set_disconnect_with_reason_handler(base::BindLambdaForTesting(
+        [&](RemoteSetElementId id, uint32_t custom_reason_code,
+            const std::string& description) {
+          EXPECT_EQ(id, id3);
+          EXPECT_EQ(custom_reason_code, static_cast<uint32_t>(10));
+          EXPECT_EQ(description, "custom description");
+          EXPECT_FALSE(remotes.Contains(id0));
+          EXPECT_FALSE(remotes.Contains(id1));
+          EXPECT_FALSE(remotes.Contains(id2));
+          EXPECT_FALSE(remotes.Contains(id3));
+          loop.Quit();
+        }));
+    impls[3]->receiver().ResetWithReason(10, "custom description");
+    loop.Run();
+  }
+
   EXPECT_TRUE(remotes.empty());
 }

--
2.39.1.581.gbfd45094c4-goog
