From f467334cafb7179cc252b993bacd8ae56c40f484 Mon Sep 17 00:00:00 2001
From: Ren-Pei Zeng <kamesan@chromium.org>
Date: Thu, 5 Dec 2024 04:07:07 +0000
Subject: [PATCH] Revert "Remove make_span."

This reverts commit 2146e0b7c539469002f22820ff0f519d92f2b684.
---
 base/containers/span.h            |  31 +++++++
 base/containers/span_nocompile.nc |  23 +++++-
 base/containers/span_unittest.cc  | 130 +++++++++++++++++++++++++++++-
 3 files changed, 182 insertions(+), 2 deletions(-)

diff --git a/base/containers/span.h b/base/containers/span.h
index fa0f607d3e..dcc6666afd 100644
--- a/base/containers/span.h
+++ b/base/containers/span.h
@@ -235,6 +235,11 @@
 //   convert `basic_cstring_view<T>` to spans, preserving the null terminator.
 // - For convenience, provides `as_[writable_]byte_span()` to convert
 //   spanifiable objects directly to byte spans.
+//
+// Because `span` predated C++17 and CTAD, there are also (deprecated)
+// type-deducing `make_span()` utility functions. Avoid these; use CTAD
+// (`span(...)` without explicit template args) or relevant helper methods.
+// TODO(crbug.com/341907909): Remove these.
 
 namespace base {
 
@@ -1540,6 +1545,32 @@ constexpr auto as_writable_byte_span(
   return as_writable_bytes(span<ElementType, Extent>(arr));
 }
 
+// Type-deducing helper to construct a span.
+// Deprecated: Use CTAD (i.e. use `span()` directly without template arguments).
+// TODO(crbug.com/341907909): Remove.
+template <int&... ExplicitArgumentBarrier, typename It, typename EndOrSize>
+  requires(std::contiguous_iterator<It>)
+// SAFETY: `it` must point to the first of a (possibly-empty) series of
+// contiguous valid elements. If `end_or_size` is a size, the series must
+// contain at least that many valid elements; if it is an iterator or sentinel,
+// it must refer to the same allocation, and all elements in the range [it,
+// end_or_size) must be valid. Otherwise, the span will allow access to invalid
+// elements, resulting in UB.
+UNSAFE_BUFFER_USAGE constexpr auto make_span(It it, EndOrSize end_or_size) {
+  return UNSAFE_BUFFERS(span(it, end_or_size));
+}
+template <int&... ExplicitArgumentBarrier, typename R>
+  requires(internal::SpanConstructibleFrom<R &&>)
+constexpr auto make_span(R&& r LIFETIME_BOUND) {
+  return span(std::forward<R>(r));
+}
+template <int&... ExplicitArgumentBarrier, typename R>
+  requires(internal::SpanConstructibleFrom<R &&> &&
+           std::ranges::borrowed_range<R>)
+constexpr auto make_span(R&& r) {
+  return span(std::forward<R>(r));
+}
+
 }  // namespace base
 
 #endif  // BASE_CONTAINERS_SPAN_H_
diff --git a/base/containers/span_nocompile.nc b/base/containers/span_nocompile.nc
index ca06bbc6c9..fffa95f9e5 100644
--- a/base/containers/span_nocompile.nc
+++ b/base/containers/span_nocompile.nc
@@ -71,6 +71,7 @@ void ConstContainerToMutableConversionDisallowed() {
   const std::vector<int> v = {1, 2, 3};
   span<int> span1(v);             // expected-error {{no matching constructor for initialization of 'span<int>'}}
   span<int, 2u> span2({1, 2});    // expected-error {{no matching constructor for initialization of 'span<int, 2U>'}}
+  span<int> span3(make_span(v));  // expected-error {{no matching constructor for initialization of 'span<int>'}}
 }
 
 // A dynamic const container should not be implicitly convertible to a static span.
@@ -96,6 +97,9 @@ void StdSetConversionDisallowed() {
   span<int> span1(set.begin(), 0u);                // expected-error {{no matching constructor for initialization of 'span<int>'}}
   span<int> span2(set.begin(), set.end());         // expected-error {{no matching constructor for initialization of 'span<int>'}}
   span<int> span3(set);                            // expected-error {{no matching constructor for initialization of 'span<int>'}}
+  auto span4 = make_span(set.begin(), 0u);         // expected-error@*:* {{no matching function for call to 'make_span'}}
+  auto span5 = make_span(set.begin(), set.end());  // expected-error@*:* {{no matching function for call to 'make_span'}}
+  auto span6 = make_span(set);                     // expected-error@*:* {{no matching function for call to 'make_span'}}
 }
 
 // Static views of spans with static extent must not exceed the size.
@@ -156,6 +160,22 @@ void SpanFromNonConstRvalueRange() {
   [[maybe_unused]] auto d = span(std::move(vec));  // expected-error {{no matching conversion}}
 }
 
+// make_span can only be called on a range rvalue when the element type is
+// read-only or the range is a borrowed range.
+void MakeSpanFromNonConstRvalueRange() {
+  std::array<bool, 3> arr = {true, false, true};
+  [[maybe_unused]] auto a = make_span(std::move(arr));  // expected-error {{no matching function for call to 'make_span'}}
+
+  std::string str = "ok";
+  [[maybe_unused]] auto b = make_span(std::move(str));  // expected-error {{no matching function for call to 'make_span'}}
+
+  std::u16string str16 = u"ok";
+  [[maybe_unused]] auto c = make_span(std::move(str16));  // expected-error {{no matching function for call to 'make_span'}}
+
+  std::vector<int> vec = {1, 2, 3, 4, 5};
+  [[maybe_unused]] auto d = make_span(std::move(vec));  // expected-error {{no matching function for call to 'make_span'}}
+}
+
 void Dangling() {
   // `std::array` destroyed at the end of the full expression.
   [[maybe_unused]] auto a = span<const int>(std::to_array({1, 2, 3}));     // expected-error-re {{temporary whose address is used as value of local variable {{.*}}will be destroyed at the end of the full-expression}}
@@ -226,7 +246,8 @@ void NotSizeTSize() {
   // we get assertion failures below where we expect.
   enum Length1 { kSize1 = -1 };
   enum Length2 { kSize2 = -1 };
-  span s(vector.data(), kSize2);  // expected-error@*:* {{no matching function for call to 'strict_cast'}}
+  auto s1 = make_span(vector.data(), kSize1);  // expected-error@*:* {{no matching function for call to 'strict_cast'}}
+  span s2(vector.data(), kSize2);              // expected-error@*:* {{no matching function for call to 'strict_cast'}}
 }
 
 void BadConstConversionsWithStdSpan() {
diff --git a/base/containers/span_unittest.cc b/base/containers/span_unittest.cc
index 6c92d80a7a..b1f056d7e0 100644
--- a/base/containers/span_unittest.cc
+++ b/base/containers/span_unittest.cc
@@ -1885,6 +1885,129 @@ TEST(SpanTest, AsStringView) {
   }
 }
 
+TEST(SpanTest, MakeSpanFromDataAndSize) {
+  int* nullint = nullptr;
+  // SAFETY: zero size is correct when pointer is NULL.
+  auto empty_span = UNSAFE_BUFFERS(make_span(nullint, 0u));
+  EXPECT_TRUE(empty_span.empty());
+  EXPECT_EQ(nullptr, empty_span.data());
+
+  std::vector<int> vector = {1, 1, 2, 3, 5, 8};
+  // SAFETY: vector.size() describes valid portion of vector.data().
+  span<int> UNSAFE_BUFFERS(expected_span(vector.data(), vector.size()));
+  auto made_span = UNSAFE_BUFFERS(make_span(vector.data(), vector.size()));
+  EXPECT_EQ(expected_span.data(), made_span.data());
+  EXPECT_EQ(expected_span.size(), made_span.size());
+  static_assert(decltype(made_span)::extent == dynamic_extent);
+  static_assert(std::is_same_v<decltype(expected_span), decltype(made_span)>,
+                "the type of made_span differs from expected_span!");
+}
+
+TEST(SpanTest, MakeSpanFromPointerPair) {
+  int* nullint = nullptr;
+  // SAFETY: The empty range between NULL and NULL is valid range.
+  auto empty_span = UNSAFE_BUFFERS(make_span(nullint, nullint));
+  EXPECT_TRUE(empty_span.empty());
+  EXPECT_EQ(nullptr, empty_span.data());
+
+  std::vector<int> vector = {1, 1, 2, 3, 5, 8};
+  // SAFETY: `vector.size()` describes valid portion of `vector.data()`.
+  span<int> UNSAFE_BUFFERS(expected_span(vector.data(), vector.size()));
+  auto made_span =
+      UNSAFE_BUFFERS(make_span(vector.data(), vector.data() + vector.size()));
+  EXPECT_EQ(expected_span.data(), made_span.data());
+  EXPECT_EQ(expected_span.size(), made_span.size());
+  static_assert(decltype(made_span)::extent == dynamic_extent);
+  static_assert(std::is_same_v<decltype(expected_span), decltype(made_span)>,
+                "the type of made_span differs from expected_span!");
+}
+
+TEST(SpanTest, MakeSpanFromConstexprArray) {
+  static constexpr int kArray[] = {1, 2, 3, 4, 5};
+  constexpr span<const int, 5> expected_span(kArray);
+  constexpr auto made_span = make_span(kArray);
+  EXPECT_EQ(expected_span.data(), made_span.data());
+  EXPECT_EQ(expected_span.size(), made_span.size());
+  static_assert(decltype(made_span)::extent == 5);
+  static_assert(std::is_same_v<decltype(expected_span), decltype(made_span)>,
+                "the type of made_span differs from expected_span!");
+}
+
+TEST(SpanTest, MakeSpanFromStdArray) {
+  const std::array<int, 5> kArray = {{1, 2, 3, 4, 5}};
+  span<const int, 5> expected_span(kArray);
+  auto made_span = make_span(kArray);
+  EXPECT_EQ(expected_span.data(), made_span.data());
+  EXPECT_EQ(expected_span.size(), made_span.size());
+  static_assert(decltype(made_span)::extent == 5);
+  static_assert(std::is_same_v<decltype(expected_span), decltype(made_span)>,
+                "the type of made_span differs from expected_span!");
+}
+
+TEST(SpanTest, MakeSpanFromConstContainer) {
+  const std::vector<int> vector = {-1, -2, -3, -4, -5};
+  span<const int> expected_span(vector);
+  auto made_span = make_span(vector);
+  EXPECT_EQ(expected_span.data(), made_span.data());
+  EXPECT_EQ(expected_span.size(), made_span.size());
+  static_assert(decltype(made_span)::extent == dynamic_extent);
+  static_assert(std::is_same_v<decltype(expected_span), decltype(made_span)>,
+                "the type of made_span differs from expected_span!");
+}
+
+TEST(SpanTest, MakeSpanFromContainer) {
+  std::vector<int> vector = {-1, -2, -3, -4, -5};
+  span<int> expected_span(vector);
+  auto made_span = make_span(vector);
+  EXPECT_EQ(expected_span.data(), made_span.data());
+  EXPECT_EQ(expected_span.size(), made_span.size());
+  static_assert(decltype(made_span)::extent == dynamic_extent);
+  static_assert(std::is_same_v<decltype(expected_span), decltype(made_span)>,
+                "the type of made_span differs from expected_span!");
+}
+
+TEST(SpanTest, MakeSpanFromDynamicSpan) {
+  static constexpr int kArray[] = {1, 2, 3, 4, 5};
+  constexpr span<const int> expected_span(kArray);
+  constexpr auto made_span = make_span(expected_span);
+  static_assert(std::is_same_v<decltype(expected_span)::element_type,
+                               decltype(made_span)::element_type>,
+                "make_span(span) should have the same element_type as span");
+
+  static_assert(expected_span.data() == made_span.data(),
+                "make_span(span) should have the same data() as span");
+
+  static_assert(expected_span.size() == made_span.size(),
+                "make_span(span) should have the same size() as span");
+
+  static_assert(decltype(made_span)::extent == decltype(expected_span)::extent,
+                "make_span(span) should have the same extent as span");
+
+  static_assert(std::is_same_v<decltype(expected_span), decltype(made_span)>,
+                "the type of made_span differs from expected_span!");
+}
+
+TEST(SpanTest, MakeSpanFromStaticSpan) {
+  static constexpr int kArray[] = {1, 2, 3, 4, 5};
+  constexpr span<const int, 5> expected_span(kArray);
+  constexpr auto made_span = make_span(expected_span);
+  static_assert(std::is_same_v<decltype(expected_span)::element_type,
+                               decltype(made_span)::element_type>,
+                "make_span(span) should have the same element_type as span");
+
+  static_assert(expected_span.data() == made_span.data(),
+                "make_span(span) should have the same data() as span");
+
+  static_assert(expected_span.size() == made_span.size(),
+                "make_span(span) should have the same size() as span");
+
+  static_assert(decltype(made_span)::extent == decltype(expected_span)::extent,
+                "make_span(span) should have the same extent as span");
+
+  static_assert(std::is_same_v<decltype(expected_span), decltype(made_span)>,
+                "the type of made_span differs from expected_span!");
+}
+
 TEST(SpanTest, EnsureConstexprGoodness) {
   static constexpr std::array<int, 5> kArray = {5, 4, 3, 2, 1};
   constexpr span<const int> constexpr_span(kArray);
@@ -3242,6 +3365,11 @@ TEST(SpanTest, FromStdSpan) {
     EXPECT_EQ(base_span.data(), kData);
   }
 
+  {
+    auto base_made_span = base::make_span(std_span);
+    EXPECT_EQ(base_made_span.size(), 3u);
+    EXPECT_EQ(base_made_span.data(), kData);
+  }
   {
     auto base_byte_span = base::as_byte_span(std_span);
     EXPECT_EQ(base_byte_span.size(), sizeof(int) * 3u);
@@ -3294,5 +3422,5 @@ TEST(SpanTest, ToStdSpan) {
     EXPECT_EQ(std_span.data(), kData);
   }
 
-  // no as_byte_span() in std::span.
+  // no make_span() or as_byte_span() in std::span.
 }
-- 
2.47.0.338.g60cca15819-goog

