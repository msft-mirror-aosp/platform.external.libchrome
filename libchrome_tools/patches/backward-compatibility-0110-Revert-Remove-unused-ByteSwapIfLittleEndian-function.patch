From 222bcf76bc02f5a0ea0f99a97acab1a44db63ae8 Mon Sep 17 00:00:00 2001
From: Nathan Muggli <nmuggli@google.com>
Date: Mon, 18 Mar 2024 08:52:47 -0600
Subject: [PATCH 2/3] Revert "Remove unused ByteSwapIfLittleEndian functions"

This reverts commit f713f3df627e0d4a7bd075ff18c0619180760898.
---
 base/big_endian.h | 33 +++++++++++++++++++++++++++++++++
 1 file changed, 33 insertions(+)

diff --git a/base/big_endian.h b/base/big_endian.h
index 678f94cfa9..76c419a799 100644
--- a/base/big_endian.h
+++ b/base/big_endian.h
@@ -22,6 +22,39 @@
 
 namespace base {
 
+namespace internal {
+
+// ByteSwapIfLittleEndian performs ByteSwap if this platform is little-endian,
+// otherwise it is a no-op.
+
+#if defined(ARCH_CPU_LITTLE_ENDIAN)
+
+template <typename T>
+inline auto ByteSwapIfLittleEndian(T val) -> decltype(ByteSwap(val)) {
+  return ByteSwap(val);
+}
+
+#else
+
+// The use of decltype ensures this is only enabled for types for which
+// ByteSwap() is defined, so the same set of overloads will work on both
+// little-endian and big-endian platforms.
+
+template <typename T>
+inline auto ByteSwapIfLittleEndian(T val) -> decltype(ByteSwap(val)) {
+  return val;
+}
+
+#endif
+
+// We never need to byte-swap a single-byte value, but it's convenient to have
+// this overload to avoid a special case.
+inline uint8_t ByteSwapIfLittleEndian(uint8_t val) {
+  return val;
+}
+
+}  // namespace internal
+
 // Allows reading integers in network order (big endian) while iterating over
 // an underlying buffer. All the reading functions advance the internal pointer.
 class BASE_EXPORT BigEndianReader {
-- 
2.44.0.291.gc1ea87d7ee-goog

