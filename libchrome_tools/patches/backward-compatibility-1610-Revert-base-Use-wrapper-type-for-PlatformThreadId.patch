From 70de898167bca3e78105f937b732ad92372e16df Mon Sep 17 00:00:00 2001
From: Georg Neis <neis@chromium.org>
Date: Fri, 14 Feb 2025 05:15:20 +0000
Subject: [PATCH 2/2] Revert "[base] Use wrapper type for PlatformThreadId"

This reverts commit 3498f5440cb6504429ff48613c04650537188f58.
---
 base/android/early_trace_event_binding.cc     | 16 ++--
 base/debug/stack_trace.cc                     |  5 +-
 base/message_loop/message_pump_glib.cc        |  2 +-
 base/process/internal_linux.h                 |  5 +-
 base/process/process_unittest.cc              |  2 +-
 base/process/set_process_title.cc             |  3 +-
 base/profiler/stack_base_address_posix.cc     |  2 +-
 .../stack_base_address_posix_unittest.cc      |  4 +-
 .../stack_sampling_profiler_test_util.h       |  2 +-
 .../thread_delegate_posix_unittest.cc         |  4 +-
 .../sampling_heap_profiler.cc                 |  2 +-
 .../sequence_manager/thread_controller.cc     |  3 +-
 base/test/launcher/test_launcher_tracer.cc    | 15 +--
 base/test/launcher/test_results_tracker.cc    | 18 +---
 .../launcher/test_results_tracker_unittest.cc |  2 +-
 base/threading/hang_watcher.cc                |  4 +-
 base/threading/hang_watcher.h                 |  2 +-
 base/threading/hang_watcher_unittest.cc       |  2 +-
 base/threading/platform_thread.cc             |  5 -
 base/threading/platform_thread.h              | 94 +++----------------
 base/threading/platform_thread_android.cc     |  9 +-
 base/threading/platform_thread_cros.cc        | 22 ++---
 base/threading/platform_thread_linux.cc       | 13 ++-
 base/threading/platform_thread_posix.cc       | 18 ++--
 base/threading/platform_thread_unittest.cc    |  2 +-
 base/threading/thread_collision_warner.h      |  2 +-
 base/trace_event/trace_event_impl.cc          | 23 +----
 base/trace_event/trace_event_impl.h           |  2 +-
 base/trace_event/trace_log.cc                 | 20 ++--
 base/tracing/perfetto_platform.cc             |  3 +-
 30 files changed, 88 insertions(+), 218 deletions(-)

diff --git a/base/android/early_trace_event_binding.cc b/base/android/early_trace_event_binding.cc
index 66fce41a80..47673de66c 100644
--- a/base/android/early_trace_event_binding.cc
+++ b/base/android/early_trace_event_binding.cc
@@ -28,8 +28,8 @@ static void JNI_EarlyTraceEvent_RecordEarlyBeginEvent(JNIEnv* env,
       TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(internal::kJavaTraceCategory);
   trace_event_internal::AddTraceEventWithThreadIdAndTimestamps(
       TRACE_EVENT_PHASE_BEGIN, category_group_enabled, name.c_str(),
-      /*scope=*/nullptr, trace_event_internal::kNoId,
-      PlatformThreadId(thread_id), TimeTicks::FromJavaNanoTime(time_ns),
+      /*scope=*/nullptr, trace_event_internal::kNoId, thread_id,
+      TimeTicks::FromJavaNanoTime(time_ns),
       ThreadTicks() + Milliseconds(thread_time_ms),
       TRACE_EVENT_FLAG_JAVA_STRING_LITERALS | TRACE_EVENT_FLAG_COPY);
 #endif  // BUILDFLAG(ENABLE_BASE_TRACING)
@@ -45,8 +45,8 @@ static void JNI_EarlyTraceEvent_RecordEarlyEndEvent(JNIEnv* env,
       TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(internal::kJavaTraceCategory);
   trace_event_internal::AddTraceEventWithThreadIdAndTimestamps(
       TRACE_EVENT_PHASE_END, category_group_enabled, name.c_str(),
-      /*scope=*/nullptr, trace_event_internal::kNoId,
-      PlatformThreadId(thread_id), TimeTicks::FromJavaNanoTime(time_ns),
+      /*scope=*/nullptr, trace_event_internal::kNoId, thread_id,
+      TimeTicks::FromJavaNanoTime(time_ns),
       ThreadTicks() + Milliseconds(thread_time_ms),
       TRACE_EVENT_FLAG_JAVA_STRING_LITERALS | TRACE_EVENT_FLAG_COPY);
 #endif  // BUILDFLAG(ENABLE_BASE_TRACING)
@@ -64,8 +64,8 @@ static void JNI_EarlyTraceEvent_RecordEarlyToplevelBeginEvent(
           internal::kToplevelTraceCategory);
   trace_event_internal::AddTraceEventWithThreadIdAndTimestamps(
       TRACE_EVENT_PHASE_BEGIN, category_group_enabled, name.c_str(),
-      /*scope=*/nullptr, trace_event_internal::kNoId,
-      PlatformThreadId(thread_id), TimeTicks::FromJavaNanoTime(time_ns),
+      /*scope=*/nullptr, trace_event_internal::kNoId, thread_id,
+      TimeTicks::FromJavaNanoTime(time_ns),
       ThreadTicks() + Milliseconds(thread_time_ms),
       TRACE_EVENT_FLAG_JAVA_STRING_LITERALS | TRACE_EVENT_FLAG_COPY);
 #endif  // BUILDFLAG(ENABLE_BASE_TRACING)
@@ -83,8 +83,8 @@ static void JNI_EarlyTraceEvent_RecordEarlyToplevelEndEvent(
           internal::kToplevelTraceCategory);
   trace_event_internal::AddTraceEventWithThreadIdAndTimestamps(
       TRACE_EVENT_PHASE_END, category_group_enabled, name.c_str(),
-      /*scope=*/nullptr, trace_event_internal::kNoId,
-      PlatformThreadId(thread_id), TimeTicks::FromJavaNanoTime(time_ns),
+      /*scope=*/nullptr, trace_event_internal::kNoId, thread_id,
+      TimeTicks::FromJavaNanoTime(time_ns),
       ThreadTicks() + Milliseconds(thread_time_ms),
       TRACE_EVENT_FLAG_JAVA_STRING_LITERALS | TRACE_EVENT_FLAG_COPY);
 #endif  // BUILDFLAG(ENABLE_BASE_TRACING)
diff --git a/base/debug/stack_trace.cc b/base/debug/stack_trace.cc
index fe2c83a0ad..3cea43f04f 100644
--- a/base/debug/stack_trace.cc
+++ b/base/debug/stack_trace.cc
@@ -206,7 +206,7 @@ uintptr_t GetStackEnd() {
   // values from its pthread_t argument.
   static uintptr_t main_stack_end = 0;
 
-  bool is_main_thread = GetCurrentProcId() == PlatformThread::CurrentId().raw();
+  bool is_main_thread = GetCurrentProcId() == PlatformThread::CurrentId();
   if (is_main_thread && main_stack_end) {
     return main_stack_end;
   }
@@ -234,8 +234,7 @@ uintptr_t GetStackEnd() {
 #else
 
 #if (BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)) && defined(__GLIBC__)
-  static_assert(std::is_same_v<ProcessId, PlatformThreadId::UnderlyingType>);
-  if (GetCurrentProcId() == PlatformThread::CurrentId().raw()) {
+  if (GetCurrentProcId() == PlatformThread::CurrentId()) {
     // For the main thread we have a shortcut.
     return reinterpret_cast<uintptr_t>(__libc_stack_end);
   }
diff --git a/base/message_loop/message_pump_glib.cc b/base/message_loop/message_pump_glib.cc
index 5df743e45e..6ce797e59e 100644
--- a/base/message_loop/message_pump_glib.cc
+++ b/base/message_loop/message_pump_glib.cc
@@ -53,7 +53,7 @@ int GetTimeIntervalMilliseconds(TimeTicks next_task_time) {
 
 bool RunningOnMainThread() {
   auto pid = getpid();
-  auto tid = PlatformThread::CurrentId().raw();
+  auto tid = PlatformThread::CurrentId();
   return pid > 0 && tid > 0 && pid == tid;
 }
 
diff --git a/base/process/internal_linux.h b/base/process/internal_linux.h
index 9b621410c2..493722298b 100644
--- a/base/process/internal_linux.h
+++ b/base/process/internal_linux.h
@@ -158,11 +158,10 @@ void ForEachProcessTask(base::ProcessHandle process, Lambda&& lambda) {
       continue;
     }
 
-    PlatformThreadId::UnderlyingType tid_value;
-    if (!StringToInt(tid_str, &tid_value)) {
+    PlatformThreadId tid;
+    if (!StringToInt(tid_str, &tid)) {
       continue;
     }
-    PlatformThreadId tid(tid_value);
 
     FilePath task_path = fd_path.Append(tid_str);
     lambda(tid, task_path);
diff --git a/base/process/process_unittest.cc b/base/process/process_unittest.cc
index d18b91c58e..1d8579ca92 100644
--- a/base/process/process_unittest.cc
+++ b/base/process/process_unittest.cc
@@ -419,7 +419,7 @@ TEST_F(ProcessTest, SetProcessPriority) {
 bool IsThreadRT(PlatformThreadId thread_id) {
   // Check if the thread is running in real-time mode
   int sched = sched_getscheduler(
-      PlatformThread::CurrentId() == thread_id ? 0 : thread_id.raw());
+      PlatformThread::CurrentId() == thread_id ? 0 : thread_id);
   if (sched == -1) {
     // The thread may disappear for any reason so ignore ESRCH.
     DPLOG_IF(ERROR, errno != ESRCH)
diff --git a/base/process/set_process_title.cc b/base/process/set_process_title.cc
index b638952395..edd8c78fb1 100644
--- a/base/process/set_process_title.cc
+++ b/base/process/set_process_title.cc
@@ -54,8 +54,7 @@ void SetProcessTitleFromCommandLine(const char** main_argv) {
   bool have_argv0 = false;
 
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
-  DCHECK_EQ(base::PlatformThread::CurrentId(),
-            base::PlatformThreadId(getpid()));
+  DCHECK_EQ(base::PlatformThread::CurrentId(), getpid());
 
   if (main_argv) {
     setproctitle_init(main_argv);
diff --git a/base/profiler/stack_base_address_posix.cc b/base/profiler/stack_base_address_posix.cc
index 1a0e00098e..0ac9ba6324 100644
--- a/base/profiler/stack_base_address_posix.cc
+++ b/base/profiler/stack_base_address_posix.cc
@@ -82,7 +82,7 @@ std::optional<uintptr_t> GetThreadStackBaseAddress(PlatformThreadId id,
   // trying to work around the problem.
   return std::nullopt;
 #else
-  const bool is_main_thread = id.raw() == GetCurrentProcId();
+  const bool is_main_thread = id == GetCurrentProcId();
   if (is_main_thread) {
 #if BUILDFLAG(IS_ANDROID)
     // The implementation of pthread_getattr_np() in Bionic reads proc/self/maps
diff --git a/base/profiler/stack_base_address_posix_unittest.cc b/base/profiler/stack_base_address_posix_unittest.cc
index fc7dd1a6df..bfa0e543a8 100644
--- a/base/profiler/stack_base_address_posix_unittest.cc
+++ b/base/profiler/stack_base_address_posix_unittest.cc
@@ -40,8 +40,8 @@ TEST(GetThreadStackBaseAddressTest, MAYBE_CurrentThread) {
 TEST(GetThreadStackBaseAddressTest, MainThread) {
   // GetThreadStackBaseAddress does not use pthread_id for main thread on these
   // platforms.
-  std::optional<uintptr_t> base = GetThreadStackBaseAddress(
-      PlatformThreadId(GetCurrentProcId()), pthread_t());
+  std::optional<uintptr_t> base =
+      GetThreadStackBaseAddress(GetCurrentProcId(), pthread_t());
   EXPECT_THAT(base, Optional(Gt(0u)));
 }
 
diff --git a/base/profiler/stack_sampling_profiler_test_util.h b/base/profiler/stack_sampling_profiler_test_util.h
index 8f0b74d152..8bcbdcd4b9 100644
--- a/base/profiler/stack_sampling_profiler_test_util.h
+++ b/base/profiler/stack_sampling_profiler_test_util.h
@@ -44,7 +44,7 @@ class TargetThread : public PlatformThread::Delegate {
   SamplingProfilerThreadToken thread_token() const { return thread_token_; }
 
  private:
-  SamplingProfilerThreadToken thread_token_ = {kInvalidThreadId};
+  SamplingProfilerThreadToken thread_token_ = {0};
   OnceClosure to_run_;
   PlatformThreadHandle target_thread_handle_;
 };
diff --git a/base/profiler/thread_delegate_posix_unittest.cc b/base/profiler/thread_delegate_posix_unittest.cc
index d6971674ba..b2b7b4e6fc 100644
--- a/base/profiler/thread_delegate_posix_unittest.cc
+++ b/base/profiler/thread_delegate_posix_unittest.cc
@@ -37,8 +37,8 @@ TEST(ThreadDelegatePosixTest, MAYBE_CurrentThreadBase) {
 // GetThreadStackBaseAddressTest.MainThread.
 TEST(ThreadDelegatePosixTest, MainThreadStackBase) {
   // The delegate does not use pthread id for main thread.
-  auto delegate = ThreadDelegatePosix::Create(SamplingProfilerThreadToken{
-      PlatformThreadId(GetCurrentProcId()), pthread_t()});
+  auto delegate = ThreadDelegatePosix::Create(
+      SamplingProfilerThreadToken{GetCurrentProcId(), pthread_t()});
   ASSERT_TRUE(delegate);
   uintptr_t base = delegate->GetStackBaseAddress();
   EXPECT_GT(base, 0u);
diff --git a/base/sampling_heap_profiler/sampling_heap_profiler.cc b/base/sampling_heap_profiler/sampling_heap_profiler.cc
index 0928e1a28a..e82f6dc315 100644
--- a/base/sampling_heap_profiler/sampling_heap_profiler.cc
+++ b/base/sampling_heap_profiler/sampling_heap_profiler.cc
@@ -98,7 +98,7 @@ const char* GetAndLeakThreadName() {
 
   // Use tid if we don't have a thread name.
   snprintf(name, sizeof(name), "Thread %lu",
-           static_cast<unsigned long>(base::PlatformThread::CurrentId().raw()));
+           static_cast<unsigned long>(base::PlatformThread::CurrentId()));
   return strdup(name);
 }
 
diff --git a/base/task/sequence_manager/thread_controller.cc b/base/task/sequence_manager/thread_controller.cc
index f82e2ab448..b91f2077ae 100644
--- a/base/task/sequence_manager/thread_controller.cc
+++ b/base/task/sequence_manager/thread_controller.cc
@@ -154,8 +154,7 @@ void ThreadController::RunLevelTracker::TimeKeeper::EnableRecording(
       // In the non-SDK version, ThreadTrack::Current() returns a different
       // track id on some platforms (for example Mac OS), which results in
       // async tracks not being associated with their thread.
-      perfetto::ThreadTrack::ForThread(
-          base::PlatformThread::CurrentId().raw()));
+      perfetto::ThreadTrack::ForThread(base::PlatformThread::CurrentId()));
   // TODO(crbug.com/42050015): Use Perfetto library to name this Track.
   // auto desc = perfetto_track_->Serialize();
   // desc.set_name(JoinString({"MessagePumpPhases", thread_name}, " "));
diff --git a/base/test/launcher/test_launcher_tracer.cc b/base/test/launcher/test_launcher_tracer.cc
index a9bfcb096f..0804ad925e 100644
--- a/base/test/launcher/test_launcher_tracer.cc
+++ b/base/test/launcher/test_launcher_tracer.cc
@@ -42,20 +42,7 @@ bool TestLauncherTracer::Dump(const FilePath& path) {
                    checked_cast<int>(
                        (event.timestamp - trace_start_time_).InMicroseconds()));
     json_event.Set("dur", checked_cast<int>(event.duration.InMicroseconds()));
-
-    // The TID might be an int64, however int64 values are not representable in
-    // JS and JSON (cf. crbug.com/40228085) since JS numbers are float64. Since
-    // thread IDs are likely to be allocated sequentially, truncation of the
-    // high bits is preferable to loss of precision in the low bits, as threads
-    // are more likely to differ in their low bit values, so we truncate the
-    // value to int32. Since this is only used for dumping test runner state,
-    // the loss of information is not catastrophic and won't happen in normal
-    // browser execution. Additionally, the test thread ids are also truncated,
-    // so the truncated values should match.
-    //
-    // LINT.IfChange(TestLauncherTidTruncation)
-    json_event.Set("tid", event.thread_id.truncate_to_int32_for_display_only());
-    // LINT.ThenChange(test_results_tracker.cc:TestLauncherTidTruncation)
+    json_event.Set("tid", checked_cast<int>(event.thread_id));
 
     // Add fake values required by the trace viewer.
     json_event.Set("pid", 0);
diff --git a/base/test/launcher/test_results_tracker.cc b/base/test/launcher/test_results_tracker.cc
index 1bf546b57f..9b9e170d73 100644
--- a/base/test/launcher/test_results_tracker.cc
+++ b/base/test/launcher/test_results_tracker.cc
@@ -453,22 +453,8 @@ bool TestResultsTracker::SaveSummaryAsJSON(
             static_cast<int>(test_result.elapsed_time.InMilliseconds()));
 
         if (test_result.thread_id) {
-          // The thread id might be an int64, however int64 values are not
-          // representable in JS and JSON (cf. crbug.com/40228085) since JS
-          // numbers are float64. Since thread IDs are likely to be allocated
-          // sequentially, truncation of the high bits is preferable to loss of
-          // precision in the low bits, as threads are more likely to differ in
-          // their low bit values, so we truncate the value to int32. Since this
-          // is only used for dumping test runner state, the loss of information
-          // is not catastrophic and won't happen in normal browser execution.
-          // Additionally, the test launcher tid is also truncated, so the
-          // truncated values should match.
-          //
-          // LINT.IfChange(TestLauncherTidTruncation)
-          test_result_value.Set(
-              "thread_id",
-              test_result.thread_id->truncate_to_int32_for_display_only());
-          // LINT.ThenChange(test_launcher_tracer.cc:TestLauncherTidTruncation)
+          test_result_value.Set("thread_id",
+                                static_cast<int>(*test_result.thread_id));
         }
         if (test_result.process_num) {
           test_result_value.Set("process_num", *test_result.process_num);
diff --git a/base/test/launcher/test_results_tracker_unittest.cc b/base/test/launcher/test_results_tracker_unittest.cc
index 5f914768b0..ce49de8d5b 100644
--- a/base/test/launcher/test_results_tracker_unittest.cc
+++ b/base/test/launcher/test_results_tracker_unittest.cc
@@ -138,7 +138,7 @@ TEST(TestResultsTrackerTest, SaveSummaryAsJSONWithTimestampInResult) {
   TestResultsTracker tracker;
   TestResult result;
   result.full_name = "A.B";
-  result.thread_id = base::PlatformThreadId::ForTest(123);
+  result.thread_id = 123;
   result.process_num = 456;
   result.timestamp = Time::Now();
 
diff --git a/base/threading/hang_watcher.cc b/base/threading/hang_watcher.cc
index 11fec1abbd..c456ac5ad1 100644
--- a/base/threading/hang_watcher.cc
+++ b/base/threading/hang_watcher.cc
@@ -797,7 +797,7 @@ void HangWatcher::WatchStateSnapShot::Init(
                                                LoggingLevel::kUmaOnly)) {
         const PlatformThreadId thread_id = watch_state.get()->GetThreadID();
         const auto track = perfetto::Track::FromPointer(
-            this, perfetto::ThreadTrack::ForThread(thread_id.raw()));
+            this, perfetto::ThreadTrack::ForThread(thread_id));
         TRACE_EVENT_BEGIN("latency", "HangWatcher::ThreadHung", track,
                           now - monitoring_period);
         TRACE_EVENT_END("latency", track, now);
@@ -1333,7 +1333,7 @@ uint64_t HangWatchState::GetSystemWideThreadID() const {
 #if BUILDFLAG(IS_MAC)
   return system_wide_thread_id_;
 #else
-  CHECK_NE(thread_id_, kInvalidThreadId);
+  CHECK(thread_id_ > 0);
   return static_cast<uint64_t>(thread_id_);
 #endif
 }
diff --git a/base/threading/hang_watcher.h b/base/threading/hang_watcher.h
index 3ee0fc89ec..a98022505a 100644
--- a/base/threading/hang_watcher.h
+++ b/base/threading/hang_watcher.h
@@ -664,7 +664,7 @@ class BASE_EXPORT HangWatchState {
 
   // A unique ID of the thread under watch. Used for logging in crash reports
   // only.
-  PlatformThreadId thread_id_ = kInvalidThreadId;
+  PlatformThreadId thread_id_;
 
 #if BUILDFLAG(IS_MAC)
   // TODO(crbug.com/40187449): Remove this once macOS uses system-wide ids.
diff --git a/base/threading/hang_watcher_unittest.cc b/base/threading/hang_watcher_unittest.cc
index bfbc9770d4..d620dd1d69 100644
--- a/base/threading/hang_watcher_unittest.cc
+++ b/base/threading/hang_watcher_unittest.cc
@@ -646,7 +646,7 @@ class HangWatcherSnapshotTest : public testing::Test {
     constexpr char kSeparator{'|'};
 
     for (PlatformThreadId id : ids) {
-      result += base::NumberToString(id.raw()) + kSeparator;
+      result += base::NumberToString(id) + kSeparator;
     }
 
     return result;
diff --git a/base/threading/platform_thread.cc b/base/threading/platform_thread.cc
index abe6453165..e457a04dc2 100644
--- a/base/threading/platform_thread.cc
+++ b/base/threading/platform_thread.cc
@@ -6,7 +6,6 @@
 
 #include "base/task/current_thread.h"
 #include "base/threading/thread_id_name_manager.h"
-#include "base/trace_event/base_tracing.h"
 
 #if BUILDFLAG(IS_FUCHSIA)
 #include "base/fuchsia/scheduler.h"
@@ -20,10 +19,6 @@ constinit thread_local ThreadType current_thread_type = ThreadType::kDefault;
 
 }  // namespace
 
-void PlatformThreadId::WriteIntoTrace(perfetto::TracedValue&& context) const {
-  perfetto::WriteIntoTracedValue(std::move(context), value_);
-}
-
 // static
 void PlatformThreadBase::SetCurrentThreadType(ThreadType thread_type) {
   MessagePumpType message_pump_type = MessagePumpType::DEFAULT;
diff --git a/base/threading/platform_thread.h b/base/threading/platform_thread.h
index 06a667f3da..e88245e1ad 100644
--- a/base/threading/platform_thread.h
+++ b/base/threading/platform_thread.h
@@ -12,7 +12,6 @@
 #include <stddef.h>
 
 #include <iosfwd>
-#include <limits>
 #include <optional>
 #include <type_traits>
 
@@ -21,7 +20,6 @@
 #include "base/process/process_handle.h"
 #include "base/threading/platform_thread_ref.h"
 #include "base/time/time.h"
-#include "base/trace_event/base_tracing_forward.h"
 #include "base/types/strong_alias.h"
 #include "build/build_config.h"
 
@@ -42,87 +40,17 @@
 
 namespace base {
 
-// Used for uniquely identifying a thread.
-//
-// Wraps a platform-specific integer value with platform-specific size,
-// guaranteed to have a maximum bitness of 64-bit. Getting a 32-bit value is
-// possible only if we either know the platform-specific size (because we're in
-// platform-specific code), or if we are ok with truncation of the value (e.g.
-// because we are logging and the occasional false match is not catastrophic).
-class BASE_EXPORT PlatformThreadId {
- public:
+// Used for logging. Always an integer value.
 #if BUILDFLAG(IS_WIN)
-  using UnderlyingType = DWORD;
+typedef DWORD PlatformThreadId;
 #elif BUILDFLAG(IS_FUCHSIA)
-  using UnderlyingType = zx_koid_t;
+typedef zx_koid_t PlatformThreadId;
 #elif BUILDFLAG(IS_APPLE)
-  // TODO(crbug.com/40187449): Use uint64_t ids from pthread_threadid_np.
-  using UnderlyingType = mach_port_t;
+typedef mach_port_t PlatformThreadId;
 #elif BUILDFLAG(IS_POSIX)
-  using UnderlyingType = pid_t;
+typedef pid_t PlatformThreadId;
 #endif
-  static_assert(std::is_integral_v<UnderlyingType>, "Always an integer value.");
-
-  constexpr PlatformThreadId() = default;
-
-  // Special templated constructor which prevents implicit conversion of the
-  // integer argument.
-  template <typename T>
-  explicit constexpr PlatformThreadId(T value)
-    requires(std::is_same_v<T, UnderlyingType>)
-      : value_(value) {}
-
-  static constexpr PlatformThreadId ForTest(int value) {
-    return PlatformThreadId(static_cast<UnderlyingType>(value));
-  }
-
-  // Allow conversion to u/int64_t, whether the underlying type is signed or
-  // not, and whether it is 32-bit or 64-bit.
-  explicit constexpr operator uint64_t() const {
-    static_assert(sizeof(uint64_t) >= sizeof(UnderlyingType));
-    return static_cast<uint64_t>(value_);
-  }
-  explicit constexpr operator int64_t() const {
-    static_assert(sizeof(int64_t) >= sizeof(UnderlyingType));
-    return static_cast<int64_t>(value_);
-  }
-  // Forbid conversion to u/int32_t, since we might have a 64-bit
-  // value -- use truncate_to_int32_for_display_only() or raw() instead.
-  explicit constexpr operator uint32_t() const = delete;
-  explicit constexpr operator int32_t() const = delete;
-
-  // Truncating getter for an int32 representation of the id.
-  //
-  // AVOID: This should only be used in cases where truncation is not
-  // catastrophic, e.g. displaying the thread id in traces or logs. It will
-  // always be preferable to display the full, untruncated thread id.
-  constexpr int32_t truncate_to_int32_for_display_only() const {
-    return static_cast<int32_t>(value_);
-  }
-
-  // Getter for the underlying raw value. Should only be used when
-  // exposing the UnderlyingType, e.g. passing into system APIs or passing into
-  // functions overloaded on different integer sizes like NumberToString.
-  constexpr UnderlyingType raw() const { return value_; }
-
-  constexpr friend auto operator<=>(const PlatformThreadId& lhs,
-                                    const PlatformThreadId& rhs) = default;
-  constexpr friend bool operator==(const PlatformThreadId& lhs,
-                                   const PlatformThreadId& rhs) = default;
-
-  // Allow serialising into a trace.
-  void WriteIntoTrace(perfetto::TracedValue&& context) const;
-
- private:
-  // TODO(crbug.com/393384253): Use a system-specific invalid value, which might
-  // be 0, -1, or some other value from a system header.
-  UnderlyingType value_ = 0;
-};
-
-inline std::ostream& operator<<(std::ostream& stream,
-                                const PlatformThreadId& id) {
-  return stream << id.raw();
-}
+static_assert(std::is_integral_v<PlatformThreadId>, "Always an integer value.");
 
 // Used to operate on threads.
 class PlatformThreadHandle {
@@ -149,7 +77,7 @@ class PlatformThreadHandle {
   Handle handle_;
 };
 
-static constexpr PlatformThreadId kInvalidThreadId = PlatformThreadId();
+const PlatformThreadId kInvalidThreadId(0);
 
 // Valid values for `thread_type` of Thread::Options, SimpleThread::Options,
 // and SetCurrentThreadType(), listed in increasing order of importance.
@@ -380,7 +308,7 @@ class BASE_EXPORT PlatformThreadLinux : public PlatformThreadBase {
   // to change the priority of sandboxed threads for improved performance.
   // Warning: Don't use this for a main thread because that will change the
   // whole thread group's (i.e. process) priority.
-  static void SetThreadType(ProcessId process_id,
+  static void SetThreadType(PlatformThreadId process_id,
                             PlatformThreadId thread_id,
                             ThreadType thread_type,
                             IsViaIPC via_ipc);
@@ -415,7 +343,7 @@ class BASE_EXPORT PlatformThreadChromeOS : public PlatformThreadLinux {
   // Toggles a specific thread's type at runtime. This is the ChromeOS-specific
   // version and includes Linux's functionality but does slightly more. See
   // PlatformThreadLinux's SetThreadType() header comment for Linux details.
-  static void SetThreadType(ProcessId process_id,
+  static void SetThreadType(PlatformThreadId process_id,
                             PlatformThreadId thread_id,
                             ThreadType thread_type,
                             IsViaIPC via_ipc);
@@ -470,13 +398,13 @@ void SetCurrentThreadTypeImpl(ThreadType thread_type,
                               MessagePumpType pump_type_hint);
 
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
-void SetThreadTypeLinux(ProcessId process_id,
+void SetThreadTypeLinux(PlatformThreadId process_id,
                         PlatformThreadId thread_id,
                         ThreadType thread_type,
                         IsViaIPC via_ipc);
 #endif
 #if BUILDFLAG(IS_CHROMEOS)
-void SetThreadTypeChromeOS(ProcessId process_id,
+void SetThreadTypeChromeOS(PlatformThreadId process_id,
                            PlatformThreadId thread_id,
                            ThreadType thread_type,
                            IsViaIPC via_ipc);
diff --git a/base/threading/platform_thread_android.cc b/base/threading/platform_thread_android.cc
index 4ffb477b32..9802dc7cda 100644
--- a/base/threading/platform_thread_android.cc
+++ b/base/threading/platform_thread_android.cc
@@ -68,8 +68,7 @@ bool SetCurrentThreadTypeForPlatform(ThreadType thread_type,
       base::android::BuildInfo::GetInstance()->sdk_int() <
           base::android::SDK_VERSION_T) {
     JNIEnv* env = base::android::AttachCurrentThread();
-    Java_ThreadUtils_setThreadPriorityAudio(env,
-                                            PlatformThread::CurrentId().raw());
+    Java_ThreadUtils_setThreadPriorityAudio(env, PlatformThread::CurrentId());
     return true;
   }
   // Recent versions of Android (O+) up the priority of the UI thread
@@ -86,8 +85,8 @@ bool SetCurrentThreadTypeForPlatform(ThreadType thread_type,
 std::optional<ThreadPriorityForTest>
 GetCurrentThreadPriorityForPlatformForTest() {
   JNIEnv* env = base::android::AttachCurrentThread();
-  if (Java_ThreadUtils_isThreadPriorityAudio(
-          env, PlatformThread::CurrentId().raw())) {
+  if (Java_ThreadUtils_isThreadPriorityAudio(env,
+                                             PlatformThread::CurrentId())) {
     return std::make_optional(ThreadPriorityForTest::kRealtimeAudio);
   }
   return std::nullopt;
@@ -102,7 +101,7 @@ void PlatformThread::SetName(const std::string& name) {
   // debugger by setting the process name for the LWP.
   // We don't want to do this for the main thread because that would rename
   // the process, causing tools like killall to stop working.
-  if (PlatformThread::CurrentId().raw() == getpid()) {
+  if (PlatformThread::CurrentId() == getpid()) {
     return;
   }
 
diff --git a/base/threading/platform_thread_cros.cc b/base/threading/platform_thread_cros.cc
index a39e31e872..af8a4ac709 100644
--- a/base/threading/platform_thread_cros.cc
+++ b/base/threading/platform_thread_cros.cc
@@ -158,10 +158,9 @@ void SetThreadLatencySensitivity(ProcessId process_id,
   // conversion from NS tid to global tid is done by the callers using
   // FindThreadID().
   FilePath thread_dir;
-  if (thread_id != kInvalidThreadId &&
-      thread_id != PlatformThread::CurrentId()) {
-    thread_dir = FilePath(
-        StringPrintf("/proc/%d/task/%d/", process_id, thread_id.raw()));
+  if (thread_id && thread_id != PlatformThread::CurrentId()) {
+    thread_dir =
+        FilePath(StringPrintf("/proc/%d/task/%d/", process_id, thread_id));
   } else {
     thread_dir = FilePath("/proc/thread-self/");
   }
@@ -173,7 +172,7 @@ void SetThreadLatencySensitivity(ProcessId process_id,
   }
 
   // Silently ignore if getattr fails due to sandboxing.
-  if (sched_getattr(thread_id.raw(), &attr, sizeof(attr), 0) == -1 ||
+  if (sched_getattr(thread_id, &attr, sizeof(attr), 0) == -1 ||
       attr.size != sizeof(attr)) {
     return;
   }
@@ -218,7 +217,7 @@ void SetThreadLatencySensitivity(ProcessId process_id,
   DCHECK_LE(attr.sched_util_max, kSchedulerUclampMax);
 
   attr.size = sizeof(struct sched_attr);
-  if (sched_setattr(thread_id.raw(), &attr, 0) == -1) {
+  if (sched_setattr(thread_id, &attr, 0) == -1) {
     // We log it as an error because, if the PathExists above succeeded, we
     // expect this syscall to also work since the kernel is new'ish.
     PLOG_IF(ERROR, errno != E2BIG)
@@ -239,8 +238,7 @@ std::optional<ThreadType> GetThreadTypeForNiceValue(int nice_value) {
 std::optional<int> GetNiceValueForThreadId(PlatformThreadId thread_id) {
   // Get the current nice value of the thread_id
   errno = 0;
-  int nice_value =
-      getpriority(PRIO_PROCESS, static_cast<id_t>(thread_id.raw()));
+  int nice_value = getpriority(PRIO_PROCESS, static_cast<id_t>(thread_id));
   if (nice_value == -1 && errno != 0) {
     // The thread may disappear for any reason so ignore ESRCH.
     DVPLOG_IF(1, errno != ESRCH)
@@ -299,8 +297,8 @@ void SetThreadRTPrioFromType(ProcessId process_id,
       return;
   }
 
-  pid_t syscall_tid =
-      thread_id == PlatformThread::CurrentId() ? 0 : thread_id.raw();
+  PlatformThreadId syscall_tid =
+      thread_id == PlatformThread::CurrentId() ? 0 : thread_id;
   if (sched_setscheduler(syscall_tid, policy, &prio) != 0) {
     DVPLOG(1) << "Failed to set policy/priority for thread " << thread_id;
   }
@@ -309,8 +307,8 @@ void SetThreadRTPrioFromType(ProcessId process_id,
 void SetThreadNiceFromType(ProcessId process_id,
                            PlatformThreadId thread_id,
                            ThreadType thread_type) {
-  pid_t syscall_tid =
-      thread_id == PlatformThread::CurrentId() ? 0 : thread_id.raw();
+  PlatformThreadId syscall_tid =
+      thread_id == PlatformThread::CurrentId() ? 0 : thread_id;
   const int nice_setting = internal::ThreadTypeToNiceValue(thread_type);
   if (setpriority(PRIO_PROCESS, static_cast<id_t>(syscall_tid), nice_setting)) {
     DVPLOG(1) << "Failed to set nice value of thread " << thread_id << " to "
diff --git a/base/threading/platform_thread_linux.cc b/base/threading/platform_thread_linux.cc
index a91ebbdabc..e624ed7a4d 100644
--- a/base/threading/platform_thread_linux.cc
+++ b/base/threading/platform_thread_linux.cc
@@ -66,7 +66,7 @@ FilePath ThreadTypeToCgroupDirectory(const FilePath& cgroup_filepath,
 void SetThreadCgroup(PlatformThreadId thread_id,
                      const FilePath& cgroup_directory) {
   FilePath tasks_filepath = cgroup_directory.Append(FILE_PATH_LITERAL("tasks"));
-  std::string tid = NumberToString(thread_id.raw());
+  std::string tid = NumberToString(thread_id);
   if (!WriteFile(tasks_filepath, as_byte_span(tid))) {
     DVLOG(1) << "Failed to add " << tid << " to " << tasks_filepath.value();
   }
@@ -180,7 +180,7 @@ bool PlatformThreadLinux::IsThreadBackgroundedForTest(
   FilePath non_urgent_tasks_filepath =
       non_urgent_cgroup_directory.Append(FILE_PATH_LITERAL("tasks"));
 
-  std::string tid = NumberToString(thread_id.raw());
+  std::string tid = NumberToString(thread_id);
   // Check if thread_id is in the urgent cpuset
   std::string urgent_tasks;
   if (!ReadFileToString(urgent_tasks_filepath, &urgent_tasks)) {
@@ -209,7 +209,7 @@ void PlatformThreadBase::SetName(const std::string& name) {
   // the process name for the LWP.  We don't want to do this for the main
   // thread because that would rename the process, causing tools like killall
   // to stop working.
-  if (PlatformThread::CurrentId().raw() == getpid()) {
+  if (PlatformThread::CurrentId() == getpid()) {
     return;
   }
 
@@ -267,11 +267,11 @@ void SetThreadTypeLinux(ProcessId process_id,
   // global TID.
   PlatformThreadId syscall_tid = thread_id;
   if (thread_id == PlatformThreadLinux::CurrentId()) {
-    syscall_tid = kInvalidThreadId;
+    syscall_tid = 0;
   }
 
   if (thread_type == ThreadType::kRealtimeAudio) {
-    if (sched_setscheduler(syscall_tid.raw(), SCHED_RR,
+    if (sched_setscheduler(syscall_tid, SCHED_RR,
                            &PlatformThreadLinux::kRealTimeAudioPrio) == 0) {
       return;
     }
@@ -280,8 +280,7 @@ void SetThreadTypeLinux(ProcessId process_id,
   }
 
   const int nice_setting = ThreadTypeToNiceValue(thread_type);
-  if (setpriority(PRIO_PROCESS, static_cast<id_t>(syscall_tid.raw()),
-                  nice_setting)) {
+  if (setpriority(PRIO_PROCESS, static_cast<id_t>(syscall_tid), nice_setting)) {
     DVPLOG(1) << "Failed to set nice value of thread (" << thread_id << ") to "
               << nice_setting;
   }
diff --git a/base/threading/platform_thread_posix.cc b/base/threading/platform_thread_posix.cc
index f5ea6363d0..b7a69e55da 100644
--- a/base/threading/platform_thread_posix.cc
+++ b/base/threading/platform_thread_posix.cc
@@ -218,7 +218,7 @@ PlatformThreadId PlatformThreadBase::CurrentId() {
   // Pthreads doesn't have the concept of a thread ID, so we have to reach down
   // into the kernel.
 #if BUILDFLAG(IS_APPLE)
-  return PlatformThreadId(pthread_mach_thread_np(pthread_self()));
+  return pthread_mach_thread_np(pthread_self());
 #elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
   // Workaround false-positive MSAN use-of-uninitialized-value on
   // thread_local storage for loaded libraries:
@@ -249,29 +249,29 @@ PlatformThreadId PlatformThreadBase::CurrentId() {
     }
 #endif
   }
-  return PlatformThreadId(g_thread_id);
+  return g_thread_id;
 #elif BUILDFLAG(IS_ANDROID)
   // Note: do not cache the return value inside a thread_local variable on
   // Android (as above). The reasons are:
   // - thread_local is slow on Android (goes through emutls)
   // - gettid() is fast, since its return value is cached in pthread (in the
   //   thread control block of pthread). See gettid.c in bionic.
-  return PlatformThreadId(gettid());
+  return gettid();
 #elif BUILDFLAG(IS_FUCHSIA)
   thread_local static zx_koid_t id =
       GetKoid(*zx::thread::self()).value_or(ZX_KOID_INVALID);
-  return PlatformThreadId(id);
+  return id;
 #elif BUILDFLAG(IS_SOLARIS) || BUILDFLAG(IS_QNX)
-  return PlatformThreadId(pthread_self());
+  return pthread_self();
 #elif BUILDFLAG(IS_NACL) && defined(__GLIBC__)
-  return PlatformThreadId(pthread_self());
+  return pthread_self();
 #elif BUILDFLAG(IS_NACL) && !defined(__GLIBC__)
   // Pointers are 32-bits in NaCl.
-  return PlatformThreadId(reinterpret_cast<int32_t>(pthread_self()));
+  return reinterpret_cast<int32_t>(pthread_self());
 #elif BUILDFLAG(IS_POSIX) && BUILDFLAG(IS_AIX)
-  return PlatformThreadId(pthread_self());
+  return pthread_self();
 #elif BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_AIX)
-  return PlatformThreadId(reinterpret_cast<int64_t>(pthread_self()));
+  return reinterpret_cast<int64_t>(pthread_self());
 #endif
 }
 
diff --git a/base/threading/platform_thread_unittest.cc b/base/threading/platform_thread_unittest.cc
index b0c53a7efa..828b2017f1 100644
--- a/base/threading/platform_thread_unittest.cc
+++ b/base/threading/platform_thread_unittest.cc
@@ -629,7 +629,7 @@ INSTANTIATE_TEST_SUITE_P(
 namespace {
 
 bool IsTidCacheCorrect() {
-  return PlatformThread::CurrentId().raw() == syscall(__NR_gettid);
+  return PlatformThread::CurrentId() == syscall(__NR_gettid);
 }
 
 void* CheckTidCacheCorrectWrapper(void*) {
diff --git a/base/threading/thread_collision_warner.h b/base/threading/thread_collision_warner.h
index f073fe3d3e..ee3f53cf07 100644
--- a/base/threading/thread_collision_warner.h
+++ b/base/threading/thread_collision_warner.h
@@ -147,7 +147,7 @@ class BASE_EXPORT ThreadCollisionWarner {
  public:
   // The parameter asserter is there only for test purpose
   explicit ThreadCollisionWarner(AsserterBase* asserter = new DCheckAsserter())
-      : valid_thread_id_(kInvalidThreadId), counter_(0), asserter_(asserter) {}
+      : valid_thread_id_(0), counter_(0), asserter_(asserter) {}
 
   ThreadCollisionWarner(const ThreadCollisionWarner&) = delete;
   ThreadCollisionWarner& operator=(const ThreadCollisionWarner&) = delete;
diff --git a/base/trace_event/trace_event_impl.cc b/base/trace_event/trace_event_impl.cc
index 828c62d531..e86c41c74d 100644
--- a/base/trace_event/trace_event_impl.cc
+++ b/base/trace_event/trace_event_impl.cc
@@ -36,7 +36,7 @@ namespace legacy {
 
 template <>
 perfetto::ThreadTrack ConvertThreadId(const ::base::PlatformThreadId& thread) {
-  return perfetto::ThreadTrack::ForThread(thread.raw());
+  return perfetto::ThreadTrack::ForThread(thread);
 }
 
 }  // namespace legacy
@@ -159,11 +159,11 @@ void TraceEvent::AppendAsJSON(
     const ArgumentFilterPredicate& argument_filter_predicate) const {
   int64_t time_int64 = timestamp_.ToInternalValue();
   ProcessId process_id;
-  std::optional<PlatformThreadId> thread_id;
+  PlatformThreadId thread_id;
   if ((flags_ & TRACE_EVENT_FLAG_HAS_PROCESS_ID) &&
       process_id_ != kNullProcessId) {
     process_id = process_id_;
-    thread_id = std::nullopt;
+    thread_id = static_cast<PlatformThreadId>(-1);
   } else {
     process_id = TraceLog::GetInstance()->process_id();
     thread_id = thread_id_;
@@ -171,26 +171,13 @@ void TraceEvent::AppendAsJSON(
   const char* category_group_name =
       TraceLog::GetCategoryGroupName(category_group_enabled_);
 
-  // The thread id might be an int64, however int64 values are not
-  // representable in JS and JSON (cf. crbug.com/40228085) since JS
-  // numbers are float64. Since thread IDs are likely to be allocated
-  // sequentially, truncation of the high bits is preferable to loss of
-  // precision in the low bits, as threads are more likely to differ in
-  // their low bit values, so we truncate the value to int32. Since this
-  // is only used for legacy JSON trace events, the loss of information
-  // is not catastrophic and won't affect normal browser execution, nor
-  // tracing with perfetto protobufs. In the worst case, the trace events
-  // will show up on a different thread track when displayed in a trace UI.
-  int thread_id_for_json =
-      thread_id ? thread_id->truncate_to_int32_for_display_only() : -1;
-
   // Category group checked at category creation time.
   DCHECK(!strchr(name_, '"'));
   StringAppendF(out,
                 "{\"pid\":%i,\"tid\":%i,\"ts\":%" PRId64
                 ",\"ph\":\"%c\",\"cat\":\"%s\",\"name\":",
-                static_cast<int>(process_id), thread_id_for_json, time_int64,
-                phase_, category_group_name);
+                static_cast<int>(process_id), static_cast<int>(thread_id),
+                time_int64, phase_, category_group_name);
   EscapeJSONString(name_, true, out);
   *out += ",\"args\":";
 
diff --git a/base/trace_event/trace_event_impl.h b/base/trace_event/trace_event_impl.h
index 64d705906d..892847d58f 100644
--- a/base/trace_event/trace_event_impl.h
+++ b/base/trace_event/trace_event_impl.h
@@ -158,7 +158,7 @@ class BASE_EXPORT TraceEvent {
   //  tid: thread_id_, pid: current_process_id (default case).
   //  tid: -1, pid: process_id_ (when flags_ & TRACE_EVENT_FLAG_HAS_PROCESS_ID).
   union {
-    PlatformThreadId thread_id_ = kInvalidThreadId;
+    PlatformThreadId thread_id_ = 0;
     ProcessId process_id_;
   };
   unsigned int flags_ = 0;
diff --git a/base/trace_event/trace_log.cc b/base/trace_event/trace_log.cc
index faff6ee791..82cc36dcf0 100644
--- a/base/trace_event/trace_log.cc
+++ b/base/trace_event/trace_log.cc
@@ -198,12 +198,12 @@ void OnAddLegacyTraceEvent(TraceEvent* trace_event) {
         break;
     }
   }
-  if (trace_event->thread_id() != kInvalidThreadId &&
+  if (trace_event->thread_id() &&
       trace_event->thread_id() != base::PlatformThread::CurrentId()) {
     PERFETTO_INTERNAL_LEGACY_EVENT_ON_TRACK(
         phase, category, trace_event->name(),
-        perfetto::ThreadTrack::ForThread(trace_event->thread_id().raw()),
-        timestamp, write_args);
+        perfetto::ThreadTrack::ForThread(trace_event->thread_id()), timestamp,
+        write_args);
     return;
   }
   PERFETTO_INTERNAL_LEGACY_EVENT_ON_TRACK(
@@ -224,11 +224,10 @@ void OnUpdateLegacyTraceEventDuration(
   auto phase = TRACE_EVENT_PHASE_END;
   base::TimeTicks timestamp =
       explicit_timestamps ? now : TRACE_TIME_TICKS_NOW();
-  if (thread_id != kInvalidThreadId &&
-      thread_id != base::PlatformThread::CurrentId()) {
+  if (thread_id && thread_id != base::PlatformThread::CurrentId()) {
     PERFETTO_INTERNAL_LEGACY_EVENT_ON_TRACK(
-        phase, category, name,
-        perfetto::ThreadTrack::ForThread(thread_id.raw()), timestamp);
+        phase, category, name, perfetto::ThreadTrack::ForThread(thread_id),
+        timestamp);
     return;
   }
   PERFETTO_INTERNAL_LEGACY_EVENT_ON_TRACK(
@@ -883,15 +882,12 @@ base::trace_event::TraceEventHandle AddTraceEventWithProcessId(
     base::ProcessId process_id,
     base::trace_event::TraceArguments* args,
     unsigned int flags) {
-  static_assert(sizeof(base::PlatformThreadId::UnderlyingType) >=
-                sizeof(base::ProcessId));
   base::TimeTicks now = TRACE_TIME_TICKS_NOW();
   return AddTraceEventWithThreadIdAndTimestamp(
       phase, category_group_enabled, name, scope, id,
       trace_event_internal::kNoId,  // bind_id
-      base::PlatformThreadId(
-          static_cast<base::PlatformThreadId::UnderlyingType>(process_id)),
-      now, args, flags | TRACE_EVENT_FLAG_HAS_PROCESS_ID);
+      static_cast<base::PlatformThreadId>(process_id), now, args,
+      flags | TRACE_EVENT_FLAG_HAS_PROCESS_ID);
 }
 
 base::trace_event::TraceEventHandle AddTraceEventWithThreadIdAndTimestamp(
diff --git a/base/tracing/perfetto_platform.cc b/base/tracing/perfetto_platform.cc
index 98290340bc..513edb7e01 100644
--- a/base/tracing/perfetto_platform.cc
+++ b/base/tracing/perfetto_platform.cc
@@ -90,8 +90,7 @@ std::string PerfettoPlatform::GetCurrentProcessName() {
 }
 
 perfetto::base::PlatformThreadId PerfettoPlatform::GetCurrentThreadId() {
-  return base::strict_cast<perfetto::base::PlatformThreadId>(
-      base::PlatformThread::CurrentId().raw());
+  return base::PlatformThread::CurrentId();
 }
 
 }  // namespace base::tracing
-- 
2.48.1.601.g30ceb7b040-goog

