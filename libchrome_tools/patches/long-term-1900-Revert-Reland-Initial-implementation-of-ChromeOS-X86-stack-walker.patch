From a43b1293dc6cfc7be20252fad7ed51661f07e90c Mon Sep 17 00:00:00 2001
From: Grace Cham <hscham@chromium.org>
Date: Mon, 26 Sep 2022 16:05:08 +0900
Subject: [PATCH] Revert "Reland "Initial implementation of ChromeOS X86_64
 stack walker""

Revert of r1024559 (crrev.com/c/3763511).
Fails to build on arm and amd. Check with upstream to see if they plan
to support them in near future. Alternatively libchrome might add new
IUSE build flags to select source files.

This reverts commit c25cdd501bd8b3e8970848e56372924140215496.

patch-name: long-term-1900-Revert-Reland-Initial-implementation-of-ChromeOS-X86-stack-walker.patch
Change-Id: I8d2f17408e83ac32b3540131dfb0caff866bafb8
---
 base/profiler/chrome_unwinder_android.cc      |  3 ++
 base/profiler/native_unwinder.h               | 20 ++++++++
 base/profiler/native_unwinder_android.cc      |  3 ++
 ...r_unwinder.cc => native_unwinder_apple.cc} | 25 ++++-----
 base/profiler/native_unwinder_apple.h         | 34 +++++++++++++
 ...t.cc => native_unwinder_apple_unittest.cc} | 35 +++++--------
 base/profiler/stack_sampler_posix.cc          | 32 ------------
 .../stack_sampling_profiler_unittest.cc       | 51 +++++--------------
 8 files changed, 99 insertions(+), 104 deletions(-)
 create mode 100644 base/profiler/native_unwinder.h
 rename base/profiler/{frame_pointer_unwinder.cc => native_unwinder_apple.cc} (87%)
 create mode 100644 base/profiler/native_unwinder_apple.h
 rename base/profiler/{frame_pointer_unwinder_unittest.cc => native_unwinder_apple_unittest.cc} (93%)

diff --git a/base/profiler/chrome_unwinder_android.cc b/base/profiler/chrome_unwinder_android.cc
index a13f2d1b4e..d7869dee93 100644
--- a/base/profiler/chrome_unwinder_android.cc
+++ b/base/profiler/chrome_unwinder_android.cc
@@ -11,6 +11,9 @@
 #include "base/notreached.h"
 #include "base/numerics/checked_math.h"
 #include "base/profiler/chrome_unwind_info_android.h"
+#include "base/profiler/module_cache.h"
+#include "base/profiler/native_unwinder.h"
+#include "build/build_config.h"
 
 namespace base {
 namespace {
diff --git a/base/profiler/native_unwinder.h b/base/profiler/native_unwinder.h
new file mode 100644
index 0000000000..7edf4af830
--- /dev/null
+++ b/base/profiler/native_unwinder.h
@@ -0,0 +1,20 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_PROFILER_NATIVE_UNWINDER_H_
+#define BASE_PROFILER_NATIVE_UNWINDER_H_
+
+#include <memory>
+
+namespace base {
+
+class ModuleCache;
+class Unwinder;
+
+// Creates the native unwinder for the platform.
+std::unique_ptr<Unwinder> CreateNativeUnwinder(ModuleCache* module_cache);
+
+}  // namespace base
+
+#endif  // BASE_PROFILER_NATIVE_UNWINDER_H_
diff --git a/base/profiler/native_unwinder_android.cc b/base/profiler/native_unwinder_android.cc
index ceda24b03c..4cdabf3e03 100644
--- a/base/profiler/native_unwinder_android.cc
+++ b/base/profiler/native_unwinder_android.cc
@@ -22,6 +22,9 @@
 #include "base/profiler/native_unwinder_android_memory_regions_map_impl.h"
 #include "base/profiler/profile_builder.h"
 #include "build/build_config.h"
+#include "base/profiler/module_cache.h"
+#include "base/profiler/native_unwinder.h"
+#include "build/build_config.h"
 
 #if defined(ARCH_CPU_ARM_FAMILY) && defined(ARCH_CPU_32_BITS)
 #include "third_party/libunwindstack/src/libunwindstack/include/unwindstack/MachineArm.h"
diff --git a/base/profiler/frame_pointer_unwinder.cc b/base/profiler/native_unwinder_apple.cc
similarity index 87%
rename from base/profiler/frame_pointer_unwinder.cc
rename to base/profiler/native_unwinder_apple.cc
index 372e5eef97..cb6c56ce08 100644
--- a/base/profiler/frame_pointer_unwinder.cc
+++ b/base/profiler/native_unwinder_apple.cc
@@ -2,19 +2,18 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/profiler/frame_pointer_unwinder.h"
+#include "base/profiler/native_unwinder_apple.h"
+
+#include <pthread/stack_np.h>
 
 #include "base/check_op.h"
 #include "base/compiler_specific.h"
 #include "base/notreached.h"
 #include "base/numerics/clamped_math.h"
 #include "base/profiler/module_cache.h"
+#include "base/profiler/native_unwinder.h"
 #include "build/build_config.h"
 
-#if BUILDFLAG(IS_APPLE)
-#include <pthread/stack_np.h>
-#endif
-
 namespace {
 
 // Given a frame pointer, returns the frame pointer of the calling stack
@@ -24,11 +23,9 @@ namespace {
 // NB: The caller *must* ensure that there are 2+ uintptr_t's worth of memory at
 // `frame_pointer`.
 uintptr_t DecodeFrame(uintptr_t frame_pointer, uintptr_t* return_address) {
-#if BUILDFLAG(IS_APPLE)
   if (__builtin_available(iOS 12, *)) {
     return pthread_stack_frame_decode_np(frame_pointer, return_address);
   }
-#endif
   const uintptr_t* fp = reinterpret_cast<uintptr_t*>(frame_pointer);
 
   // MSAN does not consider the frame pointers and return addresses to have
@@ -45,15 +42,15 @@ uintptr_t DecodeFrame(uintptr_t frame_pointer, uintptr_t* return_address) {
 
 namespace base {
 
-FramePointerUnwinder::FramePointerUnwinder() = default;
+NativeUnwinderApple::NativeUnwinderApple() = default;
 
-bool FramePointerUnwinder::CanUnwindFrom(const Frame& current_frame) const {
+bool NativeUnwinderApple::CanUnwindFrom(const Frame& current_frame) const {
   return current_frame.module && current_frame.module->IsNative();
 }
 
-UnwindResult FramePointerUnwinder::TryUnwind(RegisterContext* thread_context,
-                                             uintptr_t stack_top,
-                                             std::vector<Frame>* stack) {
+UnwindResult NativeUnwinderApple::TryUnwind(RegisterContext* thread_context,
+                                            uintptr_t stack_top,
+                                            std::vector<Frame>* stack) {
   // We expect the frame corresponding to the |thread_context| register state to
   // exist within |stack|.
   DCHECK_GT(stack->size(), 0u);
@@ -112,4 +109,8 @@ UnwindResult FramePointerUnwinder::TryUnwind(RegisterContext* thread_context,
   return UnwindResult::kCompleted;
 }
 
+std::unique_ptr<Unwinder> CreateNativeUnwinder(ModuleCache* module_cache) {
+  return std::make_unique<NativeUnwinderApple>();
+}
+
 }  // namespace base
diff --git a/base/profiler/native_unwinder_apple.h b/base/profiler/native_unwinder_apple.h
new file mode 100644
index 0000000000..1ca049e6eb
--- /dev/null
+++ b/base/profiler/native_unwinder_apple.h
@@ -0,0 +1,34 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_PROFILER_NATIVE_UNWINDER_APPLE_H_
+#define BASE_PROFILER_NATIVE_UNWINDER_APPLE_H_
+
+#include <vector>
+
+#include <os/availability.h>
+
+#include "base/base_export.h"
+#include "base/profiler/unwinder.h"
+
+namespace base {
+
+// Native unwinder implementation for iOS, ARM64 and X86_64, and macOS 10.14+.
+class BASE_EXPORT API_AVAILABLE(ios(12)) NativeUnwinderApple : public Unwinder {
+ public:
+  NativeUnwinderApple();
+
+  NativeUnwinderApple(const NativeUnwinderApple&) = delete;
+  NativeUnwinderApple& operator=(const NativeUnwinderApple&) = delete;
+
+  // Unwinder:
+  bool CanUnwindFrom(const Frame& current_frame) const override;
+  UnwindResult TryUnwind(RegisterContext* thread_context,
+                         uintptr_t stack_top,
+                         std::vector<Frame>* stack) const override;
+};
+
+}  // namespace base
+
+#endif  // BASE_PROFILER_NATIVE_UNWINDER_APPLE_H_
diff --git a/base/profiler/frame_pointer_unwinder_unittest.cc b/base/profiler/native_unwinder_apple_unittest.cc
similarity index 93%
rename from base/profiler/frame_pointer_unwinder_unittest.cc
rename to base/profiler/native_unwinder_apple_unittest.cc
index 3fd8834b4d..44e94f2a59 100644
--- a/base/profiler/frame_pointer_unwinder_unittest.cc
+++ b/base/profiler/native_unwinder_apple_unittest.cc
@@ -2,19 +2,16 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/profiler/frame_pointer_unwinder.h"
-
-#include <memory>
+#include "base/profiler/native_unwinder_apple.h"
 
+#include "base/mac/mac_util.h"
 #include "base/profiler/module_cache.h"
 #include "base/profiler/stack_sampling_profiler_test_util.h"
 #include "base/profiler/unwinder.h"
 #include "build/buildflag.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-#if BUILDFLAG(IS_APPLE)
-#include "base/mac/mac_util.h"
-#endif
+#include <memory>
 
 namespace base {
 
@@ -60,15 +57,11 @@ struct InputStack {
 
 }  // namespace
 
-class FramePointerUnwinderTest : public testing::Test {
+class NativeUnwinderAppleTest : public testing::Test {
  protected:
-  FramePointerUnwinderTest() {
-#if BUILDFLAG(IS_APPLE)
+  NativeUnwinderAppleTest() {
     if (__builtin_available(iOS 12, *)) {
-#else
-    {
-#endif
-      unwinder_ = std::make_unique<FramePointerUnwinder>();
+      unwinder_ = std::make_unique<NativeUnwinderApple>();
 
       auto test_module =
           std::make_unique<TestModule>(kModuleStart, kModuleSize);
@@ -97,7 +90,7 @@ class FramePointerUnwinderTest : public testing::Test {
   raw_ptr<ModuleCache::Module> non_native_module_;
 };
 
-TEST_F(FramePointerUnwinderTest, FPPointsOutsideOfStack) {
+TEST_F(NativeUnwinderAppleTest, FPPointsOutsideOfStack) {
   InputStack input({
       {false, 0x1000},
       {false, 0x1000},
@@ -128,7 +121,7 @@ TEST_F(FramePointerUnwinderTest, FPPointsOutsideOfStack) {
   EXPECT_EQ(std::vector<Frame>({{kModuleStart, module()}}), stack);
 }
 
-TEST_F(FramePointerUnwinderTest, FPPointsToSelf) {
+TEST_F(NativeUnwinderAppleTest, FPPointsToSelf) {
   InputStack input({
       {true, 0},
       {false, kModuleStart + 0x10},
@@ -155,7 +148,7 @@ TEST_F(FramePointerUnwinderTest, FPPointsToSelf) {
 
 // Tests that two frame pointers that point to each other can't create an
 // infinite loop
-TEST_F(FramePointerUnwinderTest, FPCycle) {
+TEST_F(NativeUnwinderAppleTest, FPCycle) {
   InputStack input({
       {true, 2},
       {false, kModuleStart + 0x10},
@@ -183,7 +176,7 @@ TEST_F(FramePointerUnwinderTest, FPCycle) {
             stack);
 }
 
-TEST_F(FramePointerUnwinderTest, NoModuleForIP) {
+TEST_F(NativeUnwinderAppleTest, NoModuleForIP) {
   uintptr_t not_in_module = kModuleStart - 0x10;
   InputStack input({
       {true, 2},
@@ -210,7 +203,7 @@ TEST_F(FramePointerUnwinderTest, NoModuleForIP) {
 
 // Tests that testing that checking if there's space to read two values from the
 // stack doesn't overflow.
-TEST_F(FramePointerUnwinderTest, FPAdditionOverflows) {
+TEST_F(NativeUnwinderAppleTest, FPAdditionOverflows) {
   uintptr_t will_overflow = std::numeric_limits<uintptr_t>::max() - 1;
   InputStack input({
       {true, 2},
@@ -235,7 +228,7 @@ TEST_F(FramePointerUnwinderTest, FPAdditionOverflows) {
 }
 
 // Tests the happy path: a successful unwind with no non-native modules.
-TEST_F(FramePointerUnwinderTest, RegularUnwind) {
+TEST_F(NativeUnwinderAppleTest, RegularUnwind) {
   InputStack input({
       {true, 4},                     // fp of frame 1
       {false, kModuleStart + 0x20},  // ip of frame 1
@@ -268,7 +261,7 @@ TEST_F(FramePointerUnwinderTest, RegularUnwind) {
 
 // Tests that if a V8 frame is encountered, unwinding stops and
 // kUnrecognizedFrame is returned to facilitate continuing with the V8 unwinder.
-TEST_F(FramePointerUnwinderTest, NonNativeFrame) {
+TEST_F(NativeUnwinderAppleTest, NonNativeFrame) {
   InputStack input({
       {true, 4},                     // fp of frame 1
       {false, kModuleStart + 0x20},  // ip of frame 1
@@ -305,7 +298,7 @@ TEST_F(FramePointerUnwinderTest, NonNativeFrame) {
 
 // Tests that a V8 frame with an unaligned frame pointer correctly returns
 // kUnrecognizedFrame and not kAborted.
-TEST_F(FramePointerUnwinderTest, NonNativeUnaligned) {
+TEST_F(NativeUnwinderAppleTest, NonNativeUnaligned) {
   InputStack input({
       {true, 4},                     // fp of frame 1
       {false, kModuleStart + 0x20},  // ip of frame 1
diff --git a/base/profiler/stack_sampler_posix.cc b/base/profiler/stack_sampler_posix.cc
index 2df66efa3b..6a0e626798 100644
--- a/base/profiler/stack_sampler_posix.cc
+++ b/base/profiler/stack_sampler_posix.cc
@@ -6,51 +6,19 @@
 
 #include <pthread.h>
 
-#include <memory>
-
 #include "base/memory/ptr_util.h"
 #include "base/threading/platform_thread.h"
 #include "build/build_config.h"
 
-#if BUILDFLAG(IS_CHROMEOS) && defined(ARCH_CPU_X86_64)
-#include "base/check.h"
-#include "base/functional/bind.h"
-#include "base/profiler/frame_pointer_unwinder.h"
-#include "base/profiler/stack_copier_signal.h"
-#include "base/profiler/thread_delegate_posix.h"
-#include "base/profiler/unwinder.h"
-#endif
-
 namespace base {
 
-namespace {
-
-#if BUILDFLAG(IS_CHROMEOS) && defined(ARCH_CPU_X86_64)
-std::vector<std::unique_ptr<Unwinder>> CreateUnwinders() {
-  std::vector<std::unique_ptr<Unwinder>> unwinders;
-  unwinders.push_back(std::make_unique<FramePointerUnwinder>());
-  return unwinders;
-}
-#endif
-
-}  // namespace
-
 std::unique_ptr<StackSampler> StackSampler::Create(
     SamplingProfilerThreadToken thread_token,
     ModuleCache* module_cache,
     UnwindersFactory core_unwinders_factory,
     RepeatingClosure record_sample_callback,
     StackSamplerTestDelegate* test_delegate) {
-#if BUILDFLAG(IS_CHROMEOS) && defined(ARCH_CPU_X86_64)
-  DCHECK(!core_unwinders_factory);
-  return base::WrapUnique(
-      new StackSampler(std::make_unique<StackCopierSignal>(
-                           ThreadDelegatePosix::Create(thread_token)),
-                       BindOnce(&CreateUnwinders), module_cache,
-                       std::move(record_sample_callback), test_delegate));
-#else
   return nullptr;
-#endif
 }
 
 size_t StackSampler::GetStackBufferSize() {
diff --git a/base/profiler/stack_sampling_profiler_unittest.cc b/base/profiler/stack_sampling_profiler_unittest.cc
index 10556682a6..93d8ed06e2 100644
--- a/base/profiler/stack_sampling_profiler_unittest.cc
+++ b/base/profiler/stack_sampling_profiler_unittest.cc
@@ -46,16 +46,11 @@
 #endif
 
 // STACK_SAMPLING_PROFILER_SUPPORTED is used to conditionally enable the tests
-// below for supported platforms (currently Win x64, Mac x64, iOS 64, some
-// Android, and ChromeOS x64).
-// ChromeOS: These don't run under MSan because parts of the stack aren't
-// initialized.
-#if (BUILDFLAG(IS_WIN) && defined(ARCH_CPU_X86_64)) ||            \
-    (BUILDFLAG(IS_MAC) && defined(ARCH_CPU_X86_64)) ||            \
-    (BUILDFLAG(IS_IOS) && defined(ARCH_CPU_64_BITS)) ||           \
-    (BUILDFLAG(IS_ANDROID) && BUILDFLAG(ENABLE_ARM_CFI_TABLE)) || \
-    (BUILDFLAG(IS_CHROMEOS) && defined(ARCH_CPU_X86_64) &&        \
-     !defined(MEMORY_SANITIZER))
+// below for supported platforms (currently Win x64, Mac x64 and iOS 64).
+#if (BUILDFLAG(IS_WIN) && defined(ARCH_CPU_X86_64)) ||  \
+    (BUILDFLAG(IS_MAC) && defined(ARCH_CPU_X86_64)) ||  \
+    (BUILDFLAG(IS_IOS) && defined(ARCH_CPU_64_BITS)) || \
+    (BUILDFLAG(IS_ANDROID) && BUILDFLAG(ENABLE_ARM_CFI_TABLE))
 #define STACK_SAMPLING_PROFILER_SUPPORTED 1
 #endif
 
@@ -207,7 +202,7 @@ void SynchronousUnloadNativeLibrary(NativeLibrary library) {
          ::GetLastError() != ERROR_MOD_NOT_FOUND) {
     PlatformThread::Sleep(Milliseconds(1));
   }
-#elif BUILDFLAG(IS_APPLE) || BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_CHROMEOS)
+#elif BUILDFLAG(IS_APPLE) || BUILDFLAG(IS_ANDROID)
 // Unloading a library on Mac and Android is synchronous.
 #else
   NOTIMPLEMENTED();
@@ -450,13 +445,8 @@ class StackSamplingProfilerTest : public testing::Test {
 //
 // TODO(https://crbug.com/1100175): Enable this test again for Android with
 // ASAN. This is now disabled because the android-asan bot fails.
-//
-// If we're running the ChromeOS unit tests on Linux, this test will never pass
-// because Ubuntu's libc isn't compiled with frame pointers. Skip if not a real
-// ChromeOS device.
-#if (defined(ADDRESS_SANITIZER) && BUILDFLAG(IS_APPLE)) ||   \
-    (defined(ADDRESS_SANITIZER) && BUILDFLAG(IS_ANDROID)) || \
-    (BUILDFLAG(IS_CHROMEOS) && !BUILDFLAG(IS_CHROMEOS_DEVICE))
+#if (defined(ADDRESS_SANITIZER) && BUILDFLAG(IS_APPLE)) || \
+    (defined(ADDRESS_SANITIZER) && BUILDFLAG(IS_ANDROID))
 #define MAYBE_Basic DISABLED_Basic
 #else
 #define MAYBE_Basic Basic
@@ -510,12 +500,7 @@ class TestAuxUnwinder : public Unwinder {
 // macOS ASAN is not yet supported - crbug.com/718628.
 // Android is not supported since Chrome unwind tables don't support dynamic
 // frames.
-// If we're running the ChromeOS unit tests on Linux, this test will never pass
-// because Ubuntu's libc isn't compiled with frame pointers. Skip if not a real
-// ChromeOS device.
-#if (defined(ADDRESS_SANITIZER) && BUILDFLAG(IS_APPLE)) || \
-    BUILDFLAG(IS_ANDROID) ||                               \
-    (BUILDFLAG(IS_CHROMEOS) && !BUILDFLAG(IS_CHROMEOS_DEVICE))
+#if (defined(ADDRESS_SANITIZER) && BUILDFLAG(IS_APPLE)) || BUILDFLAG(IS_ANDROID)
 #define MAYBE_Alloca DISABLED_Alloca
 #else
 #define MAYBE_Alloca Alloca
@@ -538,14 +523,10 @@ PROFILER_TEST_F(StackSamplingProfilerTest, MAYBE_Alloca) {
 // have unwind tables.
 // TODO(https://crbug.com/1100175): Enable this test again for Android with
 // ASAN. This is now disabled because the android-asan bot fails.
-// If we're running the ChromeOS unit tests on Linux, this test will never pass
-// because Ubuntu's libc isn't compiled with frame pointers. Skip if not a real
-// ChromeOS device.
 #if (defined(ADDRESS_SANITIZER) && BUILDFLAG(IS_APPLE)) ||         \
     BUILDFLAG(IS_IOS) ||                                           \
     (BUILDFLAG(IS_ANDROID) && BUILDFLAG(EXCLUDE_UNWIND_TABLES)) || \
-    (BUILDFLAG(IS_ANDROID) && defined(ADDRESS_SANITIZER)) ||       \
-    (BUILDFLAG(IS_CHROMEOS) && !BUILDFLAG(IS_CHROMEOS_DEVICE))
+    (BUILDFLAG(IS_ANDROID) && defined(ADDRESS_SANITIZER))
 #define MAYBE_OtherLibrary DISABLED_OtherLibrary
 #else
 #define MAYBE_OtherLibrary OtherLibrary
@@ -569,13 +550,9 @@ PROFILER_TEST_F(StackSamplingProfilerTest, MAYBE_OtherLibrary) {
 // have unwind tables.
 // TODO(https://crbug.com/1100175): Enable this test again for Android with
 // ASAN. This is now disabled because the android-asan bot fails.
-// If we're running the ChromeOS unit tests on Linux, this test will never pass
-// because Ubuntu's libc isn't compiled with frame pointers. Skip if not a real
-// ChromeOS device.
 #if BUILDFLAG(IS_APPLE) ||                                         \
     (BUILDFLAG(IS_ANDROID) && BUILDFLAG(EXCLUDE_UNWIND_TABLES)) || \
-    (BUILDFLAG(IS_ANDROID) && defined(ADDRESS_SANITIZER)) ||       \
-    (BUILDFLAG(IS_CHROMEOS) && !BUILDFLAG(IS_CHROMEOS_DEVICE))
+    (BUILDFLAG(IS_ANDROID) && defined(ADDRESS_SANITIZER))
 #define MAYBE_UnloadingLibrary DISABLED_UnloadingLibrary
 #else
 #define MAYBE_UnloadingLibrary UnloadingLibrary
@@ -588,12 +565,8 @@ PROFILER_TEST_F(StackSamplingProfilerTest, MAYBE_UnloadingLibrary) {
 // produces a stack, and doesn't crash.
 // macOS ASAN is not yet supported - crbug.com/718628.
 // Android is not supported since modules are found before unwinding.
-// If we're running the ChromeOS unit tests on Linux, this test will never pass
-// because Ubuntu's libc isn't compiled with frame pointers. Skip if not a real
-// ChromeOS device.
 #if (defined(ADDRESS_SANITIZER) && BUILDFLAG(IS_APPLE)) || \
-    BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_IOS) ||          \
-    (BUILDFLAG(IS_CHROMEOS) && !BUILDFLAG(IS_CHROMEOS_DEVICE))
+    BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_IOS)
 #define MAYBE_UnloadedLibrary DISABLED_UnloadedLibrary
 #else
 #define MAYBE_UnloadedLibrary UnloadedLibrary
-- 
2.43.0.472.g3155946c3a-goog

