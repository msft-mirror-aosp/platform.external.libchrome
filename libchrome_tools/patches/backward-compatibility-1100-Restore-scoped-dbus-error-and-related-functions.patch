From 7dd08078a3bdcd0d20577a811a4ba87aaa696a0d Mon Sep 17 00:00:00 2001
From: Georg Neis <neis@chromium.org>
Date: Wed, 19 Jul 2023 01:05:46 +0000
Subject: [PATCH] Restore dbus::ScopedDBusError and related functions

Change-Id: Id6c01566e83e5b0ea7cff744dee1c6b405944a1c
---
 dbus/bus.cc               | 36 ++++++++++++++++++++++++++++++++++++
 dbus/bus.h                |  6 ++++++
 dbus/mock_bus.h           |  3 +++
 dbus/mock_object_proxy.h  |  4 ++++
 dbus/object_proxy.cc      | 14 ++++++++++++++
 dbus/object_proxy.h       |  5 +++++
 dbus/scoped_dbus_error.cc |  4 ++--
 dbus/scoped_dbus_error.h  | 12 +++++++++---
 8 files changed, 79 insertions(+), 5 deletions(-)

diff --git a/dbus/bus.cc b/dbus/bus.cc
index 2f24e01d4a..a9b2dcccb3 100644
--- a/dbus/bus.cc
+++ b/dbus/bus.cc
@@ -664,6 +664,23 @@ base::expected<std::unique_ptr<Response>, Error> Bus::SendWithReplyAndBlock(
   return base::ok(Response::FromRawMessage(reply));
 }
 
+DBusMessage* Bus::SendWithReplyAndBlock(DBusMessage* request,
+                                        int timeout_ms,
+                                        DBusError* error) {
+  base::expected<std::unique_ptr<Response>, Error> result =
+      SendWithReplyAndBlock(request, timeout_ms);
+  if (!result.has_value()) {
+    Error e = std::move(result.error());
+    CHECK(e.IsValid());
+    if (error) {
+      dbus_error_init(error);
+      dbus_set_error(error, e.name().c_str(), "%s", e.message().c_str());
+    }
+    return nullptr;
+  }
+  return result.value()->raw_message();
+}
+
 void Bus::SendWithReply(DBusMessage* request,
                         DBusPendingCall** pending_call,
                         int timeout_ms) {
@@ -755,6 +772,15 @@ void Bus::AddMatch(const std::string& match_rule, Error* error) {
   match_rules_added_[match_rule] = 1;
 }
 
+void Bus::AddMatch(const std::string& match_rule, DBusError* error) {
+  Error e;
+  AddMatch(match_rule, &e);
+  if (error && e.IsValid()) {
+    dbus_error_init(error);
+    dbus_set_error(error, e.name().c_str(), "%s", e.message().c_str());
+  }
+}
+
 bool Bus::RemoveMatch(const std::string& match_rule, Error* error) {
   DCHECK(connection_);
   DCHECK(error);
@@ -782,6 +808,16 @@ bool Bus::RemoveMatch(const std::string& match_rule, Error* error) {
   return true;
 }
 
+bool Bus::RemoveMatch(const std::string& match_rule, DBusError* error) {
+  Error e;
+  bool result = RemoveMatch(match_rule, &e);
+  if (error && e.IsValid()) {
+    dbus_error_init(error);
+    dbus_set_error(error, e.name().c_str(), "%s", e.message().c_str());
+  }
+  return result;
+}
+
 bool Bus::TryRegisterObjectPath(const ObjectPath& object_path,
                                 const DBusObjectPathVTable* vtable,
                                 void* user_data,
diff --git a/dbus/bus.h b/dbus/bus.h
index 539a02f67a..78ca4aa691 100644
--- a/dbus/bus.h
+++ b/dbus/bus.h
@@ -454,6 +454,10 @@ class CHROME_DBUS_EXPORT Bus : public base::RefCountedThreadSafe<Bus> {
   // BLOCKING CALL.
   virtual base::expected<std::unique_ptr<Response>, Error>
   SendWithReplyAndBlock(DBusMessage* request, int timeout_ms);
+  virtual DBusMessage* SendWithReplyAndBlock(DBusMessage* request,
+                                             int timeout_ms,
+                                             DBusError* error);
+
 
   // Requests to send a message to the bus. The reply is handled with
   // |pending_call| at a later time.
@@ -512,6 +516,7 @@ class CHROME_DBUS_EXPORT Bus : public base::RefCountedThreadSafe<Bus> {
   //
   // BLOCKING CALL.
   virtual void AddMatch(const std::string& match_rule, Error* error);
+  virtual void AddMatch(const std::string& match_rule, DBusError* error);
 
   // Removes the match rule previously added by AddMatch().
   // Returns false if the requested match rule is unknown or has already been
@@ -523,6 +528,7 @@ class CHROME_DBUS_EXPORT Bus : public base::RefCountedThreadSafe<Bus> {
   //
   // BLOCKING CALL.
   virtual bool RemoveMatch(const std::string& match_rule, Error* error);
+  virtual bool RemoveMatch(const std::string& match_rule, DBusError* error);
 
   // Tries to register the object path. Returns true on success.
   // Returns false if the object path is already registered.
diff --git a/dbus/mock_bus.h b/dbus/mock_bus.h
index 55d088a54f..19030159f0 100644
--- a/dbus/mock_bus.h
+++ b/dbus/mock_bus.h
@@ -47,6 +47,9 @@ class MockBus : public Bus {
       SendWithReplyAndBlock,
       base::expected<std::unique_ptr<Response>, Error>(DBusMessage* request,
                                                        int timeout_ms));
+  MOCK_METHOD3(SendWithReplyAndBlock, DBusMessage*(DBusMessage* request,
+                                                   int timeout_ms,
+                                                   DBusError* error));
   MOCK_METHOD3(SendWithReply, void(DBusMessage* request,
                                    DBusPendingCall** pending_call,
                                    int timeout_ms));
diff --git a/dbus/mock_object_proxy.h b/dbus/mock_object_proxy.h
index 8b846dbba5..76785be140 100644
--- a/dbus/mock_object_proxy.h
+++ b/dbus/mock_object_proxy.h
@@ -26,6 +26,10 @@ class MockObjectProxy : public ObjectProxy {
                std::unique_ptr<Response>(MethodCall* method_call,
                                          int timeout_ms,
                                          Error* error));
+  MOCK_METHOD3(CallMethodAndBlockWithErrorDetails,
+               std::unique_ptr<Response>(MethodCall* method_call,
+                                         int timeout_ms,
+                                         ScopedDBusError* error));
   MOCK_METHOD2(CallMethodAndBlock,
                std::unique_ptr<Response>(MethodCall* method_call,
                                          int timeout_ms));
diff --git a/dbus/object_proxy.cc b/dbus/object_proxy.cc
index 9296cb2fd6..0281a992ab 100644
--- a/dbus/object_proxy.cc
+++ b/dbus/object_proxy.cc
@@ -154,6 +154,20 @@ std::unique_ptr<Response> ObjectProxy::CallMethodAndBlockWithErrorDetails(
   return std::move(result.value());
 }
 
+std::unique_ptr<Response> ObjectProxy::CallMethodAndBlockWithErrorDetails(
+    MethodCall* method_call,
+    int timeout_ms,
+    ScopedDBusError* scoped_error) {
+  Error error;
+  auto response = CallMethodAndBlockWithErrorDetails(method_call, timeout_ms, &error);
+  if (error.IsValid()) {
+    dbus_error_init(scoped_error->get());
+    dbus_set_error(scoped_error->get(), error.name().c_str(),
+                         "%s", error.message().c_str());
+  }
+  return response;
+}
+
 std::unique_ptr<Response> ObjectProxy::CallMethodAndBlock(
     MethodCall* method_call,
     int timeout_ms) {
diff --git a/dbus/object_proxy.h b/dbus/object_proxy.h
index d837293f0a..50d02728e2 100644
--- a/dbus/object_proxy.h
+++ b/dbus/object_proxy.h
@@ -28,6 +28,7 @@ class Error;
 class ErrorResponse;
 class MethodCall;
 class Response;
+class ScopedDBusError;
 class Signal;
 
 // ObjectProxy is used to communicate with remote objects, mainly for
@@ -113,6 +114,10 @@ class CHROME_DBUS_EXPORT ObjectProxy
       MethodCall* method_call,
       int timeout_ms,
       Error* error);
+  virtual std::unique_ptr<Response> CallMethodAndBlockWithErrorDetails(
+      MethodCall* method_call,
+      int timeout_ms,
+      ScopedDBusError* scoped_error);
 
   // Calls the method of the remote object and blocks until the response
   // is returned. Returns NULL on error.
diff --git a/dbus/scoped_dbus_error.cc b/dbus/scoped_dbus_error.cc
index e4736024ee..afd0e1d85d 100644
--- a/dbus/scoped_dbus_error.cc
+++ b/dbus/scoped_dbus_error.cc
@@ -4,7 +4,7 @@
 
 #include "dbus/scoped_dbus_error.h"
 
-namespace dbus::internal {
+namespace dbus {
 
 ScopedDBusError::ScopedDBusError() {
   dbus_error_init(&error_);
@@ -18,4 +18,4 @@ bool ScopedDBusError::is_set() const {
   return dbus_error_is_set(&error_);
 }
 
-}  // namespace dbus::internal
+}  // namespace dbus
diff --git a/dbus/scoped_dbus_error.h b/dbus/scoped_dbus_error.h
index 258bf606bd..ba418ff014 100644
--- a/dbus/scoped_dbus_error.h
+++ b/dbus/scoped_dbus_error.h
@@ -7,10 +7,12 @@
 
 #include <dbus/dbus.h>
 
-namespace dbus::internal {
+#include "dbus/dbus_export.h"
+
+namespace dbus {
 
 // Utility class to ensure that DBusError is freed.
-class ScopedDBusError {
+class CHROME_DBUS_EXPORT ScopedDBusError {
  public:
   // Do not inline methods that call dbus_error_xxx() functions.
   // See http://crbug.com/416628
@@ -26,6 +28,10 @@ class ScopedDBusError {
   DBusError error_;
 };
 
-}  // namespace dbus::internal
+namespace internal {
+using ScopedDBusError = ScopedDBusError;
+}
+
+}  // namespace dbus
 
 #endif  // DBUS_SCOPED_DBUS_ERROR_H_
-- 
2.41.0.255.g8b1d071c50-goog

