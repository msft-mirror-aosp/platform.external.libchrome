From 378fd26adbfca5b6d80df5a05aae5ff15ba12006 Mon Sep 17 00:00:00 2001
From: hscham <hscham@chromium.org>
Date: Thu, 7 Oct 2021 10:28:52 +0900
Subject: [PATCH] Revert "Mojo: explicitly use eventfd2(2)."

This reverts commit 00ee97e6e78f326d656e9e33ae087c97c1dc376e.
It introduces new use of syscall uname. Since it is more difficult to
find out all services using it and add uname to their seccomp policy
file, this is separated from the r890000 uprev and left as a post-uprev
work. Please see tracking bug b/189403036.

Change-Id: I0068a3430d11a13bbf10e83181d4850ff2dba8be
---
 mojo/core/channel_linux.cc | 24 ++++++++++++++----------
 1 file changed, 14 insertions(+), 10 deletions(-)

diff --git a/mojo/core/channel_linux.cc b/mojo/core/channel_linux.cc
index 22c391d27..a2e5be97f 100644
--- a/mojo/core/channel_linux.cc
+++ b/mojo/core/channel_linux.cc
@@ -12,6 +12,11 @@
 #include <sys/syscall.h>
 #include <sys/utsname.h>
 #include <unistd.h>
+#include <unistd.h>
+
+#if defined(OS_ANDROID)
+#include <sys/utsname.h>
+#endif
 
 #include <algorithm>
 #include <atomic>
@@ -53,6 +58,7 @@ namespace core {
 
 namespace {
 
+#if defined(OS_ANDROID)
 // On Android base::SysInfo::OperatingSystemVersionNumbers actually returns the
 // build numbers and not the kernel version as the other posix OSes would.
 void KernelVersionNumbers(int32_t* major_version,
@@ -75,6 +81,7 @@ void KernelVersionNumbers(int32_t* major_version,
   if (num_read < 3)
     *bugfix_version = 0;
 }
+#endif  // defined(OS_ANDROID)
 
 }  // namespace
 
@@ -191,14 +198,13 @@ class EventFDNotifier : public DataAvailableNotifier,
 
   static std::unique_ptr<EventFDNotifier> CreateWriteNotifier() {
     static bool zero_on_wake_supported = []() -> bool {
-      base::ScopedFD fd(
-          syscall(__NR_eventfd2, 0, kEfdFlags | EFD_ZERO_ON_WAKE));
+      base::ScopedFD fd(eventfd(0, kEfdFlags | EFD_ZERO_ON_WAKE));
       return fd.is_valid();
     }();
 
     bool use_zero_on_wake = zero_on_wake_supported && g_use_zero_on_wake;
     int extra_flags = use_zero_on_wake ? EFD_ZERO_ON_WAKE : 0;
-    int fd = syscall(__NR_eventfd2, 0, kEfdFlags | extra_flags);
+    int fd = eventfd(0, kEfdFlags | extra_flags);
     if (fd < 0) {
       PLOG(ERROR) << "Unable to create an eventfd";
       return nullptr;
@@ -226,7 +232,7 @@ class EventFDNotifier : public DataAvailableNotifier,
     // Try to create an eventfd with bad flags if we get -EINVAL it's supported
     // if we get -ENOSYS it's not, we also support -EPERM because seccomp
     // policies can cause it to be returned.
-    int ret = syscall(__NR_eventfd2, 0, ~0);
+    int ret = eventfd(0, ~0);
     PCHECK(ret < 0 && (errno == EINVAL || errno == ENOSYS || errno == EPERM));
     return (ret < 0 && errno == EINVAL);
   }
@@ -915,23 +921,21 @@ void ChannelLinux::OfferSharedMemUpgradeInternal() {
 // static
 bool ChannelLinux::KernelSupportsUpgradeRequirements() {
   static bool supported = []() -> bool {
+#if defined(OS_ANDROID)
     // See https://crbug.com/1192696 for more context, but some Android vendor
     // kernels pre-3.17 would use higher undefined syscall numbers for private
     // syscalls. To start we'll validate the kernel version is greater than or
     // equal to 3.17 before even bothering to call memfd_create.
-    //
-    // Additionally, the behavior of eventfd prior to the 4.0 kernel could be
-    // racy.
     int os_major_version = 0;
     int os_minor_version = 0;
     int os_bugfix_version = 0;
     KernelVersionNumbers(&os_major_version, &os_minor_version,
                          &os_bugfix_version);
-    if (os_major_version < 4) {
-      // Due to the potentially races in 3.17/3.18 kernels with eventfd,
-      // explicitly require a 4.x+ kernel.
+    if (os_major_version < 3 ||
+        (os_major_version == 3 && os_minor_version < 17)) {
       return false;
     }
+#endif
 
 #if defined(OS_ANDROID)
     // Finally, if running on Android it must have API version of at
-- 
2.33.0.800.g4c38ced690-goog

