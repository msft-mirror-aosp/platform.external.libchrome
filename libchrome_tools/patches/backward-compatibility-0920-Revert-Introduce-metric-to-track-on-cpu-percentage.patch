From 8ef61a3e0d5f261df6ba2d7eb42248e574321579 Mon Sep 17 00:00:00 2001
From: Nathan Muggli <nmuggli@google.com>
Date: Mon, 18 Mar 2024 09:09:29 -0600
Subject: [PATCH 3/3] Revert "Introduce metric to track on-cpu percentage."

This reverts commit 294d9321b7a42278e2dd89fabd5038eb2d2cc16d.
---
 .../sequence_manager_impl_unittest.cc         |  89 ++---------
 .../sequence_manager/thread_controller.cc     | 143 +-----------------
 .../task/sequence_manager/thread_controller.h |  24 +--
 3 files changed, 18 insertions(+), 238 deletions(-)

diff --git a/base/task/sequence_manager/sequence_manager_impl_unittest.cc b/base/task/sequence_manager/sequence_manager_impl_unittest.cc
index 06e3d4b580..29b1c50646 100644
--- a/base/task/sequence_manager/sequence_manager_impl_unittest.cc
+++ b/base/task/sequence_manager/sequence_manager_impl_unittest.cc
@@ -13,7 +13,6 @@
 
 #include "base/auto_reset.h"
 #include "base/cancelable_callback.h"
-#include "base/debug/stack_trace.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback.h"
 #include "base/functional/callback_forward.h"
@@ -24,12 +23,9 @@
 #include "base/memory/scoped_refptr.h"
 #include "base/message_loop/message_pump_default.h"
 #include "base/message_loop/message_pump_type.h"
-#include "base/rand_util.h"
 #include "base/run_loop.h"
-#include "base/sequence_checker_impl.h"
 #include "base/strings/strcat.h"
 #include "base/strings/string_number_conversions.h"
-#include "base/strings/string_split.h"
 #include "base/strings/stringprintf.h"
 #include "base/synchronization/waitable_event.h"
 #include "base/task/current_thread.h"
@@ -103,13 +99,6 @@ enum class WakeUpType {
   kAlign,
 };
 
-// Expresses whether metrics subsampling in ThreadController should always or
-// never sample which affects the count of calls to Now().
-enum class MetricsSampling {
-  kMetricsOn,
-  kMetricsOff,
-};
-
 enum class TestQueuePriority : TaskQueue::QueuePriority {
   kControlPriority = 0,
   kHighestPriority = 1,
@@ -143,21 +132,10 @@ std::string ToString(WakeUpType type) {
   }
 }
 
-std::string ToString(MetricsSampling sampling) {
-  switch (sampling) {
-    case MetricsSampling::kMetricsOn:
-      return "MetricsOn";
-    case MetricsSampling::kMetricsOff:
-      return "MetricsOff";
-  }
-}
-
 std::string GetTestNameSuffix(
-    const testing::TestParamInfo<
-        std::tuple<RunnerType, WakeUpType, MetricsSampling>>& info) {
+    const testing::TestParamInfo<std::tuple<RunnerType, WakeUpType>>& info) {
   return StrCat({"With", ToString(std::get<0>(info.param)).substr(1),
-                 ToString(std::get<1>(info.param)),
-                 ToString(std::get<2>(info.param))});
+                 ToString(std::get<1>(info.param))});
 }
 
 TaskQueueImpl* GetTaskQueueImpl(TaskQueue* task_queue) {
@@ -412,8 +390,7 @@ class FixtureWithMockMessagePump : public Fixture {
 // instead of templated ones. The latter would be more verbose as all method
 // calls to the fixture would need to be like this->method()
 class SequenceManagerTest
-    : public testing::TestWithParam<
-          std::tuple<RunnerType, WakeUpType, MetricsSampling>>,
+    : public testing::TestWithParam<std::tuple<RunnerType, WakeUpType>>,
       public Fixture {
  public:
   SequenceManagerTest() {
@@ -426,33 +403,6 @@ class SequenceManagerTest
             std::make_unique<FixtureWithMockMessagePump>(GetWakeUpType());
         break;
     }
-
-    if (GetSampling() == MetricsSampling::kMetricsOn) {
-      always_sample_scoper_.emplace();
-    } else {
-      never_sample_scoper_.emplace();
-    }
-  }
-
-  // Accounts for the extra calls to Now() that come when sampling is enabled.
-  int GetExtraNowSampleCount() {
-    // When no extra metrics are sampled there are no extra Now() calls.
-    if (GetSampling() == MetricsSampling::kMetricsOff) {
-      return 0;
-    }
-
-    // In both cases when sampling metrics there is a new call to Now() when
-    // ThreadController goes idle and the LazyNow instance used
-    // has no value. There is an equivalent use of LazyNow upon becoming active.
-    // In the case of RunnerType::kMessagePump the LazyNow has no value but it
-    // does when using RunnerType::kMockTaskRunner since it was already
-    // populated on entering OnWorkStarted().
-    switch (GetUnderlyingRunnerType()) {
-      case RunnerType::kMockTaskRunner:
-        return 1;
-      case RunnerType::kMessagePump:
-        return 2;
-    }
   }
 
   TaskQueue::Handle CreateTaskQueue(
@@ -520,37 +470,23 @@ class SequenceManagerTest
 
   RunnerType GetUnderlyingRunnerType() { return std::get<0>(GetParam()); }
   WakeUpType GetWakeUpType() { return std::get<1>(GetParam()); }
-  MetricsSampling GetSampling() { return std::get<2>(GetParam()); }
 
   TimeTicks FromStartAligned(TimeDelta delta) const override {
     return fixture_->FromStartAligned(delta);
   }
 
  private:
-  std::optional<base::MetricsSubSampler::ScopedAlwaysSampleForTesting>
-      always_sample_scoper_;
-  std::optional<base::MetricsSubSampler::ScopedNeverSampleForTesting>
-      never_sample_scoper_;
   debug::CrashKeyString dummy_key_{"dummy", debug::CrashKeySize::Size64};
   std::unique_ptr<Fixture> fixture_;
 };
 
 auto GetTestTypes() {
   return testing::Values(
-      std::make_tuple(RunnerType::kMessagePump, WakeUpType::kDefault,
-                      MetricsSampling::kMetricsOn),
-      std::make_tuple(RunnerType::kMessagePump, WakeUpType::kDefault,
-                      MetricsSampling::kMetricsOff),
+      std::make_tuple(RunnerType::kMessagePump, WakeUpType::kDefault),
 #if !BUILDFLAG(IS_WIN)
-      std::make_tuple(RunnerType::kMessagePump, WakeUpType::kAlign,
-                      MetricsSampling::kMetricsOn),
-      std::make_tuple(RunnerType::kMessagePump, WakeUpType::kAlign,
-                      MetricsSampling::kMetricsOff),
+      std::make_tuple(RunnerType::kMessagePump, WakeUpType::kAlign),
 #endif
-      std::make_tuple(RunnerType::kMockTaskRunner, WakeUpType::kDefault,
-                      MetricsSampling::kMetricsOn),
-      std::make_tuple(RunnerType::kMockTaskRunner, WakeUpType::kDefault,
-                      MetricsSampling::kMetricsOff));
+      std::make_tuple(RunnerType::kMockTaskRunner, WakeUpType::kDefault));
 }
 
 INSTANTIATE_TEST_SUITE_P(All,
@@ -632,14 +568,7 @@ TEST_P(SequenceManagerTest, NowNotCalledIfUnneeded) {
 
   RunLoop().RunUntilIdle();
 
-  // In the absence of calls to Now() for TimeObserver the only calls will
-  // come from metrics. There will be one call when the ThreadController
-  // becomes active and one when it becomes idle.
-  int extra_call_count = 0;
-  if (GetSampling() == MetricsSampling::kMetricsOn) {
-    extra_call_count = 2;
-  }
-  EXPECT_EQ(0 + extra_call_count, GetNowTicksCallCount());
+  EXPECT_EQ(0, GetNowTicksCallCount());
 }
 
 TEST_P(SequenceManagerTest,
@@ -660,7 +589,7 @@ TEST_P(SequenceManagerTest,
   RunLoop().RunUntilIdle();
   // Now is called when we start work and then for each task when it's
   // completed. 1 + 6  = 7 calls.
-  EXPECT_EQ(7 + GetExtraNowSampleCount(), GetNowTicksCallCount());
+  EXPECT_EQ(7, GetNowTicksCallCount());
 }
 
 TEST_P(SequenceManagerTest,
@@ -685,7 +614,7 @@ TEST_P(SequenceManagerTest,
   RunLoop().RunUntilIdle();
   // Now is called each time a task is queued, when first task is started
   // running, and when a task is completed. 1 + 6 * 2 = 13 calls.
-  EXPECT_EQ(13 + GetExtraNowSampleCount(), GetNowTicksCallCount());
+  EXPECT_EQ(13, GetNowTicksCallCount());
 }
 
 void NullTask() {}
diff --git a/base/task/sequence_manager/thread_controller.cc b/base/task/sequence_manager/thread_controller.cc
index f6de47e5d4..e65a7a7839 100644
--- a/base/task/sequence_manager/thread_controller.cc
+++ b/base/task/sequence_manager/thread_controller.cc
@@ -9,13 +9,9 @@
 #include "base/feature_list.h"
 #include "base/metrics/histogram.h"
 #include "base/metrics/histogram_base.h"
-#include "base/metrics/histogram_functions.h"
-#include "base/metrics/histogram_macros.h"
 #include "base/notreached.h"
-#include "base/strings/strcat.h"
 #include "base/strings/string_util.h"
 #include "base/time/tick_clock.h"
-#include "base/time/time.h"
 #include "base/trace_event/base_tracing.h"
 
 namespace base {
@@ -36,16 +32,6 @@ BASE_FEATURE(kThreadControllerSetsProfilerMetadata,
 // initialization on other clients but that's still way better than the current
 // situation which is reporting all the time.
 std::atomic<bool> g_thread_controller_sets_profiler_metadata{true};
-
-// ThreadController interval metrics are mostly of interest for intervals that
-// are not trivially short. Under a certain threshold it's unlikely that
-// intervention from developers would move metrics. Log with suffix for
-// intervals under a threshold chosen via tracing data. To validate the
-// threshold makes sense and does not filter out too many samples
-// ThreadController.ActiveIntervalDuration can be used.
-constexpr TimeDelta kNonTrivialActiveIntervalLength = Milliseconds(1);
-constexpr TimeDelta kMediumActiveIntervalLength = Milliseconds(100);
-
 }  // namespace
 
 ThreadController::ThreadController(const TickClock* time_source)
@@ -83,26 +69,6 @@ bool ThreadController::RunLevelTracker::RunLevel::ShouldRecordSampleMetadata() {
       std::memory_order_relaxed);
 }
 
-std::string ThreadController::RunLevelTracker::RunLevel::GetSuffixForHistogram(
-    TimeDelta duration) {
-  StringPiece time_suffix;
-  // No time specified
-  if (duration == TimeDelta()) {
-    time_suffix = "Any";
-  } else if (duration < kNonTrivialActiveIntervalLength) {
-    time_suffix = "Short";
-  } else if (duration < kMediumActiveIntervalLength) {
-    time_suffix = "Medium";
-  }
-
-  StringPiece thread_name = "Other";
-  if (!time_keeper_->thread_name().empty()) {
-    thread_name = time_keeper_->thread_name();
-  }
-
-  return base::StrCat({".", time_suffix, ".", thread_name});
-}
-
 void ThreadController::EnableMessagePumpTimeKeeperMetrics(
     const char* thread_name) {
   // MessagePump runs too fast, a low-res clock would result in noisy metrics.
@@ -120,8 +86,6 @@ void ThreadController::RunLevelTracker::EnableTimeKeeperMetrics(
 void ThreadController::RunLevelTracker::TimeKeeper::EnableRecording(
     const char* thread_name) {
   DCHECK(!histogram_);
-  thread_name_ = thread_name;
-
   histogram_ = LinearHistogram::FactoryGet(
       JoinString({"Scheduling.MessagePumpTimeKeeper", thread_name}, "."), 1,
       Phase::kLastPhase, Phase::kLastPhase + 1,
@@ -204,7 +168,7 @@ void ThreadController::RunLevelTracker::OnWorkStarted(LazyNow& lazy_now) {
     }
 
     // Going from kIdle or kInBetweenWorkItems to kRunningWorkItem.
-    run_levels_.top().UpdateState(kRunningWorkItem, lazy_now);
+    run_levels_.top().UpdateState(kRunningWorkItem);
   }
 }
 
@@ -242,7 +206,7 @@ void ThreadController::RunLevelTracker::OnWorkEnded(LazyNow& lazy_now,
   // Whether we exited a nested run-level or not: the current run-level is now
   // transitioning from kRunningWorkItem to kInBetweenWorkItems.
   DCHECK_EQ(run_levels_.top().state(), kRunningWorkItem);
-  run_levels_.top().UpdateState(kInBetweenWorkItems, lazy_now);
+  run_levels_.top().UpdateState(kInBetweenWorkItems);
 }
 
 void ThreadController::RunLevelTracker::OnIdle(LazyNow& lazy_now) {
@@ -252,7 +216,7 @@ void ThreadController::RunLevelTracker::OnIdle(LazyNow& lazy_now) {
 
   DCHECK_NE(run_levels_.top().state(), kRunningWorkItem);
   time_keeper_.RecordEndOfPhase(kIdleWork, lazy_now);
-  run_levels_.top().UpdateState(kIdle, lazy_now);
+  run_levels_.top().UpdateState(kIdle);
 }
 
 void ThreadController::RunLevelTracker::RecordScheduleWork() {
@@ -301,13 +265,13 @@ ThreadController::RunLevelTracker::RunLevel::RunLevel(
     // phase ends.
     time_keeper_->RecordEndOfPhase(kWorkItemSuspendedOnNested, lazy_now);
   }
-  UpdateState(initial_state, lazy_now);
+  UpdateState(initial_state);
 }
 
 ThreadController::RunLevelTracker::RunLevel::~RunLevel() {
   if (!was_moved_) {
     DCHECK(exit_lazy_now_);
-    UpdateState(kIdle, *exit_lazy_now_);
+    UpdateState(kIdle);
     if (is_nested_) {
       // Attribute the entire time in this nested RunLevel to kNested phase. If
       // this wasn't the last nested RunLevel, this is ignored and will be
@@ -329,93 +293,7 @@ ThreadController::RunLevelTracker::RunLevel::~RunLevel() {
 ThreadController::RunLevelTracker::RunLevel::RunLevel(RunLevel&& other) =
     default;
 
-void ThreadController::RunLevelTracker::RunLevel::LogPercentageMetric(
-    const char* name,
-    int percentage,
-    base::TimeDelta interval_duration) {
-  UmaHistogramPercentage(
-      base::StrCat({name, GetSuffixForHistogram(TimeDelta())}), percentage);
-  UmaHistogramPercentage(
-      base::StrCat({name, GetSuffixForHistogram(interval_duration)}),
-      percentage);
-}
-
-void ThreadController::RunLevelTracker::RunLevel::LogIntervalMetric(
-    const char* name,
-    base::TimeDelta value,
-    base::TimeDelta interval_duration) {
-  // Log towards "Any" thread suffix first.
-  UmaHistogramTimes(base::StrCat({name, GetSuffixForHistogram(TimeDelta())}),
-                    value);
-  if (interval_duration < kNonTrivialActiveIntervalLength) {
-    UmaHistogramCustomMicrosecondsTimes(
-        base::StrCat({name, GetSuffixForHistogram(interval_duration)}), value,
-        base::Microseconds(1), kNonTrivialActiveIntervalLength, 100);
-  } else if (interval_duration < kMediumActiveIntervalLength) {
-    UmaHistogramCustomTimes(
-        base::StrCat({name, GetSuffixForHistogram(interval_duration)}), value,
-        kNonTrivialActiveIntervalLength, kMediumActiveIntervalLength, 100);
-  }
-}
-
-void ThreadController::RunLevelTracker::RunLevel::LogOnActiveMetrics(
-    LazyNow& lazy_now) {
-  CHECK(last_active_start_.is_null());
-  CHECK(last_active_threadtick_start_.is_null());
-
-  if (!last_active_end_.is_null()) {
-    const base::TimeDelta idle_time = lazy_now.Now() - last_active_end_;
-    LogIntervalMetric("ThreadController.IdleDuration", idle_time, idle_time);
-    last_active_end_ = base::TimeTicks();
-  }
-
-  // Taking thread ticks can be expensive. Make sure to do it rarely enough to
-  // not have a discernible impact on performance.
-  static const bool thread_ticks_supported = ThreadTicks::IsSupported();
-  if (thread_ticks_supported && metrics_sub_sampler_.ShouldSample(0.001)) {
-    last_active_start_ = lazy_now.Now();
-    last_active_threadtick_start_ = ThreadTicks::Now();
-  }
-}
-
-void ThreadController::RunLevelTracker::RunLevel::LogOnIdleMetrics(
-    LazyNow& lazy_now) {
-  if (!last_active_start_.is_null()) {
-    const base::TimeDelta elapsed_ticks = lazy_now.Now() - last_active_start_;
-    base::TimeDelta elapsed_thread_ticks =
-        ThreadTicks::Now() - last_active_threadtick_start_;
-
-    // Round to 100% in case of clock imprecisions making it look like
-    // there's impossibly more ThreadTicks than TimeTicks elapsed.
-    elapsed_thread_ticks = std::min(elapsed_thread_ticks, elapsed_ticks);
-
-    LogIntervalMetric("ThreadController.ActiveIntervalDuration", elapsed_ticks,
-                      elapsed_ticks);
-    LogIntervalMetric("ThreadController.ActiveIntervalOffCpuDuration",
-                      elapsed_ticks - elapsed_thread_ticks, elapsed_ticks);
-    LogIntervalMetric("ThreadController.ActiveIntervalOnCpuDuration",
-                      elapsed_thread_ticks, elapsed_ticks);
-
-    // If the interval was shorter than a tick, 100% on-cpu time is assumed.
-    int active_interval_cpu_percentage =
-        elapsed_ticks.is_zero()
-            ? 100
-            : static_cast<int>(
-                  (elapsed_thread_ticks * 100).IntDiv(elapsed_ticks));
-
-    LogPercentageMetric("ThreadController.ActiveIntervalOnCpuPercentage",
-                        active_interval_cpu_percentage, elapsed_ticks);
-
-    // Reset timings.
-    last_active_start_ = base::TimeTicks();
-    last_active_threadtick_start_ = base::ThreadTicks();
-    last_active_end_ = lazy_now.Now();
-  }
-}
-
-void ThreadController::RunLevelTracker::RunLevel::UpdateState(
-    State new_state,
-    LazyNow& lazy_now) {
+void ThreadController::RunLevelTracker::RunLevel::UpdateState(State new_state) {
   // The only state that can be redeclared is idle, anything else should be a
   // transition.
   DCHECK(state_ != new_state || new_state == kIdle)
@@ -430,11 +308,9 @@ void ThreadController::RunLevelTracker::RunLevel::UpdateState(
 
   // Change of state.
   if (is_active) {
-    LogOnActiveMetrics(lazy_now);
-
     // Flow emission is found at
     // ThreadController::RunLevelTracker::RecordScheduleWork.
-    TRACE_EVENT_BEGIN("base", "ThreadController active", lazy_now.Now(),
+    TRACE_EVENT_BEGIN("base", "ThreadController active",
                       *terminating_wakeup_flow_lambda_);
 
     if (ShouldRecordSampleMetadata()) {
@@ -447,10 +323,7 @@ void ThreadController::RunLevelTracker::RunLevel::UpdateState(
     if (ShouldRecordSampleMetadata()) {
       thread_controller_sample_metadata_.Remove();
     }
-
-    LogOnIdleMetrics(lazy_now);
-
-    TRACE_EVENT_END("base", lazy_now.Now());
+    TRACE_EVENT_END("base");
     // TODO(crbug.com/1021571): Remove this once fixed.
     PERFETTO_INTERNAL_ADD_EMPTY_EVENT();
   }
diff --git a/base/task/sequence_manager/thread_controller.h b/base/task/sequence_manager/thread_controller.h
index 6108ee69eb..4d61e769fc 100644
--- a/base/task/sequence_manager/thread_controller.h
+++ b/base/task/sequence_manager/thread_controller.h
@@ -16,7 +16,6 @@
 #include "base/memory/scoped_refptr.h"
 #include "base/message_loop/message_pump.h"
 #include "base/profiler/sample_metadata.h"
-#include "base/rand_util.h"
 #include "base/run_loop.h"
 #include "base/task/common/lazy_now.h"
 #include "base/task/sequence_manager/associated_thread_id.h"
@@ -320,8 +319,6 @@ class BASE_EXPORT ThreadController {
       // for it.
       void RecordEndOfPhase(Phase phase, LazyNow& lazy_now);
 
-      const std::string& thread_name() const { return thread_name_; }
-
      private:
       enum class ShouldRecordReqs {
         // Regular should-record requirements.
@@ -344,7 +341,6 @@ class BASE_EXPORT ThreadController {
 
       static const char* PhaseToEventName(Phase phase);
 
-      std::string thread_name_;
       // Cumulative time deltas for each phase, reported and reset when >=100ms.
       std::array<TimeDelta, Phase::kLastPhase + 1> deltas_ = {};
       // Set at the start of the first work item out-of-idle. Consumed from the
@@ -391,7 +387,7 @@ class BASE_EXPORT ThreadController {
       RunLevel(RunLevel&& other);
       RunLevel& operator=(RunLevel&&) = delete;
 
-      void UpdateState(State new_state, LazyNow& lazy_now);
+      void UpdateState(State new_state);
 
       State state() const { return state_; }
 
@@ -402,29 +398,11 @@ class BASE_EXPORT ThreadController {
       }
 
      private:
-      void LogPercentageMetric(const char* name,
-                               int value,
-                               base::TimeDelta interval_duration);
-      void LogIntervalMetric(const char* name,
-                             base::TimeDelta value,
-                             base::TimeDelta interval_duration);
-      void LogOnActiveMetrics(LazyNow& lazy_now);
-      void LogOnIdleMetrics(LazyNow& lazy_now);
-
-      base::TimeTicks last_active_end_;
-      base::TimeTicks last_active_start_;
-      base::ThreadTicks last_active_threadtick_start_;
-      MetricsSubSampler metrics_sub_sampler_;
-
       State state_ = kIdle;
       bool is_nested_;
 
       bool ShouldRecordSampleMetadata();
 
-      // Get full suffix for histogram logging purposes. |duration| should equal
-      // TimeDelta() when not applicable.
-      std::string GetSuffixForHistogram(TimeDelta duration);
-
       const raw_ref<TimeKeeper> time_keeper_;
       // Must be set shortly before ~RunLevel.
       raw_ptr<LazyNow> exit_lazy_now_ = nullptr;
-- 
2.44.0.291.gc1ea87d7ee-goog

