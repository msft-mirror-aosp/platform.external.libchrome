From 84c02d7ee564a6587dc5817a55a182f74149abe3 Mon Sep 17 00:00:00 2001
From: Nathan Muggli <nmuggli@google.com>
Date: Mon, 18 Mar 2024 08:52:56 -0600
Subject: [PATCH 3/3] Revert "Remove base::{Read,Write}BigEndian"

This reverts commit dd594756704d3cbd22e90a5576239702d54fe2a4.
---
 base/big_endian.h           | 45 +++++++++++++++++++++++++++
 base/big_endian_unittest.cc | 61 +++++++++++++++++++++++++++++++++++++
 2 files changed, 106 insertions(+)

diff --git a/base/big_endian.h b/base/big_endian.h
index 76c419a799..0aed135575 100644
--- a/base/big_endian.h
+++ b/base/big_endian.h
@@ -55,6 +55,51 @@ inline uint8_t ByteSwapIfLittleEndian(uint8_t val) {
 
 }  // namespace internal
 
+// Read an integer (signed or unsigned) from |buf| in Big Endian order.
+// Note: this loop is unrolled with -O1 and above.
+// NOTE(szym): glibc dns-canon.c use ntohs(*(uint16_t*)ptr) which is
+// potentially unaligned.
+// This would cause SIGBUS on ARMv5 or earlier and ARMv6-M.
+//
+// DEPRECATED: Use base::numerics::*FromBigEndian to convert big-endian byte
+// encoding to primitives.
+template <typename T>
+inline void ReadBigEndian(span<const uint8_t, sizeof(T)> buffer, T* out) {
+  static_assert(std::is_integral_v<T>, "T has to be an integral type.");
+  // Make an unsigned version of the output type to make shift possible
+  // without UB.
+  std::make_unsigned_t<T> raw;
+  byte_span_from_ref(raw).copy_from(buffer);
+  *out = static_cast<T>(internal::ByteSwapIfLittleEndian(raw));
+}
+
+// TODO(crbug.com/40284755): Remove this function when there are no callers.
+template <typename T>
+inline void ReadBigEndian(const uint8_t buf[], T* out) {
+  ReadBigEndian(span<const uint8_t, sizeof(T)>(buf, sizeof(T)), out);
+}
+
+// Write an integer (signed or unsigned) `val` to `buffer` in Big Endian order.
+// The `buffer` must be the same size (in bytes) as the integer `val`.
+//
+// DEPRECATED: Use base::numerics::*ToBigEndian to convert primitives to big-
+// endian byte encoding.
+template <typename T>
+  requires(std::is_integral_v<T>)
+inline void WriteBigEndian(span<uint8_t, sizeof(T)> buffer, T val) {
+  const auto unsigned_val = static_cast<std::make_unsigned_t<T>>(val);
+  const auto raw = internal::ByteSwapIfLittleEndian(unsigned_val);
+  buffer.copy_from(byte_span_from_ref(raw));
+}
+
+// TODO(crbug.com/40284755): Remove this function when there are no callers.
+template <typename T>
+  requires(std::is_integral_v<T>)
+inline void WriteBigEndian(char buf[], T val) {
+  return WriteBigEndian(
+      as_writable_bytes(span<char, sizeof(T)>(buf, sizeof(T))), val);
+}
+
 // Allows reading integers in network order (big endian) while iterating over
 // an underlying buffer. All the reading functions advance the internal pointer.
 class BASE_EXPORT BigEndianReader {
diff --git a/base/big_endian_unittest.cc b/base/big_endian_unittest.cc
index a2f7348b8a..5fd3cf5e4e 100644
--- a/base/big_endian_unittest.cc
+++ b/base/big_endian_unittest.cc
@@ -13,6 +13,67 @@
 
 namespace base {
 
+TEST(ReadBigEndianTest, ReadSignedPositive) {
+  uint8_t data[] = {0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x1A, 0x2A};
+  int8_t s8 = 0;
+  int16_t s16 = 0;
+  int32_t s32 = 0;
+  int64_t s64 = 0;
+  ReadBigEndian(base::span(data).first<1>(), &s8);
+  ReadBigEndian(base::span(data).first<2>(), &s16);
+  ReadBigEndian(base::span(data).first<4>(), &s32);
+  ReadBigEndian(base::span(data).first<8>(), &s64);
+  EXPECT_EQ(0x0A, s8);
+  EXPECT_EQ(0x0A0B, s16);
+  EXPECT_EQ(int32_t{0x0A0B0C0D}, s32);
+  EXPECT_EQ(int64_t{0x0A0B0C0D0E0F1A2All}, s64);
+}
+
+TEST(ReadBigEndianTest, ReadSignedNegative) {
+  uint8_t data[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+  int8_t s8 = 0;
+  int16_t s16 = 0;
+  int32_t s32 = 0;
+  int64_t s64 = 0;
+  ReadBigEndian(base::span(data).first<1>(), &s8);
+  ReadBigEndian(base::span(data).first<2>(), &s16);
+  ReadBigEndian(base::span(data).first<4>(), &s32);
+  ReadBigEndian(base::span(data).first<8>(), &s64);
+  EXPECT_EQ(-1, s8);
+  EXPECT_EQ(-1, s16);
+  EXPECT_EQ(-1, s32);
+  EXPECT_EQ(-1, s64);
+}
+
+TEST(ReadBigEndianTest, ReadUnsignedSigned) {
+  uint8_t data[] = {0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0, 0xA1, 0xA2};
+  uint8_t u8 = 0;
+  uint16_t u16 = 0;
+  uint32_t u32 = 0;
+  uint64_t u64 = 0;
+  ReadBigEndian(base::span(data).first<1>(), &u8);
+  ReadBigEndian(base::span(data).first<2>(), &u16);
+  ReadBigEndian(base::span(data).first<4>(), &u32);
+  ReadBigEndian(base::span(data).first<8>(), &u64);
+  EXPECT_EQ(0xA0, u8);
+  EXPECT_EQ(0xA0B0, u16);
+  EXPECT_EQ(0xA0B0C0D0, u32);
+  EXPECT_EQ(0xA0B0C0D0E0F0A1A2ull, u64);
+}
+
+TEST(ReadBigEndianTest, TryAll16BitValues) {
+  using signed_type = int16_t;
+  uint8_t data[sizeof(signed_type)];
+  for (int i = std::numeric_limits<signed_type>::min();
+       i <= std::numeric_limits<signed_type>::max(); i++) {
+    signed_type expected = i;
+    signed_type actual = 0;
+    WriteBigEndian(data, expected);
+    ReadBigEndian(data, &actual);
+    EXPECT_EQ(expected, actual);
+  }
+}
+
 TEST(BigEndianReaderTest, ReadsValues) {
   std::array<uint8_t, 21u> data = {0,   1,   2,    3,    4,    5,    6,
                                    7,   8,   9,    0xA,  0xB,  0xC,  0xD,
-- 
2.44.0.291.gc1ea87d7ee-goog

