From 8358b0061d7f625bc545b651e7398280279db445 Mon Sep 17 00:00:00 2001
From: Ren-Pei Zeng <kamesan@google.com>
Date: Mon, 16 Sep 2024 08:47:31 +0000
Subject: [PATCH] Allow StringPrintf with non-constexpr format string

Change-Id: I26f173619e76d5398ed80ad63da94d23cbc940a5
---
 base/strings/stringprintf.cc | 23 +++++++++++++++++++++++
 base/strings/stringprintf.h  | 11 ++++-------
 2 files changed, 27 insertions(+), 7 deletions(-)

diff --git a/base/strings/stringprintf.cc b/base/strings/stringprintf.cc
index 71d77c5952..aab459fcfb 100644
--- a/base/strings/stringprintf.cc
+++ b/base/strings/stringprintf.cc
@@ -14,9 +14,32 @@
 #include "base/strings/span_printf.h"
 #include "base/strings/string_util.h"
 #include "build/build_config.h"
+#include "third_party/abseil-cpp/absl/cleanup/cleanup.h"
 
 namespace base {
 
+// `ENABLE_IF_ATTR()` is part of the function signature, so at least that
+// annotation, with a matching condition to the declaration, must be present, or
+// this would be considered a distinct overload (and other components will get
+// an unresolved symbol). The message need not match; anything put there will
+// only affect calls that see this definition instead of just the declaration,
+// i.e. calls within this file (i.e. none).
+std::string StringPrintf(const char* format, ...) {
+  va_list ap;
+  va_start(ap, format);
+  absl::Cleanup end_list = [&] { va_end(ap); };
+  return StringPrintV(format, ap);
+}
+
+#if HAS_ATTRIBUTE(enable_if)
+std::string StringPrintfNonConstexpr(const char* format, ...) {
+  va_list ap;
+  va_start(ap, format);
+  absl::Cleanup end_list = [&] { va_end(ap); };
+  return StringPrintV(format, ap);
+}
+#endif
+
 std::string StringPrintV(const char* format, va_list ap) {
   std::string result;
   StringAppendV(&result, format, ap);
diff --git a/base/strings/stringprintf.h b/base/strings/stringprintf.h
index 81a70dc1c6..828835d1ff 100644
--- a/base/strings/stringprintf.h
+++ b/base/strings/stringprintf.h
@@ -19,13 +19,10 @@ namespace base {
 
 // Returns a C++ string given `printf()`-like input. The format string must be a
 // compile-time constant (like with `std::format()`), or this will not compile.
-// TODO(crbug.com/40241565): Replace calls to this with direct calls to
-// `absl::StrFormat()` and remove.
-template <typename... Args>
-[[nodiscard]] std::string StringPrintf(const absl::FormatSpec<Args...>& format,
-                                       const Args&... args) {
-  return absl::StrFormat(format, args...);
-}
+// TODO(crbug.com/40241565): Implement in terms of `std::format()`,
+// `absl::StrFormat()`, or similar.
+[[nodiscard]] PRINTF_FORMAT(1, 2) BASE_EXPORT std::string
+    StringPrintf(const char* format, ...);
 
 // Returns a C++ string given `vprintf()`-like input.
 [[nodiscard]] PRINTF_FORMAT(1, 0) BASE_EXPORT std::string
-- 
2.47.1.613.gc27f4b7a9f-goog

