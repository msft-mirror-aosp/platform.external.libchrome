From ea70f9129dd672d990a34c3e86deec0ff078a880 Mon Sep 17 00:00:00 2001
From: Cici Ruan <cuicuiruan@google.com>
Date: Wed, 17 Apr 2024 21:13:23 -0700
Subject: [PATCH] Revert "Spanify and convert from BigEndianReader to
 SpanReader everywhere left"

This reverts commit fe420c63c5bc4110b1022ff66fd073ad0cf98bf2.

Change-Id: I55eeb1e3a16f44beec5ef24e99c81fc7fce286cf
---
 base/big_endian.cc | 167 +++++++++++++++++++++++++++++++++++++++++++++
 base/big_endian.h  | 121 +++++++++++++++++++++++++++++++-
 2 files changed, 285 insertions(+), 3 deletions(-)
 create mode 100644 base/big_endian.cc

diff --git a/base/big_endian.cc b/base/big_endian.cc
new file mode 100644
index 0000000000..27157d3b43
--- /dev/null
+++ b/base/big_endian.cc
@@ -0,0 +1,167 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/big_endian.h"
+
+#include <string.h>
+
+#include <string_view>
+
+#include "base/numerics/byte_conversions.h"
+#include "base/numerics/checked_math.h"
+
+namespace base {
+
+BigEndianReader BigEndianReader::FromStringPiece(std::string_view view) {
+  return BigEndianReader(as_byte_span(view));
+}
+
+BigEndianReader::BigEndianReader(const uint8_t* buf, size_t len)
+    :  // TODO(crbug.com/40284755): Remove this constructor entirely, callers
+       // should use span constructor.
+      UNSAFE_BUFFERS(buffer_(buf, len)) {}
+
+BigEndianReader::BigEndianReader(span<const uint8_t> buffer)
+    : buffer_(buffer) {}
+
+BigEndianReader::~BigEndianReader() = default;
+
+bool BigEndianReader::Skip(size_t len) {
+  if (len > remaining()) {
+    return false;
+  }
+  buffer_ = buffer_.subspan(len);
+  return true;
+}
+
+bool BigEndianReader::ReadU8(uint8_t* value) {
+  std::array<uint8_t, 1u> bytes;
+  if (!ReadBytes<1u>(bytes)) {
+    return false;
+  }
+  *value = U8FromBigEndian(bytes);
+  return true;
+}
+
+bool BigEndianReader::ReadI8(int8_t* value) {
+  std::array<uint8_t, 1u> bytes;
+  if (!ReadBytes<1u>(bytes)) {
+    return false;
+  }
+  *value = static_cast<int8_t>(numerics::U8FromBigEndian(bytes));
+  return true;
+}
+
+bool BigEndianReader::ReadU16(uint16_t* value) {
+  std::array<uint8_t, 2u> bytes;
+  if (!ReadBytes<2u>(bytes)) {
+    return false;
+  }
+  *value = U16FromBigEndian(bytes);
+  return true;
+}
+
+bool BigEndianReader::ReadI16(int16_t* value) {
+  std::array<uint8_t, 2u> bytes;
+  if (!ReadBytes<2u>(bytes)) {
+    return false;
+  }
+  *value = static_cast<int16_t>(numerics::U16FromBigEndian(bytes));
+  return true;
+}
+
+bool BigEndianReader::ReadU32(uint32_t* value) {
+  std::array<uint8_t, 4u> bytes;
+  if (!ReadBytes<4u>(bytes)) {
+    return false;
+  }
+  *value = U32FromBigEndian(bytes);
+  return true;
+}
+
+bool BigEndianReader::ReadI32(int32_t* value) {
+  std::array<uint8_t, 4u> bytes;
+  if (!ReadBytes<4u>(bytes)) {
+    return false;
+  }
+  *value = static_cast<int32_t>(numerics::U32FromBigEndian(bytes));
+  return true;
+}
+
+bool BigEndianReader::ReadU64(uint64_t* value) {
+  std::array<uint8_t, 8u> bytes;
+  if (!ReadBytes<8u>(bytes)) {
+    return false;
+  }
+  *value = U64FromBigEndian(bytes);
+  return true;
+}
+
+bool BigEndianReader::ReadI64(int64_t* value) {
+  std::array<uint8_t, 8u> bytes;
+  if (!ReadBytes<8u>(bytes)) {
+    return false;
+  }
+  *value = static_cast<int64_t>(numerics::U64FromBigEndian(bytes));
+  return true;
+}
+
+bool BigEndianReader::ReadPiece(std::string_view* out, size_t len) {
+  if (len > remaining()) {
+    return false;
+  }
+  auto [view, remain] = buffer_.split_at(len);
+  *out =
+      std::string_view(reinterpret_cast<const char*>(view.data()), view.size());
+  buffer_ = remain;
+  return true;
+}
+
+std::optional<span<const uint8_t>> BigEndianReader::ReadSpan(
+    StrictNumeric<size_t> n) {
+  if (remaining() < size_t{n}) {
+    return std::nullopt;
+  }
+  auto [consume, remain] = buffer_.split_at(n);
+  buffer_ = remain;
+  return {consume};
+}
+
+bool BigEndianReader::ReadBytes(span<uint8_t> out) {
+  if (remaining() < out.size()) {
+    return false;
+  }
+  auto [consume, remain] = buffer_.split_at(out.size());
+  buffer_ = remain;
+  out.copy_from(consume);
+  return true;
+}
+
+bool BigEndianReader::ReadU8LengthPrefixed(std::string_view* out) {
+  span<const uint8_t> rollback = buffer_;
+  uint8_t len;
+  if (!ReadU8(&len)) {
+    return false;
+  }
+  const bool ok = ReadPiece(out, len);
+  if (!ok) {
+    buffer_ = rollback;  // Undo the ReadU8.
+  }
+  return ok;
+}
+
+bool BigEndianReader::ReadU16LengthPrefixed(std::string_view* out) {
+  span<const uint8_t> rollback = buffer_;
+  uint16_t len;
+  if (!ReadU16(&len)) {
+    return false;
+  }
+  const bool ok = ReadPiece(out, len);
+  if (!ok) {
+    buffer_ = rollback;  // Undo the ReadU8.
+  }
+  return ok;
+}
+
+}  // namespace base
diff --git a/base/big_endian.h b/base/big_endian.h
index fe4ee134ee..b9f3a4a5ec 100644
--- a/base/big_endian.h
+++ b/base/big_endian.h
@@ -5,9 +5,6 @@
 #ifndef BASE_BIG_ENDIAN_H_
 #define BASE_BIG_ENDIAN_H_
 
-// TODO(danakj): Remove this header file, but it might be a pain since it's
-// included in a lot of places, and they may depend on these includes.
-
 #include <stddef.h>
 #include <stdint.h>
 #include <string.h>
@@ -21,4 +18,122 @@
 #include "base/containers/span.h"
 #include "base/memory/raw_span.h"
 
+namespace base {
+
+// Allows reading integers in network order (big endian) while iterating over
+// an underlying buffer. All the reading functions advance the internal pointer.
+class BASE_EXPORT BigEndianReader {
+ public:
+  static BigEndianReader FromStringPiece(std::string_view string_piece);
+
+  explicit BigEndianReader(base::span<const uint8_t> buffer);
+
+  // TODO(crbug.com/40284755): Remove this overload.
+  UNSAFE_BUFFER_USAGE BigEndianReader(const uint8_t* buf, size_t len);
+
+  ~BigEndianReader();
+
+  // Returns a span over all unread bytes.
+  span<const uint8_t> remaining_bytes() const { return buffer_; }
+
+  // TODO(crbug.com/40284755): Remove this method.
+  const uint8_t* ptr() const { return buffer_.data(); }
+  // TODO(crbug.com/40284755): Remove this method.
+  size_t remaining() const { return buffer_.size(); }
+
+  // Moves the internal state forward `len` bytes, or returns false if there is
+  // not enough bytes left to read from.
+  bool Skip(size_t len);
+
+  // Reads an 8-bit integer and advances past it. Returns false if there is not
+  // enough bytes to read from.
+  bool ReadU8(uint8_t* value);
+  // Reads an 8-bit signed integer and advances past it. Returns false if there
+  // is not enough bytes to read from.
+  bool ReadI8(int8_t* value);
+  // Reads a 16-bit integer and advances past it. Returns false if there is not
+  // enough bytes to read from.
+  bool ReadU16(uint16_t* value);
+  // Reads a 16-bit signed integer and advances past it. Returns false if there
+  // is not enough bytes to read from.
+  bool ReadI16(int16_t* value);
+  // Reads a 32-bit integer and advances past it. Returns false if there is not
+  // enough bytes to read from.
+  bool ReadU32(uint32_t* value);
+  // Reads a 32-bit signed integer and advances past it. Returns false if there
+  // is not enough bytes to read from.
+  bool ReadI32(int32_t* value);
+  // Reads a 64-bit integer and advances past it. Returns false if there is not
+  // enough bytes to read from.
+  bool ReadU64(uint64_t* value);
+  // Reads a 64-bit signed integer and advances past it. Returns false if there
+  // is not enough bytes to read from.
+  bool ReadI64(int64_t* value);
+
+  // An alias for `ReadU8` that works with a `char` pointer instead of
+  // `uint8_t`.
+  bool ReadChar(char* value) {
+    return ReadU8(reinterpret_cast<uint8_t*>(value));
+  }
+
+  // Creates a string_view in |out| that points to the underlying buffer.
+  bool ReadPiece(std::string_view* out, size_t len);
+
+  // Returns a span over `n` bytes from the buffer and moves the internal state
+  // past those bytes, or returns nullopt and if there are not `n` bytes
+  // remaining in the buffer.
+  std::optional<span<const uint8_t>> ReadSpan(base::StrictNumeric<size_t> n);
+
+  // Returns a span over `N` bytes from the buffer and moves the internal state
+  // past those bytes, or returns nullopt and if there are not `N` bytes
+  // remaining in the buffer.
+  template <size_t N>
+  std::optional<span<const uint8_t, N>> ReadSpan() {
+    if (remaining() < N) {
+      return std::nullopt;
+    }
+    auto [consume, remain] = buffer_.split_at<N>();
+    buffer_ = remain;
+    return {consume};
+  }
+
+  // Copies into a span (writing to the whole span) from the buffer and moves
+  // the internal state past the copied bytes, or returns false and if there are
+  // not enough bytes remaining in the buffer to fill the span and leaves the
+  // internal state unchanged.
+  bool ReadBytes(span<uint8_t> out);
+
+  // Copies into a span of `N` bytes from the buffer and moves the internal
+  // state past the copied bytes, or returns false and if there are not `N`
+  // bytes remaining in the buffer and leaves the internal state unchanged.
+  template <size_t N>
+  bool ReadBytes(span<uint8_t, N> out) {
+    std::optional<span<const uint8_t, N>> span = ReadSpan<N>();
+    if (!span.has_value()) {
+      return false;
+    }
+    out.copy_from(*span);
+    return true;
+  }
+
+  // Reads a length-prefixed region:
+  // 1. reads a big-endian length L from the buffer;
+  // 2. sets |*out| to a string_view over the next L many bytes
+  // of the buffer (beyond the end of the bytes encoding the length); and
+  // 3. skips the main reader past this L-byte substring.
+  //
+  // Fails if reading a U8 or U16 fails, or if the parsed length is greater
+  // than the number of bytes remaining in the stream.
+  //
+  // On failure, leaves the stream at the same position
+  // as before the call.
+  bool ReadU8LengthPrefixed(std::string_view* out);
+  bool ReadU16LengthPrefixed(std::string_view* out);
+
+ private:
+  raw_span<const uint8_t> buffer_;
+};
+
+}  // namespace base
+
 #endif  // BASE_BIG_ENDIAN_H_
-- 
2.44.0.683.g7961c838ac-goog

