From 1ec4a88481270af3a992274cbe1894ffbc444e6f Mon Sep 17 00:00:00 2001
From: Grace Cham <hscham@chromium.org>
Date: Wed, 26 Oct 2022 11:36:39 +0900
Subject: [PATCH] Revert "Reland: Use absl::Mutex in StatisticsRecorder for R/W
 semantics."

This reverts commit c631aacb8efb02ecc2dc35946dd1cb1cd554c906.
---
 base/metrics/statistics_recorder.cc          | 68 +++++++++-----------
 base/metrics/statistics_recorder.h           | 27 ++++----
 base/metrics/statistics_recorder_unittest.cc | 21 +-----
 3 files changed, 48 insertions(+), 68 deletions(-)

diff --git a/base/metrics/statistics_recorder.cc b/base/metrics/statistics_recorder.cc
index 9e433c55ddc6..c598fbc53b9f 100644
--- a/base/metrics/statistics_recorder.cc
+++ b/base/metrics/statistics_recorder.cc
@@ -32,8 +32,7 @@ bool HistogramNameLesser(const base::HistogramBase* a,
 }  // namespace
 
 // static
-LazyInstance<absl::Mutex>::Leaky StatisticsRecorder::lock_ =
-    LAZY_INSTANCE_INITIALIZER;
+LazyInstance<Lock>::Leaky StatisticsRecorder::lock_ = LAZY_INSTANCE_INITIALIZER;
 
 // static
 StatisticsRecorder* StatisticsRecorder::top_ = nullptr;
@@ -68,14 +67,14 @@ void StatisticsRecorder::ScopedHistogramSampleObserver::RunCallback(
 }
 
 StatisticsRecorder::~StatisticsRecorder() {
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   DCHECK_EQ(this, top_);
   top_ = previous_;
 }
 
 // static
 void StatisticsRecorder::EnsureGlobalRecorderWhileLocked() {
-  lock_.Get().AssertHeld();
+  lock_.Get().AssertAcquired();
   if (top_)
     return;
 
@@ -88,7 +87,7 @@ void StatisticsRecorder::EnsureGlobalRecorderWhileLocked() {
 // static
 void StatisticsRecorder::RegisterHistogramProvider(
     const WeakPtr<HistogramProvider>& provider) {
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   EnsureGlobalRecorderWhileLocked();
   top_->providers_.push_back(provider);
 }
@@ -98,7 +97,7 @@ HistogramBase* StatisticsRecorder::RegisterOrDeleteDuplicate(
     HistogramBase* histogram) {
   // Declared before |auto_lock| to ensure correct destruction order.
   std::unique_ptr<HistogramBase> histogram_deleter;
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   EnsureGlobalRecorderWhileLocked();
 
   const char* const name = histogram->histogram_name();
@@ -130,7 +129,7 @@ HistogramBase* StatisticsRecorder::RegisterOrDeleteDuplicate(
 // static
 const BucketRanges* StatisticsRecorder::RegisterOrDeleteDuplicateRanges(
     const BucketRanges* ranges) {
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   EnsureGlobalRecorderWhileLocked();
 
   const BucketRanges* const registered =
@@ -174,7 +173,7 @@ std::string StatisticsRecorder::ToJSON(JSONVerbosityLevel verbosity_level) {
 
 // static
 std::vector<const BucketRanges*> StatisticsRecorder::GetBucketRanges() {
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   EnsureGlobalRecorderWhileLocked();
 
   return top_->ranges_manager_.GetBucketRanges();
@@ -182,28 +181,22 @@ std::vector<const BucketRanges*> StatisticsRecorder::GetBucketRanges() {
 
 // static
 HistogramBase* StatisticsRecorder::FindHistogram(base::StringPiece name) {
-  // This must be called *before* the lock is acquired below because it may
-  // call back into StatisticsRecorder to register histograms. Those called
-  // methods will acquire the lock at that time.
+  // This must be called *before* the lock is acquired below because it will
+  // call back into this object to register histograms. Those called methods
+  // will acquire the lock at that time.
   ImportGlobalPersistentHistograms();
 
-  // Acquire the lock in "read" mode since we're only reading the data, not
-  // modifying anything. This allows multiple readers to look up histograms
-  // concurrently.
-  const absl::ReaderMutexLock auto_lock(lock_.Pointer());
-  if (top_) {
-    const HistogramMap::const_iterator it = top_->histograms_.find(name);
-    return it != top_->histograms_.end() ? it->second : nullptr;
-  }
-  // If we're here, |top_| was null (no StatisticsRecorder instance), so the
-  // histogram also doesn't exist.
-  return nullptr;
+  const AutoLock auto_lock(lock_.Get());
+  EnsureGlobalRecorderWhileLocked();
+
+  const HistogramMap::const_iterator it = top_->histograms_.find(name);
+  return it != top_->histograms_.end() ? it->second : nullptr;
 }
 
 // static
 StatisticsRecorder::HistogramProviders
 StatisticsRecorder::GetHistogramProviders() {
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   EnsureGlobalRecorderWhileLocked();
   return top_->providers_;
 }
@@ -234,7 +227,7 @@ void StatisticsRecorder::PrepareDeltas(
 
 // static
 void StatisticsRecorder::InitLogOnShutdown() {
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   InitLogOnShutdownWhileLocked();
 }
 
@@ -243,7 +236,7 @@ void StatisticsRecorder::AddHistogramSampleObserver(
     const std::string& name,
     StatisticsRecorder::ScopedHistogramSampleObserver* observer) {
   DCHECK(observer);
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   EnsureGlobalRecorderWhileLocked();
 
   auto iter = top_->observers_.find(name);
@@ -267,7 +260,7 @@ void StatisticsRecorder::AddHistogramSampleObserver(
 void StatisticsRecorder::RemoveHistogramSampleObserver(
     const std::string& name,
     StatisticsRecorder::ScopedHistogramSampleObserver* observer) {
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   EnsureGlobalRecorderWhileLocked();
 
   auto iter = top_->observers_.find(name);
@@ -295,7 +288,7 @@ void StatisticsRecorder::FindAndRunHistogramCallbacks(
     const char* histogram_name,
     uint64_t name_hash,
     HistogramBase::Sample sample) {
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   EnsureGlobalRecorderWhileLocked();
 
   auto it = top_->observers_.find(histogram_name);
@@ -312,7 +305,7 @@ void StatisticsRecorder::FindAndRunHistogramCallbacks(
 // static
 void StatisticsRecorder::SetGlobalSampleCallback(
     const GlobalSampleCallback& new_global_sample_callback) {
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   EnsureGlobalRecorderWhileLocked();
 
   DCHECK(!global_sample_callback() || !new_global_sample_callback);
@@ -325,14 +318,14 @@ void StatisticsRecorder::SetGlobalSampleCallback(
 
 // static
 size_t StatisticsRecorder::GetHistogramCount() {
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   EnsureGlobalRecorderWhileLocked();
   return top_->histograms_.size();
 }
 
 // static
 void StatisticsRecorder::ForgetHistogramForTesting(base::StringPiece name) {
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   EnsureGlobalRecorderWhileLocked();
 
   const HistogramMap::iterator found = top_->histograms_.find(name);
@@ -354,7 +347,7 @@ void StatisticsRecorder::ForgetHistogramForTesting(base::StringPiece name) {
 // static
 std::unique_ptr<StatisticsRecorder>
 StatisticsRecorder::CreateTemporaryForTesting() {
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   std::unique_ptr<StatisticsRecorder> temporary_recorder =
       WrapUnique(new StatisticsRecorder());
   temporary_recorder->ranges_manager_
@@ -365,15 +358,16 @@ StatisticsRecorder::CreateTemporaryForTesting() {
 // static
 void StatisticsRecorder::SetRecordChecker(
     std::unique_ptr<RecordHistogramChecker> record_checker) {
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   EnsureGlobalRecorderWhileLocked();
   top_->record_checker_ = std::move(record_checker);
 }
 
 // static
 bool StatisticsRecorder::ShouldRecordHistogram(uint32_t histogram_hash) {
-  const absl::ReaderMutexLock auto_lock(lock_.Pointer());
-  return !top_ || !top_->record_checker_ ||
+  const AutoLock auto_lock(lock_.Get());
+  EnsureGlobalRecorderWhileLocked();
+  return !top_->record_checker_ ||
          top_->record_checker_->ShouldRecord(histogram_hash);
 }
 
@@ -386,7 +380,7 @@ StatisticsRecorder::Histograms StatisticsRecorder::GetHistograms() {
 
   Histograms out;
 
-  const absl::MutexLock auto_lock(lock_.Pointer());
+  const AutoLock auto_lock(lock_.Get());
   EnsureGlobalRecorderWhileLocked();
 
   out.reserve(top_->histograms_.size());
@@ -441,7 +435,7 @@ void StatisticsRecorder::ImportGlobalPersistentHistograms() {
 }
 
 StatisticsRecorder::StatisticsRecorder() {
-  lock_.Get().AssertHeld();
+  lock_.Get().AssertAcquired();
   previous_ = top_;
   top_ = this;
   InitLogOnShutdownWhileLocked();
@@ -449,7 +443,7 @@ StatisticsRecorder::StatisticsRecorder() {
 
 // static
 void StatisticsRecorder::InitLogOnShutdownWhileLocked() {
-  lock_.Get().AssertHeld();
+  lock_.Get().AssertAcquired();
   if (!is_vlog_initialized_ && VLOG_IS_ON(1)) {
     is_vlog_initialized_ = true;
     const auto dump_to_vlog = [](void*) {
diff --git a/base/metrics/statistics_recorder.h b/base/metrics/statistics_recorder.h
index 4f8ebc9293c6..07e65eb807dc 100644
--- a/base/metrics/statistics_recorder.h
+++ b/base/metrics/statistics_recorder.h
@@ -30,9 +30,8 @@
 #include "base/metrics/record_histogram_checker.h"
 #include "base/observer_list_threadsafe.h"
 #include "base/strings/string_piece.h"
-#include "base/thread_annotations.h"
+#include "base/synchronization/lock.h"
 #include "base/types/pass_key.h"
-#include "third_party/abseil-cpp/absl/synchronization/mutex.h"
 
 namespace base {
 
@@ -314,8 +313,9 @@ class BASE_EXPORT StatisticsRecorder {
 
   // Initializes the global recorder if it doesn't already exist. Safe to call
   // multiple times.
-  static void EnsureGlobalRecorderWhileLocked()
-      EXCLUSIVE_LOCKS_REQUIRED(lock_.Pointer());
+  //
+  // Precondition: The global lock is already acquired.
+  static void EnsureGlobalRecorderWhileLocked();
 
   // Gets histogram providers.
   //
@@ -325,8 +325,7 @@ class BASE_EXPORT StatisticsRecorder {
   // Imports histograms from global persistent memory.
   //
   // Precondition: The global lock must not be held during this call.
-  static void ImportGlobalPersistentHistograms()
-      LOCKS_EXCLUDED(lock_.Pointer());
+  static void ImportGlobalPersistentHistograms();
 
   // Constructs a new StatisticsRecorder and sets it as the current global
   // recorder.
@@ -334,12 +333,15 @@ class BASE_EXPORT StatisticsRecorder {
   // This singleton instance should be started during the single-threaded
   // portion of startup and hence it is not thread safe. It initializes globals
   // to provide support for all future calls.
-  StatisticsRecorder() EXCLUSIVE_LOCKS_REQUIRED(lock_.Pointer());
+  //
+  // Precondition: The global lock is already acquired.
+  StatisticsRecorder();
 
   // Initialize implementation but without lock. Caller should guard
   // StatisticsRecorder by itself if needed (it isn't in unit tests).
-  static void InitLogOnShutdownWhileLocked()
-      EXCLUSIVE_LOCKS_REQUIRED(lock_.Pointer());
+  //
+  // Precondition: The global lock is already acquired.
+  static void InitLogOnShutdownWhileLocked();
 
   HistogramMap histograms_;
   ObserverMap observers_;
@@ -350,14 +352,13 @@ class BASE_EXPORT StatisticsRecorder {
   // Previous global recorder that existed when this one was created.
   raw_ptr<StatisticsRecorder> previous_ = nullptr;
 
-  // Global lock for internal synchronization. Uses an absl::Mutex to
-  // support read/write lock semantics.
-  static LazyInstance<absl::Mutex>::Leaky lock_;
+  // Global lock for internal synchronization.
+  static LazyInstance<Lock>::Leaky lock_;
 
   // Current global recorder. This recorder is used by static methods. When a
   // new global recorder is created by CreateTemporaryForTesting(), then the
   // previous global recorder is referenced by top_->previous_.
-  static StatisticsRecorder* top_ GUARDED_BY(lock_.Pointer());
+  static StatisticsRecorder* top_;
 
   // Tracks whether InitLogOnShutdownWhileLocked() has registered a logging
   // function that will be called when the program finishes.
diff --git a/base/metrics/statistics_recorder_unittest.cc b/base/metrics/statistics_recorder_unittest.cc
index 787490483df0..2aa39d9e789f 100644
--- a/base/metrics/statistics_recorder_unittest.cc
+++ b/base/metrics/statistics_recorder_unittest.cc
@@ -94,26 +94,11 @@ class StatisticsRecorderTest : public testing::TestWithParam<bool> {
   // NotInitialized to ensure a clean global state.
   void UninitializeStatisticsRecorder() {
     statistics_recorder_.reset();
-
-    // Grab the lock, so we can access |top_| to satisfy locking annotations.
-    // Normally, this wouldn't be OK (we're taking a pointer to |top_| and then
-    // freeing it outside the lock), but in this case, it's benign because the
-    // test is single-threaded.
-    //
-    // Note: We can't clear |top_| in the locked block, because the
-    // StatitisticsRecorder destructor expects |this == top_|.
-    {
-      const absl::MutexLock auto_lock(StatisticsRecorder::lock_.Pointer());
-      statistics_recorder_.reset(StatisticsRecorder::top_);
-    }
-    statistics_recorder_.reset();
-    DCHECK(!HasGlobalRecorder());
+    delete StatisticsRecorder::top_;
+    DCHECK(!StatisticsRecorder::top_);
   }
 
-  bool HasGlobalRecorder() {
-    const absl::ReaderMutexLock auto_lock(StatisticsRecorder::lock_.Pointer());
-    return StatisticsRecorder::top_ != nullptr;
-  }
+  bool HasGlobalRecorder() { return StatisticsRecorder::top_ != nullptr; }
 
   Histogram* CreateHistogram(const char* name,
                              HistogramBase::Sample min,
-- 
2.38.0.135.g90850a2211-goog

