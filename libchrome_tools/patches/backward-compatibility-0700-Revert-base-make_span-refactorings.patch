From 30b73a4b7ab990fc2409fa26bf244648e7fd6aef Mon Sep 17 00:00:00 2001
From: Andrew Moylan <amoylan@google.com>
Date: Tue, 12 Nov 2024 15:17:02 +1100
Subject: [PATCH] Revert base::make_span refactorings

Temporarily revert refactorings related to lifetime of arguments of
base::make_span() and base::span().

Change-Id: I99403040541bb45981abfb432734b0a3d12bf1ec
---
 base/containers/span.h | 126 ++++++++++++++++++++---------------------
 1 file changed, 60 insertions(+), 66 deletions(-)

diff --git a/base/containers/span.h b/base/containers/span.h
index 6ee0802cbd..13d930c143 100644
--- a/base/containers/span.h
+++ b/base/containers/span.h
@@ -204,7 +204,9 @@ template <typename T>
 inline constexpr size_t MaybeStaticExt<T> = {T::value};
 
 template <typename From, typename To>
-concept LegalDataConversion = std::is_convertible_v<From (*)[], To (*)[]>;
+concept LegalDataConversion =
+    std::is_convertible_v<std::remove_reference_t<From> (*)[],
+                          std::remove_reference_t<To> (*)[]>;
 
 // Akin to `std::constructible_from<span, T>`, but meant to be used in a
 // type-deducing context where we don't know what args would be deduced;
@@ -212,12 +214,11 @@ concept LegalDataConversion = std::is_convertible_v<From (*)[], To (*)[]>;
 // type parameters must be fully-specified (e.g. `span<int>`), requiring us to
 // have that knowledge already.
 template <typename T>
-concept SpanConstructibleFrom = requires(T&& t) { span(std::forward<T>(t)); };
+concept SpanConstructibleFrom = requires(const T& t) { span(t); };
 
 template <typename T, typename It>
-concept CompatibleIter =
-    std::contiguous_iterator<It> &&
-    LegalDataConversion<std::remove_reference_t<std::iter_reference_t<It>>, T>;
+concept CompatibleIter = std::contiguous_iterator<It> &&
+                         LegalDataConversion<std::iter_reference_t<It>, T>;
 
 // Disallow general-purpose range construction from types that have dedicated
 // constructors.
@@ -233,14 +234,27 @@ concept CompatibleRange =
     std::ranges::contiguous_range<R> && std::ranges::sized_range<R> &&
     (std::ranges::borrowed_range<R> ||
      std::is_const_v<T>)&&kCompatibleRangeType<std::remove_cvref_t<R>> &&
-    LegalDataConversion<
-        std::remove_reference_t<std::ranges::range_reference_t<R>>,
-        T>;
+    LegalDataConversion<std::ranges::range_reference_t<R>, T>;
 
-// Whether source object extent `X` will work to create a span of fixed extent
-// `N`. This is not intended for use in dynamic-extent spans.
-template <size_t N, size_t X>
-concept FixedExtentConstructibleFromExtent = X == N || X == dynamic_extent;
+template <typename T>
+concept LegacyRangeDataIsPointer = std::is_pointer_v<T>;
+
+template <typename R>
+concept LegacyRange =
+    kCompatibleRangeType<std::remove_cvref_t<R>> && requires(R& r) {
+      { std::ranges::data(r) } -> LegacyRangeDataIsPointer;
+      { std::ranges::size(r) } -> std::convertible_to<size_t>;
+    };
+
+// NOTE: Ideally we'd just use `CompatibleRange`, however this currently breaks
+// code that was written prior to C++20 being standardized and assumes providing
+// .data() and .size() is sufficient.
+// TODO: https://crbug.com/1504998 - Remove in favor of CompatibleRange and fix
+// callsites.
+template <typename T, typename R>
+concept LegacyCompatibleRange = LegacyRange<R> && requires(R& r) {
+  { *std::ranges::data(r) } -> LegalDataConversion<T>;
+};
 
 // Computes a fixed extent if possible from a source container type `T`.
 template <typename T>
@@ -365,39 +379,33 @@ class GSL_POINTER span {
   }
 
   // NOLINTNEXTLINE(google-explicit-constructor)
-  constexpr span(std::type_identity_t<T> (&arr LIFETIME_BOUND)[N]) noexcept
-      // SAFETY: The type signature guarantees `arr` contains `N` elements.
-      : UNSAFE_BUFFERS(span(arr, N)) {}
+  constexpr span(std::type_identity_t<T> (&arr)[N]) noexcept
+      // SAFETY: The std::ranges::size() function gives the number of elements
+      // pointed to by the std::ranges::data() function, which meets the
+      // requirement of span.
+      : UNSAFE_BUFFERS(span(std::ranges::data(arr), std::ranges::size(arr))) {}
 
   template <typename R, size_t X = internal::kComputedExtent<R>>
-    requires(internal::CompatibleRange<T, R> &&
-             internal::FixedExtentConstructibleFromExtent<N, X>)
+    requires(internal::CompatibleRange<T, R> && (X == N || X == dynamic_extent))
   // NOLINTNEXTLINE(google-explicit-constructor)
-  constexpr explicit(X != N) span(R&& range LIFETIME_BOUND)
-      // SAFETY: `std::ranges::size()` returns the number of elements
-      // `std::ranges::data()` will point to, so accessing those elements will
-      // be safe.
+  explicit(X == dynamic_extent) constexpr span(R&& range) noexcept
+      // SAFETY: The std::ranges::begin() and std::ranges:end() functions always
+      // give a valid iterator pair.
       : UNSAFE_BUFFERS(
-            span(std::ranges::data(range), std::ranges::size(range))) {}
+            span(std::ranges::begin(range), std::ranges::end(range))) {}
+
   template <typename R, size_t X = internal::kComputedExtent<R>>
-    requires(internal::CompatibleRange<T, R> &&
-             internal::FixedExtentConstructibleFromExtent<N, X> &&
-             std::ranges::borrowed_range<R>)
+    requires(internal::LegacyCompatibleRange<T, R> &&
+             (X == N || X == dynamic_extent) &&
+             !internal::CompatibleRange<T, R>)
   // NOLINTNEXTLINE(google-explicit-constructor)
-  constexpr explicit(X != N) span(R&& range)
-      // SAFETY: `std::ranges::size()` returns the number of elements
-      // `std::ranges::data()` will point to, so accessing those elements will
-      // be safe.
+  explicit(X == dynamic_extent) constexpr span(R&& range) noexcept
+      // SAFETY: The std::ranges::size() function gives the number of elements
+      // pointed to by the std::ranges::data() function, which meets the
+      // requirement of span.
       : UNSAFE_BUFFERS(
             span(std::ranges::data(range), std::ranges::size(range))) {}
 
-  // NOLINTNEXTLINE(google-explicit-constructor)
-  constexpr explicit span(std::initializer_list<value_type> il LIFETIME_BOUND)
-    requires(std::is_const_v<T>)
-      // SAFETY: `size()` is exactly the number of elements in the initializer
-      // list, so accessing that many will be safe.
-      : UNSAFE_BUFFERS(span(il.begin(), il.size())) {}
-
   constexpr span(const span& other) noexcept = default;
   template <typename OtherT, size_t OtherN, typename OtherInternalPtrType>
     requires((OtherN == dynamic_extent || N == OtherN) &&
@@ -960,35 +968,33 @@ class GSL_POINTER span<T, dynamic_extent, InternalPtrType> {
 
   template <size_t N>
   // NOLINTNEXTLINE(google-explicit-constructor)
-  constexpr span(std::type_identity_t<T> (&arr LIFETIME_BOUND)[N]) noexcept
-      // SAFETY: The type signature guarantees `arr` contains `N` elements.
-      : UNSAFE_BUFFERS(span(arr, N)) {}
+  constexpr span(std::type_identity_t<T> (&arr)[N]) noexcept
+      // SAFETY: The std::ranges::size() function gives the number of elements
+      // pointed to by the std::ranges::data() function, which meets the
+      // requirement of span.
+      : UNSAFE_BUFFERS(span(std::ranges::data(arr), std::ranges::size(arr))) {}
 
   template <typename R>
     requires(internal::CompatibleRange<T, R>)
   // NOLINTNEXTLINE(google-explicit-constructor)
-  constexpr span(R&& range LIFETIME_BOUND)
+  constexpr span(R&& range) noexcept
       // SAFETY: `std::ranges::size()` returns the number of elements
       // `std::ranges::data()` will point to, so accessing those elements will
       // be safe.
       : UNSAFE_BUFFERS(
             span(std::ranges::data(range), std::ranges::size(range))) {}
+
   template <typename R>
-    requires(internal::CompatibleRange<T, R> && std::ranges::borrowed_range<R>)
+    requires(internal::LegacyCompatibleRange<T, R> &&
+             !internal::CompatibleRange<T, R>)
   // NOLINTNEXTLINE(google-explicit-constructor)
-  constexpr span(R&& range)
-      // SAFETY: `std::ranges::size()` returns the number of elements
-      // `std::ranges::data()` will point to, so accessing those elements will
-      // be safe.
+  constexpr span(R&& range) noexcept
+      // SAFETY: The std::ranges::size() function gives the number of elements
+      // pointed to by the std::ranges::data() function, which meets the
+      // requirement of span.
       : UNSAFE_BUFFERS(
             span(std::ranges::data(range), std::ranges::size(range))) {}
 
-  constexpr span(std::initializer_list<value_type> il LIFETIME_BOUND)
-    requires(std::is_const_v<T>)
-      // SAFETY: `size()` is exactly the number of elements in the initializer
-      // list, so accessing that many will be safe.
-      : UNSAFE_BUFFERS(span(il.begin(), il.size())) {}
-
   constexpr span(const span& other) noexcept = default;
   template <typename OtherT, size_t OtherN, typename OtherInternalPtrType>
     requires(internal::LegalDataConversion<OtherT, T>)
@@ -1550,14 +1556,8 @@ UNSAFE_BUFFER_USAGE constexpr auto make_span(It it, EndOrSize end_or_size) {
 // Deprecated: Use CTAD (i.e. use `span()` directly without template arguments).
 // TODO(crbug.com/341907909): Remove.
 template <int&... ExplicitArgumentBarrier, typename Container>
-  requires(internal::SpanConstructibleFrom<Container &&>)
-constexpr auto make_span(Container&& container LIFETIME_BOUND) {
-  return span(std::forward<Container>(container));
-}
-template <int&... ExplicitArgumentBarrier, typename Container>
-  requires(internal::SpanConstructibleFrom<Container &&> &&
-           std::ranges::borrowed_range<Container>)
-constexpr auto make_span(Container&& container) {
+  requires(internal::SpanConstructibleFrom<Container>)
+constexpr auto make_span(Container&& container) noexcept {
   return span(std::forward<Container>(container));
 }
 
@@ -1688,13 +1688,7 @@ constexpr span<const uint8_t, N> byte_span_with_nul_from_cstring(
 // or vector-like objects holding other scalar types, prior to passing them
 // into an API that requires byte spans.
 template <int&... ExplicitArgumentBarrier, typename Spannable>
-  requires(internal::SpanConstructibleFrom<const Spannable&>)
-constexpr auto as_byte_span(const Spannable& arg LIFETIME_BOUND) {
-  return as_bytes(span(arg));
-}
-template <int&... ExplicitArgumentBarrier, typename Spannable>
-  requires(internal::SpanConstructibleFrom<const Spannable&> &&
-           std::ranges::borrowed_range<Spannable>)
+  requires(internal::SpanConstructibleFrom<Spannable>)
 constexpr auto as_byte_span(const Spannable& arg) {
   return as_bytes(span(arg));
 }
-- 
2.47.0.277.g8800431eea-goog

