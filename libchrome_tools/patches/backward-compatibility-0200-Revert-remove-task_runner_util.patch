From c8953b0142e7c743d7a5e87f30aeda5425a7c9e6 Mon Sep 17 00:00:00 2001
From: Wei-Luan Wang <weiluanwang@google.com>
Date: Wed, 14 Dec 2022 03:20:40 +0000
Subject: [PATCH] backward compatibility: Revert remove task_runner_util

TODO(b/262468344): migrate the call sites.

This reverts commit 950ad63235d5ba1300510efee73e37bf4f8e7336.

Change-Id: I37630cc9834910ceb3ede140d4cdd0b1015ad62e
---
 base/task/task_runner_util.h           |  56 +++++++++
 base/task/task_runner_util_unittest.cc | 158 +++++++++++++++++++++++++
 2 files changed, 214 insertions(+)
 create mode 100644 base/task/task_runner_util.h
 create mode 100644 base/task/task_runner_util_unittest.cc

diff --git a/base/task/task_runner_util.h b/base/task/task_runner_util.h
new file mode 100644
index 0000000000..c28f8ce908
--- /dev/null
+++ b/base/task/task_runner_util.h
@@ -0,0 +1,56 @@
+// Copyright 2012 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_TASK_TASK_RUNNER_UTIL_H_
+#define BASE_TASK_TASK_RUNNER_UTIL_H_
+
+#include <memory>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/callback.h"
+#include "base/check.h"
+#include "base/task/post_task_and_reply_with_result_internal.h"
+#include "base/task/task_runner.h"
+
+namespace base {
+
+// When you have these methods
+//
+//   R DoWorkAndReturn();
+//   void Callback(const R& result);
+//
+// and want to call them in a PostTaskAndReply kind of fashion where the
+// result of DoWorkAndReturn is passed to the Callback, you can use
+// PostTaskAndReplyWithResult as in this example:
+//
+// PostTaskAndReplyWithResult(
+//     target_thread_.task_runner(),
+//     FROM_HERE,
+//     BindOnce(&DoWorkAndReturn),
+//     BindOnce(&Callback));
+//
+// DEPRECATED: Prefer calling|task_runner->PostTaskAndReplyWithResult(...)|
+// directly.
+// TODO(gab): Mass-migrate to the member method.
+template <typename TaskReturnType, typename ReplyArgType>
+bool PostTaskAndReplyWithResult(TaskRunner* task_runner,
+                                const Location& from_here,
+                                OnceCallback<TaskReturnType()> task,
+                                OnceCallback<void(ReplyArgType)> reply) {
+  DCHECK(task);
+  DCHECK(reply);
+  // std::unique_ptr used to avoid the need of a default constructor.
+  auto* result = new std::unique_ptr<TaskReturnType>();
+  return task_runner->PostTaskAndReply(
+      from_here,
+      BindOnce(&internal::ReturnAsParamAdapter<TaskReturnType>, std::move(task),
+               result),
+      BindOnce(&internal::ReplyAdapter<TaskReturnType, ReplyArgType>,
+               std::move(reply), Owned(result)));
+}
+
+}  // namespace base
+
+#endif  // BASE_TASK_TASK_RUNNER_UTIL_H_
diff --git a/base/task/task_runner_util_unittest.cc b/base/task/task_runner_util_unittest.cc
new file mode 100644
index 0000000000..3a9ce45459
--- /dev/null
+++ b/base/task/task_runner_util_unittest.cc
@@ -0,0 +1,158 @@
+// Copyright 2012 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/task/task_runner_util.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/location.h"
+#include "base/run_loop.h"
+#include "base/test/task_environment.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace base {
+
+namespace {
+
+int ReturnFourtyTwo() {
+  return 42;
+}
+
+void StoreValue(int* destination, int value) {
+  *destination = value;
+}
+
+void StoreDoubleValue(double* destination, double value) {
+  *destination = value;
+}
+
+int g_foo_destruct_count = 0;
+int g_foo_free_count = 0;
+
+struct Foo {
+  ~Foo() {
+    ++g_foo_destruct_count;
+  }
+};
+
+std::unique_ptr<Foo> CreateFoo() {
+  return std::make_unique<Foo>();
+}
+
+void ExpectFoo(std::unique_ptr<Foo> foo) {
+  EXPECT_TRUE(foo.get());
+  std::unique_ptr<Foo> local_foo(std::move(foo));
+  EXPECT_TRUE(local_foo.get());
+  EXPECT_FALSE(foo.get());
+}
+
+struct FooDeleter {
+  void operator()(Foo* foo) const {
+    ++g_foo_free_count;
+    delete foo;
+  }
+};
+
+std::unique_ptr<Foo, FooDeleter> CreateScopedFoo() {
+  return std::unique_ptr<Foo, FooDeleter>(new Foo);
+}
+
+void ExpectScopedFoo(std::unique_ptr<Foo, FooDeleter> foo) {
+  EXPECT_TRUE(foo.get());
+  std::unique_ptr<Foo, FooDeleter> local_foo(std::move(foo));
+  EXPECT_TRUE(local_foo.get());
+  EXPECT_FALSE(foo.get());
+}
+
+struct FooWithoutDefaultConstructor {
+  explicit FooWithoutDefaultConstructor(int value) : value(value) {}
+  int value;
+};
+
+FooWithoutDefaultConstructor CreateFooWithoutDefaultConstructor(int value) {
+  return FooWithoutDefaultConstructor(value);
+}
+
+void SaveFooWithoutDefaultConstructor(int* output_value,
+                                      FooWithoutDefaultConstructor input) {
+  *output_value = input.value;
+}
+
+}  // namespace
+
+TEST(TaskRunnerHelpersTest, PostTaskAndReplyWithResult) {
+  int result = 0;
+
+  test::TaskEnvironment task_environment;
+  PostTaskAndReplyWithResult(ThreadTaskRunnerHandle::Get().get(), FROM_HERE,
+                             BindOnce(&ReturnFourtyTwo),
+                             BindOnce(&StoreValue, &result));
+
+  RunLoop().RunUntilIdle();
+
+  EXPECT_EQ(42, result);
+}
+
+TEST(TaskRunnerHelpersTest, PostTaskAndReplyWithResultImplicitConvert) {
+  double result = 0;
+
+  test::TaskEnvironment task_environment;
+  PostTaskAndReplyWithResult(ThreadTaskRunnerHandle::Get().get(), FROM_HERE,
+                             BindOnce(&ReturnFourtyTwo),
+                             BindOnce(&StoreDoubleValue, &result));
+
+  RunLoop().RunUntilIdle();
+
+  EXPECT_DOUBLE_EQ(42.0, result);
+}
+
+TEST(TaskRunnerHelpersTest, PostTaskAndReplyWithResultPassed) {
+  g_foo_destruct_count = 0;
+  g_foo_free_count = 0;
+
+  test::TaskEnvironment task_environment;
+  PostTaskAndReplyWithResult(ThreadTaskRunnerHandle::Get().get(), FROM_HERE,
+                             BindOnce(&CreateFoo), BindOnce(&ExpectFoo));
+
+  RunLoop().RunUntilIdle();
+
+  EXPECT_EQ(1, g_foo_destruct_count);
+  EXPECT_EQ(0, g_foo_free_count);
+}
+
+TEST(TaskRunnerHelpersTest, PostTaskAndReplyWithResultPassedFreeProc) {
+  g_foo_destruct_count = 0;
+  g_foo_free_count = 0;
+
+  test::TaskEnvironment task_environment;
+  PostTaskAndReplyWithResult(ThreadTaskRunnerHandle::Get().get(), FROM_HERE,
+                             BindOnce(&CreateScopedFoo),
+                             BindOnce(&ExpectScopedFoo));
+
+  RunLoop().RunUntilIdle();
+
+  EXPECT_EQ(1, g_foo_destruct_count);
+  EXPECT_EQ(1, g_foo_free_count);
+}
+
+TEST(TaskRunnerHelpersTest,
+     PostTaskAndReplyWithResultWithoutDefaultConstructor) {
+  const int kSomeVal = 17;
+
+  test::TaskEnvironment task_environment;
+  int actual = 0;
+  PostTaskAndReplyWithResult(
+      ThreadTaskRunnerHandle::Get().get(), FROM_HERE,
+      BindOnce(&CreateFooWithoutDefaultConstructor, kSomeVal),
+      BindOnce(&SaveFooWithoutDefaultConstructor, &actual));
+
+  RunLoop().RunUntilIdle();
+
+  EXPECT_EQ(kSomeVal, actual);
+}
+
+}  // namespace base
-- 
2.39.0.rc1.256.g54fd8350bd-goog

