From 943f821220d48888e653c064a181ea021bc621e6 Mon Sep 17 00:00:00 2001
From: Cici Ruan <cuicuiruan@google.com>
Date: Tue, 17 Dec 2024 00:03:28 -0800
Subject: [PATCH] Revert "[base] Convert parts of base to std::atomic from
 atomicops"

This reverts commit da933f570719e7aac8a1c2240154f6ffac6a119b.

Change-Id: Id0b5599e76f7d198aa313df5e16fe4b2fc2906b8
---
 base/threading/thread_collision_warner.cc | 50 ++++++++++++++---------
 base/threading/thread_collision_warner.h  |  9 ++--
 2 files changed, 33 insertions(+), 26 deletions(-)

diff --git a/base/threading/thread_collision_warner.cc b/base/threading/thread_collision_warner.cc
index c99661e2b9..ee055c01e7 100644
--- a/base/threading/thread_collision_warner.cc
+++ b/base/threading/thread_collision_warner.cc
@@ -4,7 +4,6 @@
 
 #include "base/threading/thread_collision_warner.h"
 
-#include <atomic>
 #include <ostream>
 
 #include "base/notreached.h"
@@ -16,40 +15,51 @@ void DCheckAsserter::warn() {
   NOTREACHED() << "Thread Collision";
 }
 
+static subtle::Atomic32 CurrentThread() {
+  const PlatformThreadId current_thread_id = PlatformThread::CurrentId();
+  // We need to get the thread id into an atomic data type. This might be a
+  // truncating conversion, but any loss-of-information just increases the
+  // chance of a fault negative, not a false positive.
+  const subtle::Atomic32 atomic_thread_id =
+      static_cast<subtle::Atomic32>(current_thread_id);
+
+  return atomic_thread_id;
+}
+
 void ThreadCollisionWarner::EnterSelf() {
-  // If the active thread is kInvalidThreadId then I'll write the current thread
-  // ID if two or more threads arrive here only one will succeed to write on
-  // valid_thread_id_ the current thread ID.
-  PlatformThreadId current_thread_id = PlatformThread::CurrentId();
-  PlatformThreadId expected = kInvalidThreadId;
-
-  bool ok = valid_thread_id_.compare_exchange_strong(
-      expected, current_thread_id, std::memory_order_relaxed,
-      std::memory_order_relaxed);
-  if (!ok && expected != current_thread_id) {
+  // If the active thread is 0 then I'll write the current thread ID
+  // if two or more threads arrive here only one will succeed to
+  // write on valid_thread_id_ the current thread ID.
+  subtle::Atomic32 current_thread_id = CurrentThread();
+
+  int previous_value = subtle::NoBarrier_CompareAndSwap(&valid_thread_id_,
+                                                        0,
+                                                        current_thread_id);
+  if (previous_value != 0 && previous_value != current_thread_id) {
     // gotcha! a thread is trying to use the same class and that is
     // not current thread.
     asserter_->warn();
   }
-  counter_.fetch_add(1, std::memory_order_relaxed);
+
+  subtle::NoBarrier_AtomicIncrement(&counter_, 1);
 }
 
 void ThreadCollisionWarner::Enter() {
-  PlatformThreadId current_thread_id = PlatformThread::CurrentId();
-  PlatformThreadId expected = kInvalidThreadId;
+  subtle::Atomic32 current_thread_id = CurrentThread();
 
-  if (!valid_thread_id_.compare_exchange_strong(expected, current_thread_id,
-                                                std::memory_order_relaxed,
-                                                std::memory_order_relaxed)) {
+  if (subtle::NoBarrier_CompareAndSwap(&valid_thread_id_,
+                                       0,
+                                       current_thread_id) != 0) {
     // gotcha! another thread is trying to use the same class.
     asserter_->warn();
   }
-  counter_.fetch_add(1, std::memory_order_relaxed);
+
+  subtle::NoBarrier_AtomicIncrement(&counter_, 1);
 }
 
 void ThreadCollisionWarner::Leave() {
-  if (counter_.fetch_sub(1, std::memory_order_relaxed) == 1) {
-    valid_thread_id_.store(kInvalidThreadId, std::memory_order_relaxed);
+  if (subtle::Barrier_AtomicIncrement(&counter_, -1) == 0) {
+    subtle::NoBarrier_Store(&valid_thread_id_, 0);
   }
 }
 
diff --git a/base/threading/thread_collision_warner.h b/base/threading/thread_collision_warner.h
index b6795c5589..41d99b89ff 100644
--- a/base/threading/thread_collision_warner.h
+++ b/base/threading/thread_collision_warner.h
@@ -5,14 +5,12 @@
 #ifndef BASE_THREADING_THREAD_COLLISION_WARNER_H_
 #define BASE_THREADING_THREAD_COLLISION_WARNER_H_
 
-#include <atomic>
-
+#include "base/atomicops.h"
 #include "base/base_export.h"
 #include "base/compiler_specific.h"
 #include "base/dcheck_is_on.h"
 #include "base/macros/uniquify.h"
 #include "base/memory/raw_ptr.h"
-#include "base/threading/platform_thread.h"
 
 // A helper class alongside macros to be used to verify assumptions about thread
 // safety of a class.
@@ -233,12 +231,11 @@ class BASE_EXPORT ThreadCollisionWarner {
 
   // This stores the thread id that is inside the critical section, if the
   // value is 0 then no thread is inside.
-  std::atomic<PlatformThreadId> valid_thread_id_;
-  static_assert(std::atomic<PlatformThreadId>::is_always_lock_free, "");
+  volatile subtle::Atomic32 valid_thread_id_;
 
   // Counter to trace how many time a critical section was "pinned"
   // (when allowed) in order to unpin it when counter_ reaches 0.
-  std::atomic<uint32_t> counter_;
+  volatile subtle::Atomic32 counter_;
 
   // Here only for class unit tests purpose, during the test I need to not
   // DCHECK but notify the collision with something else.
-- 
2.47.1.613.gc27f4b7a9f-goog

