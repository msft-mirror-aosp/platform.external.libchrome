From 4c96ab074a0dca93f55238243b28324e725dd640 Mon Sep 17 00:00:00 2001
From: Georg Neis <neis@chromium.org>
Date: Wed, 27 Mar 2024 07:38:47 +0000
Subject: [PATCH] Revert most of "Return expected from ProcessMetrics CPU
 methods"

Revert commit 8876621b1da83510a41017d74302e030a6b4db98 except for the
additions to optional_util{.h,_unittest.cc}.

Change-Id: I634e20b20460e2120d7b83419376c1020b30e3b8
---
 base/process/process_metrics.cc          | 11 ++++----
 base/process/process_metrics.h           | 21 ++------------
 base/process/process_metrics_apple.cc    | 36 +++++++++---------------
 base/process/process_metrics_linux.cc    | 21 ++++++--------
 base/process/process_metrics_unittest.cc | 23 +++++++--------
 ipc/ipc_cpu_perftest.cc                  |  2 +-
 6 files changed, 43 insertions(+), 71 deletions(-)

diff --git a/base/process/process_metrics.cc b/base/process/process_metrics.cc
index 5bdcedb625..e9d90dcad8 100644
--- a/base/process/process_metrics.cc
+++ b/base/process/process_metrics.cc
@@ -123,11 +123,12 @@ double ProcessMetrics::GetPlatformIndependentCPUUsage(
   return 100.0 * cpu_time_delta / time_delta;
 }
 
-base::expected<double, ProcessCPUUsageError>
-ProcessMetrics::GetPlatformIndependentCPUUsage() {
-  return GetCumulativeCPUUsage().transform([this](base::TimeDelta cpu_usage) {
-    return GetPlatformIndependentCPUUsage(cpu_usage);
-  });
+std::optional<double> ProcessMetrics::GetPlatformIndependentCPUUsage() {
+  const std::optional<TimeDelta> cpu_usage = GetCumulativeCPUUsage();
+  if (!cpu_usage.has_value()) {
+    return std::nullopt;
+  }
+  return GetPlatformIndependentCPUUsage(cpu_usage.value());
 }
 #endif
 
diff --git a/base/process/process_metrics.h b/base/process/process_metrics.h
index 56bc320a62..db4ea9d024 100644
--- a/base/process/process_metrics.h
+++ b/base/process/process_metrics.h
@@ -12,6 +12,7 @@
 #include <stdint.h>
 
 #include <memory>
+#include <optional>
 
 #include "base/base_export.h"
 #include "base/gtest_prod_util.h"
@@ -19,7 +20,6 @@
 #include "base/process/process_handle.h"
 #include "base/strings/string_piece.h"
 #include "base/time/time.h"
-#include "base/types/expected.h"
 #include "base/values.h"
 #include "build/build_config.h"
 
@@ -64,19 +64,6 @@ struct PageFaultCounts {
 // Convert a POSIX timeval to microseconds.
 BASE_EXPORT int64_t TimeValToMicroseconds(const struct timeval& tv);
 
-enum class ProcessCPUUsageError {
-  // The OS returned an error while measuring the CPU usage. The possible causes
-  // vary by platform.
-  kSystemError,
-
-  // Process CPU usage couldn't be measured because the process wasn't running.
-  // Some platforms may return kSystemError instead in this situation.
-  kProcessNotFound,
-
-  // CPU usage measurement isn't implemented on this platform.
-  kNotImplemented,
-};
-
 // Provides performance metrics for a specified process (CPU usage and IO
 // counters). Use CreateCurrentProcessMetrics() to get an instance for the
 // current process, or CreateProcessMetrics() to get an instance for an
@@ -140,16 +127,14 @@ class BASE_EXPORT ProcessMetrics {
   // Same as the above, but automatically calls GetCumulativeCPUUsage() to
   // determine the current cumulative CPU. Returns nullopt if
   // GetCumulativeCPUUsage() fails.
-  [[nodiscard]] base::expected<double, ProcessCPUUsageError>
-  GetPlatformIndependentCPUUsage();
+  [[nodiscard]] std::optional<double> GetPlatformIndependentCPUUsage();
 
   // Returns the cumulative CPU usage across all threads of the process since
   // process start, or nullopt on error. In case of multi-core processors, a
   // process can consume CPU at a rate higher than wall-clock time, e.g. two
   // cores at full utilization will result in a time delta of 2 seconds/per 1
   // wall-clock second.
-  [[nodiscard]] base::expected<TimeDelta, ProcessCPUUsageError>
-  GetCumulativeCPUUsage();
+  [[nodiscard]] std::optional<TimeDelta> GetCumulativeCPUUsage();
 
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_ANDROID) || \
     BUILDFLAG(IS_AIX)
diff --git a/base/process/process_metrics_apple.cc b/base/process/process_metrics_apple.cc
index 9070d1ceee..685e0c4360 100644
--- a/base/process/process_metrics_apple.cc
+++ b/base/process/process_metrics_apple.cc
@@ -21,7 +21,6 @@
 #include "base/notimplemented.h"
 #include "base/numerics/safe_math.h"
 #include "base/time/time.h"
-#include "base/types/expected.h"
 #include "build/build_config.h"
 
 #if BUILDFLAG(IS_MAC)
@@ -45,21 +44,16 @@ namespace base {
 
 namespace {
 
-base::expected<task_basic_info_64, ProcessCPUUsageError> GetTaskInfo(
-    mach_port_t task) {
+bool GetTaskInfo(mach_port_t task, task_basic_info_64* task_info_data) {
   if (task == MACH_PORT_NULL) {
-    return base::unexpected(ProcessCPUUsageError::kProcessNotFound);
+    return false;
   }
-  task_basic_info_64 task_info_data{};
   mach_msg_type_number_t count = TASK_BASIC_INFO_64_COUNT;
   kern_return_t kr =
       task_info(task, TASK_BASIC_INFO_64,
-                reinterpret_cast<task_info_t>(&task_info_data), &count);
+                reinterpret_cast<task_info_t>(task_info_data), &count);
   // Most likely cause for failure: |task| is a zombie.
-  if (kr != KERN_SUCCESS) {
-    return base::unexpected(ProcessCPUUsageError::kSystemError);
-  }
-  return base::ok(task_info_data);
+  return kr == KERN_SUCCESS;
 }
 
 MachVMRegionResult ParseOutputFromMachVMRegion(kern_return_t kr) {
@@ -101,11 +95,10 @@ mach_port_t ProcessMetrics::TaskForHandle(ProcessHandle process_handle) const {
   return task;
 }
 
-base::expected<TimeDelta, ProcessCPUUsageError>
-ProcessMetrics::GetCumulativeCPUUsage() {
+std::optional<TimeDelta> ProcessMetrics::GetCumulativeCPUUsage() {
   mach_port_t task = TaskForHandle(process_);
   if (task == MACH_PORT_NULL) {
-    return base::unexpected(ProcessCPUUsageError::kProcessNotFound);
+    return std::nullopt;
   }
 
   // Libtop explicitly loops over the threads (libtop_pinfo_update_cpu_usage()
@@ -117,13 +110,12 @@ ProcessMetrics::GetCumulativeCPUUsage() {
                                &thread_info_count);
   if (kr != KERN_SUCCESS) {
     // Most likely cause: |task| is a zombie.
-    return base::unexpected(ProcessCPUUsageError::kSystemError);
+    return std::nullopt;
   }
 
-  const base::expected<task_basic_info_64, ProcessCPUUsageError>
-      task_info_data = GetTaskInfo(task);
-  if (!task_info_data.has_value()) {
-    return base::unexpected(task_info_data.error());
+  task_basic_info_64 task_info_data;
+  if (!GetTaskInfo(task, &task_info_data)) {
+    return std::nullopt;
   }
 
   /* Set total_time. */
@@ -134,8 +126,8 @@ ProcessMetrics::GetCumulativeCPUUsage() {
   timeradd(&user_timeval, &system_timeval, &task_timeval);
 
   // ... task info contains terminated time.
-  TIME_VALUE_TO_TIMEVAL(&task_info_data->user_time, &user_timeval);
-  TIME_VALUE_TO_TIMEVAL(&task_info_data->system_time, &system_timeval);
+  TIME_VALUE_TO_TIMEVAL(&task_info_data.user_time, &user_timeval);
+  TIME_VALUE_TO_TIMEVAL(&task_info_data.system_time, &system_timeval);
   timeradd(&user_timeval, &task_timeval, &task_timeval);
   timeradd(&system_timeval, &task_timeval, &task_timeval);
 
@@ -147,10 +139,10 @@ ProcessMetrics::GetCumulativeCPUUsage() {
     // a lag before it shows up in the terminated thread times returned by
     // GetTaskInfo(). Make sure CPU usage doesn't appear to go backwards if
     // GetCumulativeCPUUsage() is called in the interval.
-    return base::ok(last_measured_cpu_);
+    return std::optional(last_measured_cpu_);
   }
   last_measured_cpu_ = measured_cpu;
-  return base::ok(measured_cpu);
+  return std::optional(measured_cpu);
 }
 
 int ProcessMetrics::GetPackageIdleWakeupsPerSecond() {
diff --git a/base/process/process_metrics_linux.cc b/base/process/process_metrics_linux.cc
index 501f2fb741..8d4ab37cf4 100644
--- a/base/process/process_metrics_linux.cc
+++ b/base/process/process_metrics_linux.cc
@@ -35,7 +35,6 @@
 #include "base/strings/string_util.h"
 #include "base/system/sys_info.h"
 #include "base/threading/thread_restrictions.h"
-#include "base/types/expected.h"
 #include "base/values.h"
 #include "build/build_config.h"
 #include "third_party/abseil-cpp/absl/strings/ascii.h"
@@ -60,27 +59,26 @@ uint64_t ReadFileToUint64(const FilePath& file) {
 }
 #endif
 
-// Get the total CPU from a proc stat buffer. Return value is a TimeDelta
-// converted from a number of jiffies on success or an error code if parsing
-// failed.
-base::expected<TimeDelta, ProcessCPUUsageError> ParseTotalCPUTimeFromStats(
+// Get the total CPU from a proc stat buffer.  Return value is a TimeDelta
+// converted from a number of jiffies on success or nullopt if parsing failed.
+std::optional<TimeDelta> ParseTotalCPUTimeFromStats(
     base::span<const std::string> proc_stats) {
   const std::optional<int64_t> utime =
       internal::GetProcStatsFieldAsOptionalInt64(proc_stats,
                                                  internal::VM_UTIME);
   if (utime.value_or(-1) < 0) {
-    return base::unexpected(ProcessCPUUsageError::kSystemError);
+    return std::nullopt;
   }
   const std::optional<int64_t> stime =
       internal::GetProcStatsFieldAsOptionalInt64(proc_stats,
                                                  internal::VM_UTIME);
   if (stime.value_or(-1) < 0) {
-    return base::unexpected(ProcessCPUUsageError::kSystemError);
+    return std::nullopt;
   }
   const TimeDelta cpu_time = internal::ClockTicksToTimeDelta(
       base::ClampAdd(utime.value(), stime.value()));
   CHECK(!cpu_time.is_negative());
-  return base::ok(cpu_time);
+  return std::optional(cpu_time);
 }
 
 }  // namespace
@@ -96,13 +94,12 @@ size_t ProcessMetrics::GetResidentSetSize() const {
          checked_cast<size_t>(getpagesize());
 }
 
-base::expected<TimeDelta, ProcessCPUUsageError>
-ProcessMetrics::GetCumulativeCPUUsage() {
+std::optional<TimeDelta> ProcessMetrics::GetCumulativeCPUUsage() {
   std::string buffer;
   std::vector<std::string> proc_stats;
   if (!internal::ReadProcStats(process_, &buffer) ||
       !internal::ParseProcStats(buffer, &proc_stats)) {
-    return base::unexpected(ProcessCPUUsageError::kSystemError);
+    return std::nullopt;
   }
 
   return ParseTotalCPUTimeFromStats(proc_stats);
@@ -124,7 +121,7 @@ bool ProcessMetrics::GetCumulativeCPUUsagePerThread(
           return;
         }
 
-        const base::expected<TimeDelta, ProcessCPUUsageError> thread_time =
+        const std::optional<TimeDelta> thread_time =
             ParseTotalCPUTimeFromStats(proc_stats);
         if (thread_time.has_value()) {
           cpu_per_thread.emplace_back(tid, thread_time.value());
diff --git a/base/process/process_metrics_unittest.cc b/base/process/process_metrics_unittest.cc
index 5ee7d9916a..230d22499e 100644
--- a/base/process/process_metrics_unittest.cc
+++ b/base/process/process_metrics_unittest.cc
@@ -8,6 +8,7 @@
 #include <stdint.h>
 
 #include <memory>
+#include <optional>
 #include <sstream>
 #include <string>
 #include <utility>
@@ -29,12 +30,10 @@
 #include "base/strings/string_util.h"
 #include "base/strings/stringprintf.h"
 #include "base/system/sys_info.h"
-#include "base/test/gmock_expected_support.h"
 #include "base/test/gtest_util.h"
 #include "base/test/multiprocess_test.h"
 #include "base/test/test_timeouts.h"
 #include "base/threading/thread.h"
-#include "base/types/expected.h"
 #include "build/blink_buildflags.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
@@ -67,13 +66,11 @@ namespace base::debug {
 
 namespace {
 
-using base::test::ErrorIs;
-using base::test::ValueIs;
-using ::testing::_;
 using ::testing::AssertionFailure;
 using ::testing::AssertionResult;
 using ::testing::AssertionSuccess;
 using ::testing::Ge;
+using ::testing::Optional;
 
 #if ENABLE_CPU_TESTS
 
@@ -91,10 +88,10 @@ void BusyWork(std::vector<std::string>* vec) {
 // returns an empty TimeDelta so that each test doesn't need to check for
 // nullopt repeatedly.
 TimeDelta TestCumulativeCPU(ProcessMetrics* metrics, TimeDelta prev_cpu_usage) {
-  const base::expected<TimeDelta, ProcessCPUUsageError> current_cpu_usage =
+  const std::optional<TimeDelta> current_cpu_usage =
       metrics->GetCumulativeCPUUsage();
-  EXPECT_THAT(current_cpu_usage, ValueIs(Ge(prev_cpu_usage)));
-  EXPECT_THAT(metrics->GetPlatformIndependentCPUUsage(), ValueIs(Ge(0.0)));
+  EXPECT_THAT(current_cpu_usage, Optional(Ge(prev_cpu_usage)));
+  EXPECT_THAT(metrics->GetPlatformIndependentCPUUsage(), Optional(Ge(0.0)));
   return current_cpu_usage.value_or(TimeDelta());
 }
 
@@ -637,7 +634,7 @@ TEST_F(SystemMetricsTest, TestNoNegativeCpuUsage) {
   std::unique_ptr<ProcessMetrics> metrics =
       ProcessMetrics::CreateCurrentProcessMetrics();
 
-  EXPECT_THAT(metrics->GetPlatformIndependentCPUUsage(), ValueIs(Ge(0.0)));
+  EXPECT_THAT(metrics->GetPlatformIndependentCPUUsage(), Optional(Ge(0.0)));
 
   Thread thread1("thread1");
   Thread thread2("thread2");
@@ -702,8 +699,8 @@ TEST_F(SystemMetricsTest, MeasureChildCpuUsage) {
   TestCumulativeCPU(metrics.get(), cpu_usage2);
 #else
   // All other platforms return an error.
-  EXPECT_THAT(metrics->GetCumulativeCPUUsage(), ErrorIs(_));
-  EXPECT_THAT(metrics->GetPlatformIndependentCPUUsage(), ErrorIs(_));
+  EXPECT_EQ(metrics->GetCumulativeCPUUsage(), std::nullopt);
+  EXPECT_EQ(metrics->GetPlatformIndependentCPUUsage(), std::nullopt);
 #endif
 }
 
@@ -717,8 +714,8 @@ TEST_F(SystemMetricsTest, InvalidProcessCpuUsage) {
   std::unique_ptr<ProcessMetrics> metrics =
       ProcessMetrics::CreateProcessMetrics(kNullProcessHandle);
 #endif
-  EXPECT_THAT(metrics->GetCumulativeCPUUsage(), ErrorIs(_));
-  EXPECT_THAT(metrics->GetPlatformIndependentCPUUsage(), ErrorIs(_));
+  EXPECT_EQ(metrics->GetCumulativeCPUUsage(), std::nullopt);
+  EXPECT_EQ(metrics->GetPlatformIndependentCPUUsage(), std::nullopt);
 }
 
 #endif  // ENABLE_CPU_TESTS
diff --git a/ipc/ipc_cpu_perftest.cc b/ipc/ipc_cpu_perftest.cc
index cc5a464652..dacbdc987b 100644
--- a/ipc/ipc_cpu_perftest.cc
+++ b/ipc/ipc_cpu_perftest.cc
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include <memory>
+#include <optional>
 #include <string_view>
 #include <tuple>
 
@@ -17,7 +18,6 @@
 #include "base/test/perf_log.h"
 #include "base/test/task_environment.h"
 #include "base/timer/timer.h"
-#include "base/types/expected.h"
 #include "ipc/ipc_channel_proxy.h"
 #include "ipc/ipc_perftest_messages.h"
 #include "ipc/ipc_perftest_util.h"
-- 
2.44.0.478.gd926399ef9-goog

