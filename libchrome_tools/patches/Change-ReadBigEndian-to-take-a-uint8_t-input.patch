From 11d5fb324800fec4480c71170ecf6c9dace7216e Mon Sep 17 00:00:00 2001
From: Felix Weilbach <feweilbach@gmail.com>
Date: Wed, 17 Nov 2021 10:42:45 -0800
Subject: [PATCH] Change ReadBigEndian to take a uint8_t* input

ReadBigEndian() is interpreting the input as bytes not as characters
(e.g. UTF-8). Therefore it makes sense that ReadBidEndian() gets the
input as uint8_t.

Bug: 1219110
Change-Id: If44ae3e420be49b50e157529b024accb9699da21
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3184459
Reviewed-by: Robert Sesek <rsesek@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Tommi <tommi@chromium.org>
Commit-Queue: Daniel Cheng <dcheng@chromium.org>
Owners-Override: Daniel Cheng <dcheng@chromium.org>
Cr-Commit-Position: refs/heads/main@{#942723}


CrOS-Libchrome-Original-Commit: b7f34d81f8ead36200b8882389d9f892946d4713
---
 base/big_endian.cc          | 24 +++++++++++++---
 base/big_endian.h           | 27 ++++++++++--------
 base/big_endian_unittest.cc | 55 +++++++++++++++++++------------------
 3 files changed, 65 insertions(+), 41 deletions(-)

diff --git a/base/big_endian.cc b/base/big_endian.cc
index ad6a1016ed..e1142163aa 100644
--- a/base/big_endian.cc
+++ b/base/big_endian.cc
@@ -11,9 +11,17 @@
 
 namespace base {
 
-BigEndianReader::BigEndianReader(const char* buf, size_t len)
+BigEndianReader BigEndianReader::FromStringPiece(
+    base::StringPiece string_piece) {
+  return BigEndianReader(base::as_bytes(base::make_span(string_piece)));
+}
+
+BigEndianReader::BigEndianReader(const uint8_t* buf, size_t len)
     : ptr_(buf), end_(ptr_ + len) {}
 
+BigEndianReader::BigEndianReader(base::span<const uint8_t> buf)
+    : ptr_(buf.data()), end_(buf.data() + buf.size()) {}
+
 bool BigEndianReader::Skip(size_t len) {
   if (len > remaining())
     return false;
@@ -32,7 +40,15 @@ bool BigEndianReader::ReadBytes(void* out, size_t len) {
 bool BigEndianReader::ReadPiece(base::StringPiece* out, size_t len) {
   if (len > remaining())
     return false;
-  *out = base::StringPiece(ptr_, len);
+  *out = base::StringPiece(reinterpret_cast<const char*>(ptr_), len);
+  ptr_ += len;
+  return true;
+}
+
+bool BigEndianReader::ReadSpan(base::span<const uint8_t>* out, size_t len) {
+  if (len > remaining())
+    return false;
+  *out = base::make_span(ptr_, len);
   ptr_ += len;
   return true;
 }
@@ -68,12 +84,12 @@ bool BigEndianReader::ReadLengthPrefixed(base::StringPiece* out) {
   if (!Read(&t_len))
     return false;
   size_t len = strict_cast<size_t>(t_len);
-  const char* original_ptr = ptr_;
+  const uint8_t* original_ptr = ptr_;
   if (!Skip(len)) {
     ptr_ -= sizeof(T);
     return false;
   }
-  *out = base::StringPiece(original_ptr, len);
+  *out = base::StringPiece(reinterpret_cast<const char*>(original_ptr), len);
   return true;
 }
 
diff --git a/base/big_endian.h b/base/big_endian.h
index 13a0b9ba4c..53bac4a3c1 100644
--- a/base/big_endian.h
+++ b/base/big_endian.h
@@ -10,6 +10,7 @@
 #include <type_traits>
 
 #include "base/base_export.h"
+#include "base/containers/span.h"
 #include "base/strings/string_piece.h"
 
 namespace base {
@@ -19,17 +20,16 @@ namespace base {
 // NOTE(szym): glibc dns-canon.c use ntohs(*(uint16_t*)ptr) which is
 // potentially unaligned.
 // This would cause SIGBUS on ARMv5 or earlier and ARMv6-M.
-template<typename T>
-inline void ReadBigEndian(const char buf[], T* out) {
+template <typename T>
+inline void ReadBigEndian(const uint8_t buf[], T* out) {
   static_assert(std::is_integral<T>::value, "T has to be an integral type.");
   // Make an unsigned version of the output type to make shift possible
   // without UB.
-  typename std::make_unsigned<T>::type unsigned_result =
-      static_cast<uint8_t>(buf[0]);
+  typename std::make_unsigned<T>::type unsigned_result = buf[0];
   for (size_t i = 1; i < sizeof(T); ++i) {
     unsigned_result <<= 8;
     // Must cast to uint8_t to avoid clobbering by sign extension.
-    unsigned_result |= static_cast<uint8_t>(buf[i]);
+    unsigned_result |= buf[i];
   }
   *out = unsigned_result;
 }
@@ -48,7 +48,7 @@ inline void WriteBigEndian(char buf[], T val) {
 
 // Specializations to make clang happy about the (dead code) shifts above.
 template <>
-inline void ReadBigEndian<uint8_t>(const char buf[], uint8_t* out) {
+inline void ReadBigEndian<uint8_t>(const uint8_t buf[], uint8_t* out) {
   *out = buf[0];
 }
 
@@ -58,7 +58,7 @@ inline void WriteBigEndian<uint8_t>(char buf[], uint8_t val) {
 }
 
 template <>
-inline void ReadBigEndian<int8_t>(const char buf[], int8_t* out) {
+inline void ReadBigEndian<int8_t>(const uint8_t buf[], int8_t* out) {
   *out = buf[0];
 }
 
@@ -71,15 +71,20 @@ inline void WriteBigEndian<int8_t>(char buf[], int8_t val) {
 // an underlying buffer. All the reading functions advance the internal pointer.
 class BASE_EXPORT BigEndianReader {
  public:
-  BigEndianReader(const char* buf, size_t len);
+  static BigEndianReader FromStringPiece(base::StringPiece string_piece);
+
+  BigEndianReader(const uint8_t* buf, size_t len);
+  explicit BigEndianReader(base::span<const uint8_t> buf);
 
-  const char* ptr() const { return ptr_; }
+  const uint8_t* ptr() const { return ptr_; }
   size_t remaining() const { return end_ - ptr_; }
 
   bool Skip(size_t len);
   bool ReadBytes(void* out, size_t len);
   // Creates a StringPiece in |out| that points to the underlying buffer.
   bool ReadPiece(base::StringPiece* out, size_t len);
+  bool ReadSpan(base::span<const uint8_t>* out, size_t len);
+
   bool ReadU8(uint8_t* value);
   bool ReadU16(uint16_t* value);
   bool ReadU32(uint32_t* value);
@@ -106,8 +111,8 @@ class BASE_EXPORT BigEndianReader {
   template <typename T>
   bool ReadLengthPrefixed(base::StringPiece* out);
 
-  const char* ptr_;
-  const char* end_;
+  const uint8_t* ptr_;
+  const uint8_t* end_;
 };
 
 // Allows writing integers in network order (big endian) while iterating over
diff --git a/base/big_endian_unittest.cc b/base/big_endian_unittest.cc
index 7f73ab135d..00aef35d62 100644
--- a/base/big_endian_unittest.cc
+++ b/base/big_endian_unittest.cc
@@ -14,7 +14,7 @@
 namespace base {
 
 TEST(ReadBigEndianTest, ReadSignedPositive) {
-  char data[] = {0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x1A, 0x2A};
+  uint8_t data[] = {0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x1A, 0x2A};
   int8_t s8 = 0;
   int16_t s16 = 0;
   int32_t s32 = 0;
@@ -35,10 +35,10 @@ TEST(ReadBigEndianTest, ReadSignedNegative) {
   int16_t s16 = 0;
   int32_t s32 = 0;
   int64_t s64 = 0;
-  ReadBigEndian(reinterpret_cast<const char*>(data), &s8);
-  ReadBigEndian(reinterpret_cast<const char*>(data), &s16);
-  ReadBigEndian(reinterpret_cast<const char*>(data), &s32);
-  ReadBigEndian(reinterpret_cast<const char*>(data), &s64);
+  ReadBigEndian(data, &s8);
+  ReadBigEndian(data, &s16);
+  ReadBigEndian(data, &s32);
+  ReadBigEndian(data, &s64);
   EXPECT_EQ(-1, s8);
   EXPECT_EQ(-1, s16);
   EXPECT_EQ(-1, s32);
@@ -51,10 +51,10 @@ TEST(ReadBigEndianTest, ReadUnsignedSigned) {
   uint16_t u16 = 0;
   uint32_t u32 = 0;
   uint64_t u64 = 0;
-  ReadBigEndian(reinterpret_cast<const char*>(data), &u8);
-  ReadBigEndian(reinterpret_cast<const char*>(data), &u16);
-  ReadBigEndian(reinterpret_cast<const char*>(data), &u32);
-  ReadBigEndian(reinterpret_cast<const char*>(data), &u64);
+  ReadBigEndian(data, &u8);
+  ReadBigEndian(data, &u16);
+  ReadBigEndian(data, &u32);
+  ReadBigEndian(data, &u64);
   EXPECT_EQ(0xA0, u8);
   EXPECT_EQ(0xA0B0, u16);
   EXPECT_EQ(0xA0B0C0D0, u32);
@@ -63,20 +63,20 @@ TEST(ReadBigEndianTest, ReadUnsignedSigned) {
 
 TEST(ReadBigEndianTest, TryAll16BitValues) {
   using signed_type = int16_t;
-  char data[sizeof(signed_type)];
+  uint8_t data[sizeof(signed_type)];
   for (int i = std::numeric_limits<signed_type>::min();
        i <= std::numeric_limits<signed_type>::max(); i++) {
     signed_type expected = i;
     signed_type actual = 0;
-    WriteBigEndian(data, expected);
+    WriteBigEndian(reinterpret_cast<char*>(data), expected);
     ReadBigEndian(data, &actual);
     EXPECT_EQ(expected, actual);
   }
 }
 
 TEST(BigEndianReaderTest, ReadsValues) {
-  char data[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF,
-                  0x1A, 0x2B, 0x3C, 0x4D, 0x5E };
+  uint8_t data[] = {0,   1,   2,   3,   4,   5,    6,    7,    8,    9,   0xA,
+                    0xB, 0xC, 0xD, 0xE, 0xF, 0x1A, 0x2B, 0x3C, 0x4D, 0x5E};
   char buf[2];
   uint8_t u8;
   uint16_t u16;
@@ -99,7 +99,7 @@ TEST(BigEndianReaderTest, ReadsValues) {
   EXPECT_EQ(0x0708090Au, u32);
   EXPECT_TRUE(reader.ReadU64(&u64));
   EXPECT_EQ(0x0B0C0D0E0F1A2B3Cllu, u64);
-  base::StringPiece expected(reader.ptr(), 2);
+  base::StringPiece expected(reinterpret_cast<const char*>(reader.ptr()), 2);
   EXPECT_TRUE(reader.ReadPiece(&piece, 2));
   EXPECT_EQ(2u, piece.size());
   EXPECT_EQ(expected.data(), piece.data());
@@ -107,8 +107,8 @@ TEST(BigEndianReaderTest, ReadsValues) {
 
 TEST(BigEndianReaderTest, ReadsLengthPrefixedValues) {
   {
-    char u8_prefixed_data[] = {8,   8,   9,    0xA,  0xB,  0xC,  0xD,
-                               0xE, 0xF, 0x1A, 0x2B, 0x3C, 0x4D, 0x5E};
+    uint8_t u8_prefixed_data[] = {8,   8,   9,    0xA,  0xB,  0xC,  0xD,
+                                  0xE, 0xF, 0x1A, 0x2B, 0x3C, 0x4D, 0x5E};
     BigEndianReader reader(u8_prefixed_data, sizeof(u8_prefixed_data));
 
     base::StringPiece piece;
@@ -116,19 +116,21 @@ TEST(BigEndianReaderTest, ReadsLengthPrefixedValues) {
     // |reader| should skip both a u8 and the length-8 length-prefixed field.
     EXPECT_EQ(reader.ptr(), u8_prefixed_data + 9);
     EXPECT_EQ(piece.size(), 8u);
-    EXPECT_EQ(piece.data(), u8_prefixed_data + 1);
+    EXPECT_EQ(reinterpret_cast<const uint8_t*>(piece.data()),
+              u8_prefixed_data + 1);
   }
 
   {
-    char u16_prefixed_data[] = {0,    8,    0xD,  0xE,  0xF,
-                                0x1A, 0x2B, 0x3C, 0x4D, 0x5E};
+    uint8_t u16_prefixed_data[] = {0,    8,    0xD,  0xE,  0xF,
+                                   0x1A, 0x2B, 0x3C, 0x4D, 0x5E};
     BigEndianReader reader(u16_prefixed_data, sizeof(u16_prefixed_data));
     base::StringPiece piece;
     ASSERT_TRUE(reader.ReadU16LengthPrefixed(&piece));
     // |reader| should skip both a u16 and the length-8 length-prefixed field.
     EXPECT_EQ(reader.ptr(), u16_prefixed_data + 10);
     EXPECT_EQ(piece.size(), 8u);
-    EXPECT_EQ(piece.data(), u16_prefixed_data + 2);
+    EXPECT_EQ(reinterpret_cast<const uint8_t*>(piece.data()),
+              u16_prefixed_data + 2);
 
     // With no data left, we shouldn't be able to
     // read another u8 length prefix (or a u16 length prefix,
@@ -139,12 +141,13 @@ TEST(BigEndianReaderTest, ReadsLengthPrefixedValues) {
 
   {
     // Make sure there's no issue reading a zero-value length prefix.
-    char u16_prefixed_data[3] = {};
+    uint8_t u16_prefixed_data[3] = {};
     BigEndianReader reader(u16_prefixed_data, sizeof(u16_prefixed_data));
     base::StringPiece piece;
     ASSERT_TRUE(reader.ReadU16LengthPrefixed(&piece));
     EXPECT_EQ(reader.ptr(), u16_prefixed_data + 2);
-    EXPECT_EQ(piece.data(), u16_prefixed_data + 2);
+    EXPECT_EQ(reinterpret_cast<const uint8_t*>(piece.data()),
+              u16_prefixed_data + 2);
     EXPECT_EQ(piece.size(), 0u);
   }
 }
@@ -152,8 +155,8 @@ TEST(BigEndianReaderTest, ReadsLengthPrefixedValues) {
 TEST(BigEndianReaderTest, LengthPrefixedReadsFailGracefully) {
   // We can't read 0xF (or, for that matter, 0xF8) bytes after the length
   // prefix: there isn't enough data.
-  char data[] = {0xF, 8,   9,    0xA,  0xB,  0xC,  0xD,
-                 0xE, 0xF, 0x1A, 0x2B, 0x3C, 0x4D, 0x5E};
+  uint8_t data[] = {0xF, 8,   9,    0xA,  0xB,  0xC,  0xD,
+                    0xE, 0xF, 0x1A, 0x2B, 0x3C, 0x4D, 0x5E};
   BigEndianReader reader(data, sizeof(data));
   base::StringPiece piece;
   EXPECT_FALSE(reader.ReadU8LengthPrefixed(&piece));
@@ -164,7 +167,7 @@ TEST(BigEndianReaderTest, LengthPrefixedReadsFailGracefully) {
 }
 
 TEST(BigEndianReaderTest, RespectsLength) {
-  char data[8];
+  uint8_t data[8];
   char buf[2];
   uint8_t u8;
   uint16_t u16;
@@ -192,7 +195,7 @@ TEST(BigEndianReaderTest, RespectsLength) {
 }
 
 TEST(BigEndianReaderTest, SafePointerMath) {
-  char data[] = "foo";
+  uint8_t data[] = "foo";
   BigEndianReader reader(data, sizeof(data));
   // The test should fail without ever dereferencing the |dummy_buf| pointer.
   char* dummy_buf = reinterpret_cast<char*>(0xdeadbeef);
-- 
2.35.1.616.g0bdcbb4464-goog

