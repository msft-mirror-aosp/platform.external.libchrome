From d282f20fb5505e33d3d13fe8fa322ec310e58a06 Mon Sep 17 00:00:00 2001
From: Nathan Muggli <nmuggli@google.com>
Date: Tue, 4 Apr 2023 10:51:19 -0600
Subject: [PATCH] Revert "Remove Value::DictItems(), replacing it with
 Value::GetDict()."

This reverts commit 93274aed96240ac1d33cfc1d99564b67091d8222.
---
 base/value_iterators.cc                       | 110 ++++++++++++++++++
 base/value_iterators.h                        |  78 +++++++++++++
 base/value_iterators_unittest.cc              |  66 +++++++++++
 base/values.cc                                |   8 ++
 base/values.h                                 |  20 ++++
 base/values_unittest.cc                       |   3 +-
 .../policy_loader_command_line_unittest.cc    |   2 +-
 mojo/public/cpp/base/values_mojom_traits.h    |  25 ++++
 8 files changed, 310 insertions(+), 2 deletions(-)

diff --git a/base/value_iterators.cc b/base/value_iterators.cc
index b408ec2eb8..583c8ca64c 100644
--- a/base/value_iterators.cc
+++ b/base/value_iterators.cc
@@ -123,6 +123,116 @@ bool operator!=(const const_dict_iterator& lhs,
   return !(lhs == rhs);
 }
 
+// ----------------------------------------------------------------------------
+// dict_iterator_proxy.
+
+dict_iterator_proxy::dict_iterator_proxy(DictStorage* storage)
+    : storage_(storage) {}
+
+dict_iterator_proxy::size_type dict_iterator_proxy::size() const {
+  return storage_->size();
+}
+
+dict_iterator_proxy::iterator dict_iterator_proxy::begin() {
+  return iterator(storage_->begin());
+}
+
+dict_iterator_proxy::const_iterator dict_iterator_proxy::begin() const {
+  return const_iterator(storage_->begin());
+}
+
+dict_iterator_proxy::iterator dict_iterator_proxy::end() {
+  return iterator(storage_->end());
+}
+
+dict_iterator_proxy::const_iterator dict_iterator_proxy::end() const {
+  return const_iterator(storage_->end());
+}
+
+dict_iterator_proxy::reverse_iterator dict_iterator_proxy::rbegin() {
+  return reverse_iterator(end());
+}
+
+dict_iterator_proxy::const_reverse_iterator dict_iterator_proxy::rbegin()
+    const {
+  return const_reverse_iterator(end());
+}
+
+dict_iterator_proxy::reverse_iterator dict_iterator_proxy::rend() {
+  return reverse_iterator(begin());
+}
+
+dict_iterator_proxy::const_reverse_iterator dict_iterator_proxy::rend() const {
+  return const_reverse_iterator(begin());
+}
+
+dict_iterator_proxy::const_iterator dict_iterator_proxy::cbegin() const {
+  return const_iterator(begin());
+}
+
+dict_iterator_proxy::const_iterator dict_iterator_proxy::cend() const {
+  return const_iterator(end());
+}
+
+dict_iterator_proxy::const_reverse_iterator dict_iterator_proxy::crbegin()
+    const {
+  return const_reverse_iterator(rbegin());
+}
+
+dict_iterator_proxy::const_reverse_iterator dict_iterator_proxy::crend() const {
+  return const_reverse_iterator(rend());
+}
+
+// ----------------------------------------------------------------------------
+// const_dict_iterator_proxy.
+
+const_dict_iterator_proxy::const_dict_iterator_proxy(const DictStorage* storage)
+    : storage_(storage) {}
+
+const_dict_iterator_proxy::const_iterator const_dict_iterator_proxy::begin()
+    const {
+  return const_iterator(storage_->begin());
+}
+
+const_dict_iterator_proxy::size_type const_dict_iterator_proxy::size() const {
+  return storage_->size();
+}
+
+const_dict_iterator_proxy::const_iterator const_dict_iterator_proxy::end()
+    const {
+  return const_iterator(storage_->end());
+}
+
+const_dict_iterator_proxy::const_reverse_iterator
+const_dict_iterator_proxy::rbegin() const {
+  return const_reverse_iterator(end());
+}
+
+const_dict_iterator_proxy::const_reverse_iterator
+const_dict_iterator_proxy::rend() const {
+  return const_reverse_iterator(begin());
+}
+
+const_dict_iterator_proxy::const_iterator const_dict_iterator_proxy::cbegin()
+    const {
+  return const_iterator(begin());
+}
+
+const_dict_iterator_proxy::const_iterator const_dict_iterator_proxy::cend()
+    const {
+  return const_iterator(end());
+}
+
+const_dict_iterator_proxy::const_reverse_iterator
+const_dict_iterator_proxy::crbegin() const {
+  return const_reverse_iterator(rbegin());
+}
+
+const_dict_iterator_proxy::const_reverse_iterator
+const_dict_iterator_proxy::crend() const {
+  return const_reverse_iterator(rend());
+}
+
 }  // namespace detail
 
 }  // namespace base
diff --git a/base/value_iterators.h b/base/value_iterators.h
index 8f854c2f10..f10f186889 100644
--- a/base/value_iterators.h
+++ b/base/value_iterators.h
@@ -129,6 +129,84 @@ class BASE_EXPORT const_dict_iterator {
   DictStorage::const_iterator dict_iter_;
 };
 
+// This class wraps the various |begin| and |end| methods of the underlying
+// DictStorage in dict_iterators and const_dict_iterators. This allows callers
+// to use this class for easy iteration over the underlying values, granting
+// them either read-only or read-write access, depending on the
+// const-qualification.
+class BASE_EXPORT dict_iterator_proxy {
+ public:
+  using key_type = DictStorage::key_type;
+  using mapped_type = DictStorage::mapped_type::element_type;
+  using value_type = std::pair<key_type, mapped_type>;
+  using key_compare = DictStorage::key_compare;
+  using size_type = DictStorage::size_type;
+  using difference_type = DictStorage::difference_type;
+
+  using iterator = dict_iterator;
+  using const_iterator = const_dict_iterator;
+  using reverse_iterator = std::reverse_iterator<iterator>;
+  using const_reverse_iterator = std::reverse_iterator<const_iterator>;
+
+  explicit dict_iterator_proxy(DictStorage* storage);
+
+  size_type size() const;
+
+  iterator begin();
+  const_iterator begin() const;
+  iterator end();
+  const_iterator end() const;
+
+  reverse_iterator rbegin();
+  const_reverse_iterator rbegin() const;
+  reverse_iterator rend();
+  const_reverse_iterator rend() const;
+
+  const_dict_iterator cbegin() const;
+  const_dict_iterator cend() const;
+  const_reverse_iterator crbegin() const;
+  const_reverse_iterator crend() const;
+
+ private:
+  raw_ptr<DictStorage, DanglingUntriaged> storage_;
+};
+
+// This class wraps the various const |begin| and |end| methods of the
+// underlying DictStorage in const_dict_iterators. This allows callers to use
+// this class for easy iteration over the underlying values, granting them
+// either read-only access.
+class BASE_EXPORT const_dict_iterator_proxy {
+ public:
+  using key_type = const DictStorage::key_type;
+  using mapped_type = const DictStorage::mapped_type::element_type;
+  using value_type = std::pair<key_type, mapped_type>;
+  using key_compare = DictStorage::key_compare;
+  using size_type = DictStorage::size_type;
+  using difference_type = DictStorage::difference_type;
+
+  using iterator = const_dict_iterator;
+  using const_iterator = const_dict_iterator;
+  using reverse_iterator = std::reverse_iterator<iterator>;
+  using const_reverse_iterator = std::reverse_iterator<const_iterator>;
+
+  explicit const_dict_iterator_proxy(const DictStorage* storage);
+
+  size_type size() const;
+
+  const_iterator begin() const;
+  const_iterator end() const;
+
+  const_reverse_iterator rbegin() const;
+  const_reverse_iterator rend() const;
+
+  const_iterator cbegin() const;
+  const_iterator cend() const;
+  const_reverse_iterator crbegin() const;
+  const_reverse_iterator crend() const;
+
+ private:
+  raw_ptr<const DictStorage, DanglingUntriaged> storage_;
+};
 }  // namespace detail
 
 }  // namespace base
diff --git a/base/value_iterators_unittest.cc b/base/value_iterators_unittest.cc
index 655e6e68d5..e1f0a8ab17 100644
--- a/base/value_iterators_unittest.cc
+++ b/base/value_iterators_unittest.cc
@@ -259,6 +259,72 @@ TEST(ValueIteratorsTest, ConstDictIteratorOperatorNE) {
   EXPECT_NE(iterator(storage.begin()), iterator(storage.end()));
 }
 
+TEST(ValueIteratorsTest, DictIteratorProxy) {
+  DictStorage storage;
+  storage.emplace("null", std::make_unique<Value>(Value::Type::NONE));
+  storage.emplace("bool", std::make_unique<Value>(Value::Type::BOOLEAN));
+  storage.emplace("int", std::make_unique<Value>(Value::Type::INTEGER));
+  storage.emplace("double", std::make_unique<Value>(Value::Type::DOUBLE));
+  storage.emplace("string", std::make_unique<Value>(Value::Type::STRING));
+  storage.emplace("blob", std::make_unique<Value>(Value::Type::BINARY));
+  storage.emplace("dict", std::make_unique<Value>(Value::Type::DICT));
+  storage.emplace("list", std::make_unique<Value>(Value::Type::LIST));
+
+  using iterator = const_dict_iterator;
+  using iterator_proxy = dict_iterator_proxy;
+  iterator_proxy proxy(&storage);
+
+  auto equal_to = [](const DictStorage::value_type& lhs,
+                     const iterator::reference& rhs) {
+    return std::tie(lhs.first, *lhs.second) == std::tie(rhs.first, rhs.second);
+  };
+
+  EXPECT_TRUE(are_equal(storage.begin(), storage.end(), proxy.begin(),
+                        proxy.end(), equal_to));
+
+  EXPECT_TRUE(are_equal(storage.rbegin(), storage.rend(), proxy.rbegin(),
+                        proxy.rend(), equal_to));
+
+  EXPECT_TRUE(are_equal(storage.cbegin(), storage.cend(), proxy.cbegin(),
+                        proxy.cend(), equal_to));
+
+  EXPECT_TRUE(are_equal(storage.crbegin(), storage.crend(), proxy.crbegin(),
+                        proxy.crend(), equal_to));
+}
+
+TEST(ValueIteratorsTest, ConstDictIteratorProxy) {
+  DictStorage storage;
+  storage.emplace("null", std::make_unique<Value>(Value::Type::NONE));
+  storage.emplace("bool", std::make_unique<Value>(Value::Type::BOOLEAN));
+  storage.emplace("int", std::make_unique<Value>(Value::Type::INTEGER));
+  storage.emplace("double", std::make_unique<Value>(Value::Type::DOUBLE));
+  storage.emplace("string", std::make_unique<Value>(Value::Type::STRING));
+  storage.emplace("blob", std::make_unique<Value>(Value::Type::BINARY));
+  storage.emplace("dict", std::make_unique<Value>(Value::Type::DICT));
+  storage.emplace("list", std::make_unique<Value>(Value::Type::LIST));
+
+  using iterator = const_dict_iterator;
+  using iterator_proxy = const_dict_iterator_proxy;
+  iterator_proxy proxy(&storage);
+
+  auto equal_to = [](const DictStorage::value_type& lhs,
+                     const iterator::reference& rhs) {
+    return std::tie(lhs.first, *lhs.second) == std::tie(rhs.first, rhs.second);
+  };
+
+  EXPECT_TRUE(are_equal(storage.begin(), storage.end(), proxy.begin(),
+                        proxy.end(), equal_to));
+
+  EXPECT_TRUE(are_equal(storage.rbegin(), storage.rend(), proxy.rbegin(),
+                        proxy.rend(), equal_to));
+
+  EXPECT_TRUE(are_equal(storage.cbegin(), storage.cend(), proxy.cbegin(),
+                        proxy.cend(), equal_to));
+
+  EXPECT_TRUE(are_equal(storage.crbegin(), storage.crend(), proxy.crbegin(),
+                        proxy.crend(), equal_to));
+}
+
 }  // namespace detail
 
 }  // namespace base
diff --git a/base/values.cc b/base/values.cc
index 2e51b987d3..cd41f9cfe1 100644
--- a/base/values.cc
+++ b/base/values.cc
@@ -1281,6 +1281,14 @@ Value* Value::FindListPath(StringPiece path) {
   return const_cast<Value*>(std::as_const(*this).FindListPath(path));
 }
 
+Value::dict_iterator_proxy Value::DictItems() {
+  return dict_iterator_proxy(&GetDict().storage_);
+}
+
+Value::const_dict_iterator_proxy Value::DictItems() const {
+  return const_dict_iterator_proxy(&GetDict().storage_);
+}
+
 size_t Value::DictSize() const {
   return GetDict().size();
 }
diff --git a/base/values.h b/base/values.h
index 45dfea06a8..059bd425e0 100644
--- a/base/values.h
+++ b/base/values.h
@@ -855,6 +855,26 @@ class BASE_EXPORT GSL_OWNER Value {
   Value* FindListPath(StringPiece path);
   const Value* FindListPath(StringPiece path) const;
 
+  using dict_iterator_proxy = detail::dict_iterator_proxy;
+  using const_dict_iterator_proxy = detail::const_dict_iterator_proxy;
+
+  // `DictItems` returns a proxy object that exposes iterators to the underlying
+  // dictionary. These are intended for iteration over all items in the
+  // dictionary and are compatible with for-each loops and standard library
+  // algorithms.
+  //
+  // Unlike with std::map, a range-for over the non-const version of
+  // `DictItems()` will range over items of type
+  // `pair<const std::string&, Value&>`, so code of the form
+  //   for (auto kv : my_value.DictItems())
+  //     Mutate(kv.second);
+  // will actually alter `my_value` in place (if it isn't const).
+  //
+  // DEPRECATED: Use a range-based for loop over `base::Value::Dict` directly
+  // instead.
+  dict_iterator_proxy DictItems();
+  const_dict_iterator_proxy DictItems() const;
+
   // DEPRECATED: prefer `Value::Dict::size()`.
   size_t DictSize() const;
 
diff --git a/base/values_unittest.cc b/base/values_unittest.cc
index 941013ac85..6ea72298b9 100644
--- a/base/values_unittest.cc
+++ b/base/values_unittest.cc
@@ -253,6 +253,7 @@ TEST(ValuesTest, HardenTests) {
   EXPECT_DEATH_IF_SUPPORTED(value.GetDouble(), "");
   EXPECT_DEATH_IF_SUPPORTED(value.GetString(), "");
   EXPECT_DEATH_IF_SUPPORTED(value.GetBlob(), "");
+  EXPECT_DEATH_IF_SUPPORTED(value.DictItems(), "");
 }
 
 // Group of tests for the copy constructors and copy-assigmnent. For equality
@@ -2029,7 +2030,7 @@ TEST(ValuesTest, DictionaryIterator) {
   EXPECT_TRUE(seen2);
 }
 
-TEST(ValuesTest, MutatingCopiedPairsInDictMutatesUnderlyingValues) {
+TEST(ValuesTest, MutatingCopiedPairsInDictItemsMutatesUnderlyingValues) {
   Value::Dict dict;
   dict.Set("key", Value("initial value"));
 
diff --git a/components/policy/core/common/policy_loader_command_line_unittest.cc b/components/policy/core/common/policy_loader_command_line_unittest.cc
index 3697077bc7..01cb8cb5c9 100644
--- a/components/policy/core/common/policy_loader_command_line_unittest.cc
+++ b/components/policy/core/common/policy_loader_command_line_unittest.cc
@@ -28,7 +28,7 @@ class PolicyLoaderCommandLineTest : public ::testing::Test {
     PolicyMap& map =
         bundle->Get(PolicyNamespace(POLICY_DOMAIN_CHROME, std::string()));
     EXPECT_EQ(expected_policies.DictSize(), map.size());
-    for (auto expected_policy : expected_policies.GetDict()) {
+    for (auto expected_policy : expected_policies.DictItems()) {
       const PolicyMap::Entry* actual_policy = map.Get(expected_policy.first);
       ASSERT_TRUE(actual_policy);
       EXPECT_EQ(POLICY_LEVEL_MANDATORY, actual_policy->level);
diff --git a/mojo/public/cpp/base/values_mojom_traits.h b/mojo/public/cpp/base/values_mojom_traits.h
index 4edba60841..8b66a36d65 100644
--- a/mojo/public/cpp/base/values_mojom_traits.h
+++ b/mojo/public/cpp/base/values_mojom_traits.h
@@ -67,6 +67,31 @@ struct COMPONENT_EXPORT(MOJO_BASE_SHARED_TRAITS)
                    base::Value::List* out);
 };
 
+template <>
+struct MapTraits<base::Value> {
+  using Key = std::string;
+  using Value = base::Value;
+  using Iterator = base::Value::const_dict_iterator_proxy::const_iterator;
+
+  static size_t GetSize(const base::Value& input) {
+    DCHECK(input.is_dict());
+    return input.GetDict().size();
+  }
+
+  static Iterator GetBegin(const base::Value& input) {
+    DCHECK(input.is_dict());
+    return input.DictItems().cbegin();
+  }
+
+  static void AdvanceIterator(Iterator& iterator) { ++iterator; }
+
+  static const Key& GetKey(const Iterator& iterator) { return iterator->first; }
+
+  static const Value& GetValue(const Iterator& iterator) {
+    return iterator->second;
+  }
+};
+
 template <>
 struct COMPONENT_EXPORT(MOJO_BASE_SHARED_TRAITS)
     UnionTraits<mojo_base::mojom::ValueDataView, base::Value> {
-- 
2.40.0.423.gd6c402a77b-goog

