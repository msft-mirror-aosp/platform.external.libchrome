From 086cc0ad5c29b6d00498696353e4ae8c5e950e3d Mon Sep 17 00:00:00 2001
From: Ren-Pei Zeng <kamesan@chromium.org>
Date: Thu, 2 Feb 2023 18:07:48 +0800
Subject: [PATCH] Revert "Rename UnguessableToken Deserialize2 to Deserialize"

This reverts commit ef100405bf3afe57fed7c25c998c0cc56ece75e8.
---
 base/android/unguessable_token_android.cc     |  2 +-
 base/json/values_util.cc                      |  2 +-
 base/metrics/field_trial.cc                   |  2 +-
 base/unguessable_token.cc                     |  4 +-
 base/unguessable_token.h                      |  6 +--
 base/unguessable_token_unittest.cc            | 40 +++++++++----------
 ipc/ipc_message_utils.cc                      |  2 +-
 mojo/core/broker_posix.cc                     |  2 +-
 mojo/core/data_pipe_consumer_dispatcher.cc    |  4 +-
 mojo/core/data_pipe_producer_dispatcher.cc    |  4 +-
 mojo/core/ipcz_driver/shared_buffer.cc        |  4 +-
 mojo/core/platform_wrapper_unittest.cc        |  2 +-
 mojo/core/shared_buffer_dispatcher.cc         |  4 +-
 .../base/unguessable_token_mojom_traits.cc    |  2 +-
 .../cpp/platform/platform_handle_internal.h   |  2 +-
 15 files changed, 41 insertions(+), 41 deletions(-)

diff --git a/base/android/unguessable_token_android.cc b/base/android/unguessable_token_android.cc
index efff14bdb2..448daee645 100644
--- a/base/android/unguessable_token_android.cc
+++ b/base/android/unguessable_token_android.cc
@@ -30,7 +30,7 @@ UnguessableTokenAndroid::FromJavaUnguessableToken(
       Java_UnguessableToken_getLowForSerialization(env, token));
   DCHECK(high);
   DCHECK(low);
-  return base::UnguessableToken::Deserialize(high, low);
+  return base::UnguessableToken::Deserialize2(high, low);
 }
 
 ScopedJavaLocalRef<jobject>
diff --git a/base/json/values_util.cc b/base/json/values_util.cc
index 8f14256fcd..45035d894f 100644
--- a/base/json/values_util.cc
+++ b/base/json/values_util.cc
@@ -113,7 +113,7 @@ absl::optional<UnguessableToken> ValueToUnguessableToken(const Value& value) {
   if (!HexStringToSpan(value.GetString(), repr.buffer))
     return absl::nullopt;
   absl::optional<base::UnguessableToken> token =
-      UnguessableToken::Deserialize(repr.field.high, repr.field.low);
+      UnguessableToken::Deserialize2(repr.field.high, repr.field.low);
   if (!token.has_value()) {
     return absl::nullopt;
   }
diff --git a/base/metrics/field_trial.cc b/base/metrics/field_trial.cc
index 8ebcd47c67..5d06211c71 100644
--- a/base/metrics/field_trial.cc
+++ b/base/metrics/field_trial.cc
@@ -203,7 +203,7 @@ bool DeserializeGUIDFromStringPieces(StringPiece first,
     return false;
 
   absl::optional<UnguessableToken> token =
-      UnguessableToken::Deserialize(high, low);
+      UnguessableToken::Deserialize2(high, low);
   if (!token.has_value()) {
     return false;
   }
diff --git a/base/unguessable_token.cc b/base/unguessable_token.cc
index aa7423f88d..db7a361447 100644
--- a/base/unguessable_token.cc
+++ b/base/unguessable_token.cc
@@ -33,8 +33,8 @@ const UnguessableToken& UnguessableToken::Null() {
 }
 
 // static
-absl::optional<UnguessableToken> UnguessableToken::Deserialize(uint64_t high,
-                                                               uint64_t low) {
+absl::optional<UnguessableToken> UnguessableToken::Deserialize2(uint64_t high,
+                                                                uint64_t low) {
   // Receiving a zeroed out UnguessableToken from another process means that it
   // was never initialized via Create(). Since this method might also be used to
   // create an UnguessableToken from data on disk, we will handle this case more
diff --git a/base/unguessable_token.h b/base/unguessable_token.h
index d1e57a1d51..121f92d07a 100644
--- a/base/unguessable_token.h
+++ b/base/unguessable_token.h
@@ -62,8 +62,8 @@ class BASE_EXPORT UnguessableToken {
   // NOTE: If the returned `absl::optional` does not have a value, it means that
   // `high` and `low` correspond to an `UnguesssableToken` that was never
   // initialized via Create(). This is a security issue, and should be handled.
-  static absl::optional<UnguessableToken> Deserialize(uint64_t high,
-                                                      uint64_t low);
+  static absl::optional<UnguessableToken> Deserialize2(uint64_t high,
+                                                       uint64_t low);
 
   // Creates an empty UnguessableToken.
   // Assign to it with Create() before using it.
@@ -107,7 +107,7 @@ class BASE_EXPORT UnguessableToken {
 
 #if defined(UNIT_TEST)
   static UnguessableToken CreateForTesting(uint64_t high, uint64_t low) {
-    absl::optional<UnguessableToken> token = Deserialize(high, low);
+    absl::optional<UnguessableToken> token = Deserialize2(high, low);
     DCHECK(token.has_value());
     return token.value();
   }
diff --git a/base/unguessable_token_unittest.cc b/base/unguessable_token_unittest.cc
index 1064a35aa1..ff88f158e7 100644
--- a/base/unguessable_token_unittest.cc
+++ b/base/unguessable_token_unittest.cc
@@ -20,7 +20,7 @@ void TestSmallerThanOperator(const UnguessableToken& a,
 }
 
 TEST(UnguessableTokenTest, VerifyEveryBit) {
-  absl::optional<UnguessableToken> token = UnguessableToken::Deserialize(1, 2);
+  absl::optional<UnguessableToken> token = UnguessableToken::Deserialize2(1, 2);
   ASSERT_TRUE(token.has_value());
   uint64_t high = 1;
   uint64_t low = 2;
@@ -28,7 +28,7 @@ TEST(UnguessableTokenTest, VerifyEveryBit) {
   for (uint64_t bit = 1; bit != 0; bit <<= 1) {
     uint64_t new_high = high ^ bit;
     absl::optional<UnguessableToken> new_token =
-        UnguessableToken::Deserialize(new_high, low);
+        UnguessableToken::Deserialize2(new_high, low);
     ASSERT_TRUE(new_token.has_value());
     EXPECT_FALSE(*token == *new_token);
   }
@@ -36,7 +36,7 @@ TEST(UnguessableTokenTest, VerifyEveryBit) {
   for (uint64_t bit = 1; bit != 0; bit <<= 1) {
     uint64_t new_low = low ^ bit;
     absl::optional<UnguessableToken> new_token =
-        UnguessableToken::Deserialize(high, new_low);
+        UnguessableToken::Deserialize2(high, new_low);
     ASSERT_TRUE(new_token.has_value());
     EXPECT_FALSE(*token == *new_token);
   }
@@ -45,9 +45,9 @@ TEST(UnguessableTokenTest, VerifyEveryBit) {
 TEST(UnguessableTokenTest, VerifyEqualityOperators) {
   // Deserialize is used for testing purposes.
   // Use UnguessableToken::Create() in production code instead.
-  UnguessableToken token = UnguessableToken::Deserialize(1, 2).value();
-  UnguessableToken same_token = UnguessableToken::Deserialize(1, 2).value();
-  UnguessableToken diff_token = UnguessableToken::Deserialize(1, 3).value();
+  UnguessableToken token = UnguessableToken::Deserialize2(1, 2).value();
+  UnguessableToken same_token = UnguessableToken::Deserialize2(1, 2).value();
+  UnguessableToken diff_token = UnguessableToken::Deserialize2(1, 3).value();
   UnguessableToken empty_token;
 
   EXPECT_TRUE(token == token);
@@ -96,7 +96,7 @@ TEST(UnguessableTokenTest, VerifySerialization) {
   EXPECT_TRUE(low);
 
   absl::optional<UnguessableToken> Deserialized =
-      UnguessableToken::Deserialize(high, low);
+      UnguessableToken::Deserialize2(high, low);
   ASSERT_TRUE(Deserialized.has_value());
   EXPECT_EQ(token, *Deserialized);
 }
@@ -104,7 +104,7 @@ TEST(UnguessableTokenTest, VerifySerialization) {
 // Common case (~88% of the time) - no leading zeroes in high_ nor low_.
 TEST(UnguessableTokenTest, VerifyToString1) {
   UnguessableToken token =
-      UnguessableToken::Deserialize(0x1234567890ABCDEF, 0xFEDCBA0987654321)
+      UnguessableToken::Deserialize2(0x1234567890ABCDEF, 0xFEDCBA0987654321)
           .value();
   std::string expected = "1234567890ABCDEFFEDCBA0987654321";
 
@@ -118,7 +118,7 @@ TEST(UnguessableTokenTest, VerifyToString1) {
 
 // Less common case - leading zeroes in high_ or low_ (testing with both).
 TEST(UnguessableTokenTest, VerifyToString2) {
-  UnguessableToken token = UnguessableToken::Deserialize(0x123, 0xABC).value();
+  UnguessableToken token = UnguessableToken::Deserialize2(0x123, 0xABC).value();
   std::string expected = "00000000000001230000000000000ABC";
 
   EXPECT_EQ(expected, token.ToString());
@@ -131,16 +131,16 @@ TEST(UnguessableTokenTest, VerifyToString2) {
 
 TEST(UnguessableTokenTest, VerifyToStringUniqueness) {
   const UnguessableToken token1 =
-      UnguessableToken::Deserialize(0x0000000012345678, 0x0000000123456789)
+      UnguessableToken::Deserialize2(0x0000000012345678, 0x0000000123456789)
           .value();
   const UnguessableToken token2 =
-      UnguessableToken::Deserialize(0x0000000123456781, 0x0000000023456789)
+      UnguessableToken::Deserialize2(0x0000000123456781, 0x0000000023456789)
           .value();
   EXPECT_NE(token1.ToString(), token2.ToString());
 }
 
 TEST(UnguessableTokenTest, VerifyDeserializeZeroes) {
-  absl::optional<UnguessableToken> token = UnguessableToken::Deserialize(0, 0);
+  absl::optional<UnguessableToken> token = UnguessableToken::Deserialize2(0, 0);
 
   EXPECT_FALSE(token.has_value());
 }
@@ -150,23 +150,23 @@ TEST(UnguessableTokenTest, VerifySmallerThanOperator) {
   // Use UnguessableToken::Create() in production code instead.
   {
     SCOPED_TRACE("a.low < b.low and a.high == b.high.");
-    TestSmallerThanOperator(UnguessableToken::Deserialize(0, 1).value(),
-                            UnguessableToken::Deserialize(0, 5).value());
+    TestSmallerThanOperator(UnguessableToken::Deserialize2(0, 1).value(),
+                            UnguessableToken::Deserialize2(0, 5).value());
   }
   {
     SCOPED_TRACE("a.low == b.low and a.high < b.high.");
-    TestSmallerThanOperator(UnguessableToken::Deserialize(1, 0).value(),
-                            UnguessableToken::Deserialize(5, 0).value());
+    TestSmallerThanOperator(UnguessableToken::Deserialize2(1, 0).value(),
+                            UnguessableToken::Deserialize2(5, 0).value());
   }
   {
     SCOPED_TRACE("a.low < b.low and a.high < b.high.");
-    TestSmallerThanOperator(UnguessableToken::Deserialize(1, 1).value(),
-                            UnguessableToken::Deserialize(5, 5).value());
+    TestSmallerThanOperator(UnguessableToken::Deserialize2(1, 1).value(),
+                            UnguessableToken::Deserialize2(5, 5).value());
   }
   {
     SCOPED_TRACE("a.low > b.low and a.high < b.high.");
-    TestSmallerThanOperator(UnguessableToken::Deserialize(1, 10).value(),
-                            UnguessableToken::Deserialize(10, 1).value());
+    TestSmallerThanOperator(UnguessableToken::Deserialize2(1, 10).value(),
+                            UnguessableToken::Deserialize2(10, 1).value());
   }
 }
 
diff --git a/ipc/ipc_message_utils.cc b/ipc/ipc_message_utils.cc
index 6c48bf40b7..bce4265cfc 100644
--- a/ipc/ipc_message_utils.cc
+++ b/ipc/ipc_message_utils.cc
@@ -1311,7 +1311,7 @@ bool ParamTraits<base::UnguessableToken>::Read(const base::Pickle* m,
   // deserialized by the traits should always yield a non-empty token.
   // If deserialization results in an empty token, the data is malformed.
   absl::optional<base::UnguessableToken> token =
-      base::UnguessableToken::Deserialize(high, low);
+      base::UnguessableToken::Deserialize2(high, low);
   if (!token.has_value()) {
     return false;
   }
diff --git a/mojo/core/broker_posix.cc b/mojo/core/broker_posix.cc
index 96cdf72864..06997066c0 100644
--- a/mojo/core/broker_posix.cc
+++ b/mojo/core/broker_posix.cc
@@ -132,7 +132,7 @@ base::WritableSharedMemoryRegion Broker::GetWritableSharedMemoryRegion(
     if (!GetBrokerMessageData(message.get(), &data))
       return base::WritableSharedMemoryRegion();
     absl::optional<base::UnguessableToken> guid =
-        base::UnguessableToken::Deserialize(data->guid_high, data->guid_low);
+        base::UnguessableToken::Deserialize2(data->guid_high, data->guid_low);
     if (!guid.has_value()) {
       return base::WritableSharedMemoryRegion();
     }
diff --git a/mojo/core/data_pipe_consumer_dispatcher.cc b/mojo/core/data_pipe_consumer_dispatcher.cc
index ba0e8eed4c..d035540717 100644
--- a/mojo/core/data_pipe_consumer_dispatcher.cc
+++ b/mojo/core/data_pipe_consumer_dispatcher.cc
@@ -391,8 +391,8 @@ DataPipeConsumerDispatcher::Deserialize(const void* data,
   }
 
   absl::optional<base::UnguessableToken> buffer_guid =
-      base::UnguessableToken::Deserialize(state->buffer_guid_high,
-                                          state->buffer_guid_low);
+      base::UnguessableToken::Deserialize2(state->buffer_guid_high,
+                                           state->buffer_guid_low);
   if (!buffer_guid.has_value()) {
     AssertNotExtractingHandlesFromMessage();
     return nullptr;
diff --git a/mojo/core/data_pipe_producer_dispatcher.cc b/mojo/core/data_pipe_producer_dispatcher.cc
index 1a54b1a0c2..2e8abc1549 100644
--- a/mojo/core/data_pipe_producer_dispatcher.cc
+++ b/mojo/core/data_pipe_producer_dispatcher.cc
@@ -352,8 +352,8 @@ DataPipeProducerDispatcher::Deserialize(const void* data,
   }
 
   absl::optional<base::UnguessableToken> buffer_guid =
-      base::UnguessableToken::Deserialize(state->buffer_guid_high,
-                                          state->buffer_guid_low);
+      base::UnguessableToken::Deserialize2(state->buffer_guid_high,
+                                           state->buffer_guid_low);
   if (!buffer_guid.has_value()) {
     AssertNotExtractingHandlesFromMessage();
     return nullptr;
diff --git a/mojo/core/ipcz_driver/shared_buffer.cc b/mojo/core/ipcz_driver/shared_buffer.cc
index 15155644ce..24267ce627 100644
--- a/mojo/core/ipcz_driver/shared_buffer.cc
+++ b/mojo/core/ipcz_driver/shared_buffer.cc
@@ -133,7 +133,7 @@ scoped_refptr<SharedBuffer> SharedBuffer::CreateForMojoWrapper(
   }
 
   absl::optional<base::UnguessableToken> guid =
-      base::UnguessableToken::Deserialize(mojo_guid.high, mojo_guid.low);
+      base::UnguessableToken::Deserialize2(mojo_guid.high, mojo_guid.low);
   if (!guid.has_value()) {
     return nullptr;
   }
@@ -251,7 +251,7 @@ scoped_refptr<SharedBuffer> SharedBuffer::Deserialize(
   }
 
   absl::optional<base::UnguessableToken> guid =
-      base::UnguessableToken::Deserialize(header.guid_high, header.guid_low);
+      base::UnguessableToken::Deserialize2(header.guid_high, header.guid_low);
   if (!guid.has_value()) {
     return nullptr;
   }
diff --git a/mojo/core/platform_wrapper_unittest.cc b/mojo/core/platform_wrapper_unittest.cc
index 72ee50cf3d..607814ad78 100644
--- a/mojo/core/platform_wrapper_unittest.cc
+++ b/mojo/core/platform_wrapper_unittest.cc
@@ -192,7 +192,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(ReadPlatformSharedBuffer,
 
   auto mode = base::subtle::PlatformSharedMemoryRegion::Mode::kUnsafe;
   absl::optional<base::UnguessableToken> guid =
-      base::UnguessableToken::Deserialize(mojo_guid.high, mojo_guid.low);
+      base::UnguessableToken::Deserialize2(mojo_guid.high, mojo_guid.low);
   ASSERT_TRUE(guid.has_value());
 #if BUILDFLAG(IS_WIN)
   ASSERT_EQ(MOJO_PLATFORM_HANDLE_TYPE_WINDOWS_HANDLE, os_buffer.type);
diff --git a/mojo/core/shared_buffer_dispatcher.cc b/mojo/core/shared_buffer_dispatcher.cc
index 575a992af5..d13da69161 100644
--- a/mojo/core/shared_buffer_dispatcher.cc
+++ b/mojo/core/shared_buffer_dispatcher.cc
@@ -164,8 +164,8 @@ scoped_refptr<SharedBufferDispatcher> SharedBufferDispatcher::Deserialize(
   handles[0] = std::move(platform_handles[0]);
 
   absl::optional<base::UnguessableToken> guid =
-      base::UnguessableToken::Deserialize(serialized_state->guid_high,
-                                          serialized_state->guid_low);
+      base::UnguessableToken::Deserialize2(serialized_state->guid_high,
+                                           serialized_state->guid_low);
   if (!guid.has_value()) {
     AssertNotExtractingHandlesFromMessage();
     return nullptr;
diff --git a/mojo/public/cpp/base/unguessable_token_mojom_traits.cc b/mojo/public/cpp/base/unguessable_token_mojom_traits.cc
index ba96eeac98..d4e9b6fbef 100644
--- a/mojo/public/cpp/base/unguessable_token_mojom_traits.cc
+++ b/mojo/public/cpp/base/unguessable_token_mojom_traits.cc
@@ -18,7 +18,7 @@ bool StructTraits<mojo_base::mojom::UnguessableTokenDataView,
   // deserialized by the traits should always yield a non-empty token.
   // If deserialization results in an empty token, the data is malformed.
   absl::optional<base::UnguessableToken> token =
-      base::UnguessableToken::Deserialize(high, low);
+      base::UnguessableToken::Deserialize2(high, low);
   if (!token.has_value()) {
     return false;
   }
diff --git a/mojo/public/cpp/platform/platform_handle_internal.h b/mojo/public/cpp/platform/platform_handle_internal.h
index 5cc7b44399..89dc0c8d38 100644
--- a/mojo/public/cpp/platform/platform_handle_internal.h
+++ b/mojo/public/cpp/platform/platform_handle_internal.h
@@ -24,7 +24,7 @@ class PlatformHandleInternal {
   }
   static absl::optional<base::UnguessableToken> UnmarshalUnguessableToken(
       const MojoSharedBufferGuid* guid) {
-    return base::UnguessableToken::Deserialize(guid->high, guid->low);
+    return base::UnguessableToken::Deserialize2(guid->high, guid->low);
   }
 };
 
-- 
2.39.1.456.gfc5497dd1b-goog

