From b70a22a537907ec9b5380e6703379886a52ad627 Mon Sep 17 00:00:00 2001
From: Kevin Lin <kevinptt@chromium.org>
Date: Wed, 29 Mar 2023 05:04:45 +0800
Subject: [PATCH] Revert "Fix race conditions in Watchdog subclasses"

This reverts commit e3a6ab9d6a69b4d79718026e09fd07ff2e09c15b.
---
 base/threading/watchdog.cc          | 31 ++++++++++-------------------
 base/threading/watchdog.h           | 27 ++++++-------------------
 base/threading/watchdog_unittest.cc | 28 ++++++++++++--------------
 3 files changed, 30 insertions(+), 56 deletions(-)

diff --git a/base/threading/watchdog.cc b/base/threading/watchdog.cc
index 8854f2b51c..91eca37131 100644
--- a/base/threading/watchdog.cc
+++ b/base/threading/watchdog.cc
@@ -41,20 +41,19 @@ StaticData* GetStaticData() {
 // Start thread running in a Disarmed state.
 Watchdog::Watchdog(const TimeDelta& duration,
                    const std::string& thread_watched_name,
-                   bool enabled,
-                   Delegate* delegate)
-    : enabled_(enabled),
-      condition_variable_(&lock_),
-      state_(DISARMED),
-      duration_(duration),
-      thread_watched_name_(thread_watched_name),
-      thread_delegate_(this),
-      delegate_(delegate) {
-  if (!enabled_) {
+                   bool enabled)
+  : enabled_(enabled),
+    lock_(),
+    condition_variable_(&lock_),
+    state_(DISARMED),
+    duration_(duration),
+    thread_watched_name_(thread_watched_name),
+    delegate_(this) {
+  if (!enabled_)
     return;  // Don't start thread, or doing anything really.
-  }
   enabled_ = PlatformThread::Create(0,  // Default stack size.
-                                    &thread_delegate_, &handle_);
+                                    &delegate_,
+                                    &handle_);
   DCHECK(enabled_);
 }
 
@@ -109,14 +108,6 @@ void Watchdog::Disarm() {
 }
 
 void Watchdog::Alarm() {
-  if (delegate_) {
-    delegate_->Alarm();
-  } else {
-    DefaultAlarm();
-  }
-}
-
-void Watchdog::DefaultAlarm() {
   DVLOG(1) << "Watchdog alarmed for " << thread_watched_name_;
 }
 
diff --git a/base/threading/watchdog.h b/base/threading/watchdog.h
index f09e9a2d3e..0a138be7bf 100644
--- a/base/threading/watchdog.h
+++ b/base/threading/watchdog.h
@@ -32,26 +32,15 @@ namespace base {
 
 class BASE_EXPORT Watchdog {
  public:
-  class Delegate {
-   public:
-    virtual ~Delegate() = default;
-
-    // Called on the watchdog thread.
-    virtual void Alarm() = 0;
-  };
-
-  // Constructor specifies how long the Watchdog will wait before alarming. If
-  // `delegate` is non-null, `Alarm` on the delegate will be called instead of
-  // the default behavior.
+  // Constructor specifies how long the Watchdog will wait before alarming.
   Watchdog(const TimeDelta& duration,
            const std::string& thread_watched_name,
-           bool enabled,
-           Delegate* delegate = nullptr);
+           bool enabled);
 
   Watchdog(const Watchdog&) = delete;
   Watchdog& operator=(const Watchdog&) = delete;
 
-  ~Watchdog();
+  virtual ~Watchdog();
 
   // Notify watchdog thread to finish up. Sets the state_ to SHUTDOWN.
   void Cleanup();
@@ -69,16 +58,13 @@ class BASE_EXPORT Watchdog {
   void Disarm();
 
   // Alarm is called if the time expires after an Arm() without someone calling
-  // Disarm().
-  void Alarm();
+  // Disarm().  This method can be overridden to create testable classes.
+  virtual void Alarm();
 
   // Reset static data to initial state. Useful for tests, to ensure
   // they are independent.
   static void ResetStaticData();
 
-  // The default behavior of Alarm() if a delegate is not provided.
-  void DefaultAlarm();
-
  private:
   class ThreadDelegate : public PlatformThread::Delegate {
    public:
@@ -102,9 +88,8 @@ class BASE_EXPORT Watchdog {
   const TimeDelta duration_;  // How long after start_time_ do we alarm?
   const std::string thread_watched_name_;
   PlatformThreadHandle handle_;
-  ThreadDelegate thread_delegate_;  // Must outlive the thread.
+  ThreadDelegate delegate_;  // Store it, because it must outlive the thread.
 
-  raw_ptr<Delegate> delegate_;
   TimeTicks start_time_;  // Start of epoch, and alarm after duration_.
 };
 
diff --git a/base/threading/watchdog_unittest.cc b/base/threading/watchdog_unittest.cc
index e249a8ce51..5a44cd6144 100644
--- a/base/threading/watchdog_unittest.cc
+++ b/base/threading/watchdog_unittest.cc
@@ -4,8 +4,6 @@
 
 #include "base/threading/watchdog.h"
 
-#include <atomic>
-
 #include "base/logging.h"
 #include "base/test/spin_wait.h"
 #include "base/threading/platform_thread.h"
@@ -19,12 +17,14 @@ namespace {
 //------------------------------------------------------------------------------
 // Provide a derived class to facilitate testing.
 
-class WatchdogCounter : public Watchdog::Delegate {
+class WatchdogCounter : public Watchdog {
  public:
   WatchdogCounter(const TimeDelta& duration,
                   const std::string& thread_watched_name,
                   bool enabled)
-      : watchdog_(duration, thread_watched_name, enabled, this) {}
+      : Watchdog(duration, thread_watched_name, enabled),
+        alarm_counter_(0) {
+  }
 
   WatchdogCounter(const WatchdogCounter&) = delete;
   WatchdogCounter& operator=(const WatchdogCounter&) = delete;
@@ -33,15 +33,13 @@ class WatchdogCounter : public Watchdog::Delegate {
 
   void Alarm() override {
     alarm_counter_++;
-    watchdog_.DefaultAlarm();
+    Watchdog::Alarm();
   }
 
-  Watchdog& watchdog() { return watchdog_; }
-  int alarm_counter() { return alarm_counter_.load(); }
+  int alarm_counter() { return alarm_counter_; }
 
  private:
-  std::atomic<int> alarm_counter_{0};
-  Watchdog watchdog_;
+  int alarm_counter_;
 };
 
 class WatchdogTest : public testing::Test {
@@ -78,7 +76,7 @@ TEST_F(WatchdogTest, ArmDisarmTest) {
 // Make sure a basic alarm fires when the time has expired.
 TEST_F(WatchdogTest, AlarmTest) {
   WatchdogCounter watchdog(Milliseconds(10), "Enabled", true);
-  watchdog.watchdog().Arm();
+  watchdog.Arm();
   SPIN_FOR_TIMEDELTA_OR_UNTIL_TRUE(Minutes(5), watchdog.alarm_counter() > 0);
   EXPECT_EQ(1, watchdog.alarm_counter());
 }
@@ -87,7 +85,7 @@ TEST_F(WatchdogTest, AlarmTest) {
 TEST_F(WatchdogTest, AlarmPriorTimeTest) {
   WatchdogCounter watchdog(TimeDelta(), "Enabled2", true);
   // Set a time in the past.
-  watchdog.watchdog().ArmSomeTimeDeltaAgo(Seconds(2));
+  watchdog.ArmSomeTimeDeltaAgo(Seconds(2));
   // It should instantly go off, but certainly in less than 5 minutes.
   SPIN_FOR_TIMEDELTA_OR_UNTIL_TRUE(Minutes(5), watchdog.alarm_counter() > 0);
 
@@ -97,7 +95,7 @@ TEST_F(WatchdogTest, AlarmPriorTimeTest) {
 // Make sure a disable alarm does nothing, even if we arm it.
 TEST_F(WatchdogTest, ConstructorDisabledTest) {
   WatchdogCounter watchdog(Milliseconds(10), "Disabled", false);
-  watchdog.watchdog().Arm();
+  watchdog.Arm();
   // Alarm should not fire, as it was disabled.
   PlatformThread::Sleep(Milliseconds(500));
   EXPECT_EQ(0, watchdog.alarm_counter());
@@ -108,10 +106,10 @@ TEST_F(WatchdogTest, DisarmTest) {
   WatchdogCounter watchdog(Seconds(1), "Enabled3", true);
 
   TimeTicks start = TimeTicks::Now();
-  watchdog.watchdog().Arm();
+  watchdog.Arm();
   // Sleep a bit, but not past the alarm point.
   PlatformThread::Sleep(Milliseconds(100));
-  watchdog.watchdog().Disarm();
+  watchdog.Disarm();
   TimeTicks end = TimeTicks::Now();
 
   if (end - start > Milliseconds(500)) {
@@ -130,7 +128,7 @@ TEST_F(WatchdogTest, DisarmTest) {
 
   // ...but even after disarming, we can still use the alarm...
   // Set a time greater than the timeout into the past.
-  watchdog.watchdog().ArmSomeTimeDeltaAgo(Seconds(10));
+  watchdog.ArmSomeTimeDeltaAgo(Seconds(10));
   // It should almost instantly go off, but certainly in less than 5 minutes.
   SPIN_FOR_TIMEDELTA_OR_UNTIL_TRUE(Minutes(5), watchdog.alarm_counter() > 0);
 
-- 
2.40.0.348.gf938b09366-goog

