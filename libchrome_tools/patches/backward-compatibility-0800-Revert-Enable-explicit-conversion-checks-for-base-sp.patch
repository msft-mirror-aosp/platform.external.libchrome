From 5416d3b2bd3ae909b4c66ebe6daecdfccaf1a543 Mon Sep 17 00:00:00 2001
From: Qijiang Fan <fqj@google.com>
Date: Tue, 21 Feb 2023 15:26:07 +0900
Subject: [PATCH] Revert "Enable explicit conversion checks for base::span
 sizes."

This reverts commit c52a595db6bdc149f757bbca292414adc719e855.
---
 base/containers/span.h                        | 17 +++--
 base/containers/span_unittest.cc              | 12 +---
 base/containers/span_unittest.nc              | 62 +++++++------------
 .../file_descriptor_watcher_posix_unittest.cc |  2 +-
 base/json/json_writer_unittest.cc             |  2 +-
 .../thread_pool/thread_pool_impl_unittest.cc  |  2 +-
 ipc/ipc_mojo_bootstrap_unittest.cc            |  4 +-
 mojo/core/core_ipcz_test.cc                   |  8 +--
 mojo/core/ipcz_driver/transport_test.cc       |  4 +-
 9 files changed, 44 insertions(+), 69 deletions(-)

diff --git a/base/containers/span.h b/base/containers/span.h
index 9fb62818a1..07d8a5aeaf 100644
--- a/base/containers/span.h
+++ b/base/containers/span.h
@@ -18,7 +18,6 @@
 #include "base/containers/checked_iterators.h"
 #include "base/containers/contiguous_iterator.h"
 #include "base/cxx20_to_address.h"
-#include "base/numerics/safe_math.h"
 
 namespace base {
 
@@ -257,16 +256,16 @@ class GSL_POINTER span : public internal::ExtentStorage<Extent> {
 
   template <typename It,
             typename = internal::EnableIfCompatibleContiguousIterator<It, T>>
-  constexpr span(It first, StrictNumeric<size_t> count) noexcept
+  constexpr span(It first, size_t count) noexcept
       : ExtentStorage(count),
         // The use of to_address() here is to handle the case where the iterator
         // `first` is pointing to the container's `end()`. In that case we can
         // not use the address returned from the iterator, or dereference it
-        // through the iterator's `operator*`, but we can store it. We must
-        // assume in this case that `count` is 0, since the iterator does not
-        // point to valid data. Future hardening of iterators may disallow
-        // pulling the address from `end()`, as demonstrated by asserts() in
-        // libstdc++: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=93960.
+        // through the iterator's `operator*`, but we can store it. We must assume
+        // in this case that `count` is 0, since the iterator does not point to
+        // valid data. Future hardening of iterators may disallow pulling the
+        // address from `end()`, as demonstrated by asserts() in libstdc++:
+        // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=93960.
         //
         // The span API dictates that the `data()` is accessible when size is 0,
         // since the pointer may be valid, so we cannot prevent storing and
@@ -474,7 +473,7 @@ as_writable_bytes(span<T, X> s) noexcept {
 
 // Type-deducing helpers for constructing a span.
 template <int&... ExplicitArgumentBarrier, typename It>
-constexpr auto make_span(It it, StrictNumeric<size_t> size) noexcept {
+constexpr auto make_span(It it, size_t size) noexcept {
   using T = std::remove_reference_t<iter_reference_t<It>>;
   return span<T>(it, size);
 }
@@ -509,7 +508,7 @@ constexpr auto make_span(Container&& container) noexcept {
 //
 // Usage: auto static_span = base::make_span<N>(...);
 template <size_t N, int&... ExplicitArgumentBarrier, typename It>
-constexpr auto make_span(It it, StrictNumeric<size_t> size) noexcept {
+constexpr auto make_span(It it, size_t size) noexcept {
   using T = std::remove_reference_t<iter_reference_t<It>>;
   return span<T, N>(it, size);
 }
diff --git a/base/containers/span_unittest.cc b/base/containers/span_unittest.cc
index d74ba60598..b3091a113a 100644
--- a/base/containers/span_unittest.cc
+++ b/base/containers/span_unittest.cc
@@ -38,7 +38,7 @@ TEST(SpanTest, DefaultConstructor) {
 
 TEST(SpanTest, ConstructFromDataAndSize) {
   constexpr int* kNull = nullptr;
-  constexpr span<int> empty_span(kNull, 0u);
+  constexpr span<int> empty_span(kNull, 0);
   EXPECT_TRUE(empty_span.empty());
   EXPECT_EQ(nullptr, empty_span.data());
 
@@ -61,7 +61,7 @@ TEST(SpanTest, ConstructFromDataAndSize) {
 
 TEST(SpanTest, ConstructFromIterAndSize) {
   constexpr int* kNull = nullptr;
-  constexpr span<int> empty_span(kNull, 0u);
+  constexpr span<int> empty_span(kNull, 0);
   EXPECT_TRUE(empty_span.empty());
   EXPECT_EQ(nullptr, empty_span.data());
 
@@ -1111,7 +1111,7 @@ TEST(SpanTest, AsWritableBytes) {
 
 TEST(SpanTest, MakeSpanFromDataAndSize) {
   int* nullint = nullptr;
-  auto empty_span = make_span(nullint, 0u);
+  auto empty_span = make_span(nullint, 0);
   EXPECT_TRUE(empty_span.empty());
   EXPECT_EQ(nullptr, empty_span.data());
 
@@ -1349,12 +1349,6 @@ TEST(SpanTest, OutOfBoundsDeath) {
   ASSERT_DEATH_IF_SUPPORTED(kNonEmptyDynamicSpan[4], "");
   ASSERT_DEATH_IF_SUPPORTED(kNonEmptyDynamicSpan.subspan(10), "");
   ASSERT_DEATH_IF_SUPPORTED(kNonEmptyDynamicSpan.subspan(1, 7), "");
-
-  size_t minus_one = static_cast<size_t>(-1);
-  ASSERT_DEATH_IF_SUPPORTED(kNonEmptyDynamicSpan.subspan(minus_one), "");
-  ASSERT_DEATH_IF_SUPPORTED(kNonEmptyDynamicSpan.subspan(minus_one, minus_one),
-                            "");
-  ASSERT_DEATH_IF_SUPPORTED(kNonEmptyDynamicSpan.subspan(minus_one, 1), "");
 }
 
 TEST(SpanTest, IteratorIsRangeMoveSafe) {
diff --git a/base/containers/span_unittest.nc b/base/containers/span_unittest.nc
index ae72e9af9d..8d4470afa2 100644
--- a/base/containers/span_unittest.nc
+++ b/base/containers/span_unittest.nc
@@ -25,34 +25,34 @@ class Derived : Base {
 
 // A default constructed span must have an extent of 0 or dynamic_extent.
 void WontCompile() {
-  span<int, 1u> span;
+  span<int, 1> span;
 }
 
-#elif defined(NCTEST_SPAN_FROM_ARRAY_WITH_NON_MATCHING_STATIC_EXTENT_DISALLOWED) // [r"fatal error: no matching constructor for initialization of 'span<int, 1U>'"]
+#elif defined(NCTEST_SPAN_FROM_ARRAY_WITH_NON_MATCHING_STATIC_EXTENT_DISALLOWED) // [r"fatal error: no matching constructor for initialization of 'span<int, 1>'"]
 
 // A span with static extent constructed from an array must match the size of
 // the array.
 void WontCompile() {
   int array[] = {1, 2, 3};
-  span<int, 1u> span(array);
+  span<int, 1> span(array);
 }
 
-#elif defined(NCTEST_SPAN_FROM_OTHER_SPAN_WITH_MISMATCHING_EXTENT_DISALLOWED) // [r"fatal error: no matching constructor for initialization of 'span<int, 4U>'"]
+#elif defined(NCTEST_SPAN_FROM_OTHER_SPAN_WITH_MISMATCHING_EXTENT_DISALLOWED) // [r"fatal error: no matching constructor for initialization of 'span<int, 4>'"]
 
 // A span with static extent constructed from another span must match the
 // extent.
 void WontCompile() {
   std::array<int, 3> array = {1, 2, 3};
-  span<int, 3u> span3(array);
-  span<int, 4u> span4(span3);
+  span<int, 3> span3(array);
+  span<int, 4> span4(span3);
 }
 
-#elif defined(NCTEST_DYNAMIC_SPAN_TO_STATIC_SPAN_DISALLOWED)  // [r"fatal error: no matching constructor for initialization of 'span<int, 3U>'"]
+#elif defined(NCTEST_DYNAMIC_SPAN_TO_STATIC_SPAN_DISALLOWED)  // [r"fatal error: no matching constructor for initialization of 'span<int, 3>'"]
 
 // Converting a dynamic span to a static span should not be allowed.
 void WontCompile() {
   span<int> dynamic_span;
-  span<int, 3u> static_span(dynamic_span);
+  span<int, 3> static_span(dynamic_span);
 }
 
 #elif defined(NCTEST_DERIVED_TO_BASE_CONVERSION_DISALLOWED)  // [r"fatal error: no matching constructor for initialization of 'span<Base \*>'"]
@@ -86,20 +86,20 @@ void WontCompile() {
   span<int> span(v);
 }
 
-#elif defined(NCTEST_IMPLICIT_CONVERSION_FROM_DYNAMIC_CONST_CONTAINER_TO_STATIC_SPAN_DISALLOWED) // [r"fatal error: no viable conversion from 'const std::vector<int>' to 'span<const int, 3U>'"]
+#elif defined(NCTEST_IMPLICIT_CONVERSION_FROM_DYNAMIC_CONST_CONTAINER_TO_STATIC_SPAN_DISALLOWED) // [r"fatal error: no viable conversion from 'const std::vector<int>' to 'span<const int, 3>'"]
 
 // A dynamic const container should not be implicitly convertible to a static span.
 void WontCompile() {
   const std::vector<int> v = {1, 2, 3};
-  span<const int, 3u> span = v;
+  span<const int, 3> span = v;
 }
 
-#elif defined(NCTEST_IMPLICIT_CONVERSION_FROM_DYNAMIC_MUTABLE_CONTAINER_TO_STATIC_SPAN_DISALLOWED) // [r"fatal error: no viable conversion from 'std::vector<int>' to 'span<int, 3U>'"]
+#elif defined(NCTEST_IMPLICIT_CONVERSION_FROM_DYNAMIC_MUTABLE_CONTAINER_TO_STATIC_SPAN_DISALLOWED) // [r"fatal error: no viable conversion from 'std::vector<int>' to 'span<int, 3>'"]
 
 // A dynamic mutable container should not be implicitly convertible to a static span.
 void WontCompile() {
   std::vector<int> v = {1, 2, 3};
-  span<int, 3u> span = v;
+  span<int, 3> span = v;
 }
 
 #elif defined(NCTEST_STD_SET_ITER_SIZE_CONVERSION_DISALLOWED)  // [r"fatal error: no matching constructor for initialization of 'span<int>'"]
@@ -107,7 +107,7 @@ void WontCompile() {
 // A std::set() should not satisfy the requirements for conversion to a span.
 void WontCompile() {
   std::set<int> set;
-  span<int> span(set.begin(), 0u);
+  span<int> span(set.begin(), 0);
 }
 
 #elif defined(NCTEST_STD_SET_ITER_ITER_CONVERSION_DISALLOWED)  // [r"fatal error: no matching constructor for initialization of 'span<int>'"]
@@ -131,7 +131,7 @@ void WontCompile() {
 // Static first called on a span with static extent must not exceed the size.
 void WontCompile() {
   std::array<int, 3> array = {1, 2, 3};
-  span<int, 3u> span(array);
+  span<int, 3> span(array);
   auto first = span.first<4>();
 }
 
@@ -140,7 +140,7 @@ void WontCompile() {
 // Static last called on a span with static extent must not exceed the size.
 void WontCompile() {
   std::array<int, 3> array = {1, 2, 3};
-  span<int, 3u> span(array);
+  span<int, 3> span(array);
   auto last = span.last<4>();
 }
 
@@ -149,7 +149,7 @@ void WontCompile() {
 // Static subspan called on a span with static extent must not exceed the size.
 void WontCompile() {
   std::array<int, 3> array = {1, 2, 3};
-  span<int, 3u> span(array);
+  span<int, 3> span(array);
   auto subspan = span.subspan<4>();
 }
 
@@ -158,7 +158,7 @@ void WontCompile() {
 // Static subspan called on a span with static extent must not exceed the size.
 void WontCompile() {
   std::array<int, 3> array = {1, 2, 3};
-  span<int, 3u> span(array);
+  span<int, 3> span(array);
   auto subspan = span.subspan<0, 4>();
 }
 
@@ -174,7 +174,7 @@ void WontCompile() {
 
 // Front called on an empty span with static extent is not allowed.
 void WontCompile() {
-  span<int, 0u> s;
+  span<int, 0> s;
   s.front();
 }
 
@@ -182,7 +182,7 @@ void WontCompile() {
 
 // Back called on an empty span with static extent is not allowed.
 void WontCompile() {
-  span<int, 0u> s;
+  span<int, 0> s;
   s.back();
 }
 
@@ -191,7 +191,7 @@ void WontCompile() {
 // Calling swap on spans with different extents is not allowed.
 void WontCompile() {
   std::array<int, 3> array = {1, 2, 3};
-  span<int, 3u> static_span(array);
+  span<int, 3> static_span(array);
   span<int> dynamic_span(array);
   std::swap(static_span, dynamic_span);
 }
@@ -234,7 +234,7 @@ int WontCompile() {
 int WontCompile() {
   constexpr StringPiece str = "Foo";
   // Intentional extent mismatch causing CHECK failure.
-  constexpr auto made_span = make_span<2>(str.begin(), 3u);
+  constexpr auto made_span = make_span<2>(str.begin(), 3);
 }
 
 #elif defined(NCTEST_STATIC_MAKE_SPAN_FROM_ITERS_CHECKS_SIZE)  // [r"constexpr variable 'made_span' must be initialized by a constant expression"]
@@ -270,7 +270,7 @@ void WontCompile() {
 #elif defined(NCTEST_DANGLING_STD_ARRAY)  // [r"object backing the pointer will be destroyed at the end of the full-expression"]
 
 void WontCompile() {
-  span<const int, 3u> s{std::array<int, 3>()};
+  span<const int, 3> s{std::array<int, 3>()};
   (void)s;
 }
 
@@ -281,24 +281,6 @@ void WontCompile() {
   (void)s;
 }
 
-#elif defined(NCTEST_MAKE_SPAN_NOT_SIZE_T_SIZE)  // [r"The source type is out of range for the destination type"]
-
-void WontCompile() {
-  int length = -1;
-  std::vector<int> vector = {1, 2, 3};
-  auto s = make_span(vector.data(), length);
-  (void)s;
-}
-
-#elif defined(NCTEST_SPAN_NOT_SIZE_T_SIZE)  // [r"The source type is out of range for the destination type"]
-
-void WontCompile() {
-  int length = -1;
-  std::vector<int> vector = {1, 2, 3};
-  span<int> s(vector.data(), length);
-  (void)s;
-}
-
 #endif
 
 }  // namespace base
diff --git a/base/files/file_descriptor_watcher_posix_unittest.cc b/base/files/file_descriptor_watcher_posix_unittest.cc
index a8dc7cbe56..099f148806 100644
--- a/base/files/file_descriptor_watcher_posix_unittest.cc
+++ b/base/files/file_descriptor_watcher_posix_unittest.cc
@@ -127,7 +127,7 @@ class FileDescriptorWatcherTest
   void WriteByte() {
     constexpr char kByte = '!';
     ASSERT_TRUE(WriteFileDescriptor(write_file_descriptor(),
-                                    as_bytes(make_span(&kByte, 1u))));
+                                    as_bytes(make_span(&kByte, 1))));
   }
 
   void ReadByte() {
diff --git a/base/json/json_writer_unittest.cc b/base/json/json_writer_unittest.cc
index 8fc132923f..4b2e7975dc 100644
--- a/base/json/json_writer_unittest.cc
+++ b/base/json/json_writer_unittest.cc
@@ -116,7 +116,7 @@ TEST(JSONWriterTest, BinaryValues) {
   // Binary values should return errors unless suppressed via the
   // OPTIONS_OMIT_BINARY_VALUES flag.
   const auto kBufferSpan =
-      base::make_span(reinterpret_cast<const uint8_t*>("asdf"), 4u);
+      base::make_span(reinterpret_cast<const uint8_t*>("asdf"), 4);
   Value root(kBufferSpan);
   EXPECT_FALSE(JSONWriter::Write(root, &output_js));
   EXPECT_TRUE(JSONWriter::WriteWithOptions(
diff --git a/base/task/thread_pool/thread_pool_impl_unittest.cc b/base/task/thread_pool/thread_pool_impl_unittest.cc
index e0f712cf73..fd14425a89 100644
--- a/base/task/thread_pool/thread_pool_impl_unittest.cc
+++ b/base/task/thread_pool/thread_pool_impl_unittest.cc
@@ -962,7 +962,7 @@ TEST_P(ThreadPoolImplTest, FileDescriptorWatcherNoOpsAfterShutdown) {
   thread_pool_->Shutdown();
 
   constexpr char kByte = '!';
-  ASSERT_TRUE(WriteFileDescriptor(pipes[1], as_bytes(make_span(&kByte, 1u))));
+  ASSERT_TRUE(WriteFileDescriptor(pipes[1], as_bytes(make_span(&kByte, 1))));
 
   // Give a chance for the file watcher to fire before closing the handles.
   PlatformThread::Sleep(TestTimeouts::tiny_timeout());
diff --git a/ipc/ipc_mojo_bootstrap_unittest.cc b/ipc/ipc_mojo_bootstrap_unittest.cc
index f7bd5f5c08..8771bcdd69 100644
--- a/ipc/ipc_mojo_bootstrap_unittest.cc
+++ b/ipc/ipc_mojo_bootstrap_unittest.cc
@@ -206,8 +206,8 @@ MULTIPROCESS_TEST_MAIN_WITH_SETUP(
   auto& sender = connection.GetSender();
 
   uint8_t data = 0;
-  sender->Receive(IPC::MessageView(base::make_span(&data, 0u),
-                                   absl::nullopt /* handles */));
+  sender->Receive(
+      IPC::MessageView(base::make_span(&data, 0), absl::nullopt /* handles */));
 
   base::RunLoop run_loop;
   PeerPidReceiver impl(std::move(receiver), run_loop.QuitClosure());
diff --git a/mojo/core/core_ipcz_test.cc b/mojo/core/core_ipcz_test.cc
index ea08b41464..1ea4772d70 100644
--- a/mojo/core/core_ipcz_test.cc
+++ b/mojo/core/core_ipcz_test.cc
@@ -275,7 +275,7 @@ TEST_F(CoreIpczTest, BasicMessageUsage) {
   EXPECT_EQ(MOJO_RESULT_OK, mojo().CreateMessagePipe(nullptr, &a, &b));
 
   constexpr base::StringPiece kMessage = "hellllooooo";
-  MojoMessageHandle message = CreateMessage(kMessage, {&b, 1u});
+  MojoMessageHandle message = CreateMessage(kMessage, {&b, 1});
 
   void* buffer;
   uint32_t num_bytes;
@@ -316,7 +316,7 @@ TEST_F(CoreIpczTest, MessageDestruction) {
   EXPECT_EQ(MOJO_RESULT_OK, mojo().CreateMessagePipe(nullptr, &a, &b));
 
   constexpr base::StringPiece kMessage = "hellllooooo";
-  MojoMessageHandle message = CreateMessage(kMessage, {&b, 1u});
+  MojoMessageHandle message = CreateMessage(kMessage, {&b, 1});
 
   // Destroying the message must also close the attached pipe.
   MojoHandleSignalsState signals_state;
@@ -874,7 +874,7 @@ DEFINE_TEST_CLIENT_TEST_WITH_PIPE(DataPipeTransferClient,
   EXPECT_EQ(MOJO_RESULT_OK, mojo().Close(invitation));
 
   MojoHandle consumer;
-  EXPECT_EQ("", ReadFromMessagePipe(new_pipe, {&consumer, 1u}));
+  EXPECT_EQ("", ReadFromMessagePipe(new_pipe, {&consumer, 1}));
   EXPECT_NE(MOJO_HANDLE_INVALID, consumer);
 
   WaitForReadable(consumer);
@@ -927,7 +927,7 @@ TEST_F(CoreIpczTest, DataPipeTransfer) {
                   mojo().CreateDataPipe(&options, &producer, &consumer));
         EXPECT_EQ(MOJO_RESULT_OK,
                   mojo().WriteMessage(
-                      new_pipe, CreateMessage("", {&consumer, 1u}), nullptr));
+                      new_pipe, CreateMessage("", {&consumer, 1}), nullptr));
         EXPECT_EQ(MOJO_RESULT_OK, mojo().Close(new_pipe));
 
         // First attempt an oversized write, which should fail because this
diff --git a/mojo/core/ipcz_driver/transport_test.cc b/mojo/core/ipcz_driver/transport_test.cc
index 01f40dc558..493d4f2ad2 100644
--- a/mojo/core/ipcz_driver/transport_test.cc
+++ b/mojo/core/ipcz_driver/transport_test.cc
@@ -319,8 +319,8 @@ TEST_F(MojoIpczTransportTest, TransmitHandle) {
         MakeHandleFromEndpoint(channel2.TakeRemoteEndpoint());
     {
       TransportListener listener(*transport);
-      TestMessage("!", {&handle1, 1u}).Transmit(*transport);
-      TestMessage("!", {&handle2, 1u}).Transmit(*transport);
+      TestMessage("!", {&handle1, 1}).Transmit(*transport);
+      TestMessage("!", {&handle2, 1}).Transmit(*transport);
       listener.WaitForDisconnect();
     }
 
-- 
2.39.2.637.g21b0678d19-goog

