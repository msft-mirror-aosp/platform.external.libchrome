// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import {mojo} from '//resources/mojo/mojo/public/js/bindings.js';

{% for path, types in converter_imports.items()|sort -%}
import type {
{%- for type in types|sort %}
  {{type}}
{%- if not loop.last -%},{% endif -%}
{%- endfor %}
} from '{{path}}';
{% endfor %}

{%- for struct in typemapped_structs %}

export class {{struct.name}}DataView {
  private readonly decoder_: mojo.internal.Decoder;
  private readonly version_: number;
  private readonly fieldSpecs_: Array<mojo.internal.StructFieldSpec<any, any>>;

  constructor(decoder: mojo.internal.Decoder,
              version: number,
              fieldSpecs: Array<mojo.internal.StructFieldSpec<any, any>>) {
    this.decoder_ = decoder;
    this.version_ = version;
    this.fieldSpecs_ = fieldSpecs;
  }
{%-    for packed_field in struct.packed.packed_fields_in_ordinal_order %}
{%-      set f = packed_field.field %}

  get {{f.name}}(): {{f.kind|ts_type_maybe_nullable}} {
    const field = this.fieldSpecs_[{{loop.index0}}];
{%-       if packed_field|is_nullable_value_kind_packed_field %}
{# TODO(ffred): nullable primitives don't generate correct converter #}
{# interfaces atm. #}
    throw new Error("unsupported");
{%-       else %}
    return mojo.internal.decodeStructField(this.decoder_, field!, this.version_);
{%-       endif %}
  }
{%-   endfor %}
}

export interface {{struct.name}}TypeMapper<T> {
  // Encoding:
  {%- for packed_field in struct.packed.packed_fields_in_ordinal_order %}
    {%- set f = packed_field.field %}
  {{f.name}}(mappedTyped: T): {{f.kind|ts_type_maybe_nullable}};
  {%- endfor %}

  // Decoding:
  convert(dataView: {{struct.name}}DataView): T;
}

{% endfor -%}
